

# ——C++标准库系列——

# 时间日期

## 1.引言

C++ `std::chrono`时间库是C++标准库提供的一个时间处理库，提供了一个方便、灵活和精确的时间处理工具，用于在程序中进行时间相关的操作和计算。它具有以下重要性和作用：

1. **精确的时间计量**
   `std::chrono`时间库提供了高精度的时间计量单位和操作，可以精确测量和计算代码的执行时间、延时等。
2. **跨平台兼容性**
   `std::chrono`时间库在不同平台上都具备良好的兼容性，无论是Windows、Linux还是其他操作系统，都可以使用该库进行时间处理，使代码具备良好的可移植性。
3. **高度可扩展性**
   该库提供了丰富的时间单位和精度选项，适应不同场景下的时间计算需求。无论是秒、毫秒、微秒还是纳秒的时间单位，都可以很方便地应用于代码中。
4. **时钟的灵活选择**
   `std::chrono`时间库提供了不同类型的时钟，如系统时钟（system_clock）、稳定时钟（steady_clock）和高分辨率时钟（high_resolution_clock），可以根据具体需求选择合适的时钟类型。
5. **时间点和时间段的处理**
   该库提供了表示时间点（time_point）和时间段（duration）的相关类，可以对时间进行精确刻度和处理。时间点表示具体的时间，时间段表示两个时间点之间的时间差。

C++ `std::chrono`时间库能够帮助准确测量和控制代码的执行时间，处理定时任务，进行时间间隔计算等操作。

## 2.时间库概述

### 1.命名空间的作用

C++ `std::chrono`命名空间是C++标准库中的一个命名空间，它包含了一组用于处理时间和时间相关操作的类和函数。该命名空间提供了丰富的时间处理功能，旨在**方便**进行时间计算、测量和控制。`std::chrono`命名空间的主要作用和用途：

1. **提供时间单位和精度的定义**
   `std::chrono`命名空间定义了一系列时间单位，如秒（seconds）、毫秒（milliseconds）、微秒（microseconds）和纳秒（nanoseconds），以及精度等级，如高精度时钟（high_resolution_clock）和稳定时钟（steady_clock）。这些定义使得时间计算和测量更加灵活和精确。
2. **定义时间段和时间点的概念**
   `std::chrono`命名空间提供了表示时间段（duration）和时间点（time_point）的相关类，包括`std::chrono::duration`和`std::chrono::time_point`。时间段表示两个时间点之间的时间差，时间点表示具体的时间。
3. **支持时间的计算和操作**
   该命名空间提供了各种用于时间计算和操作的函数和操作符。例如，可以通过相加或相减两个时间点或时间段来计算时间的差异、延迟或间隔。也可以比较两个时间点的先后顺序，判断时间的先后关系。
4. **管理和控制时间流逝**
   `std::chrono`命名空间提供了函数和工具，可用于管理和控制时间的流逝。例如，可以获取当前的系统时间和时钟时间，或者获取程序执行的实际时间。还可以设置**定时任务**或者延时执行代码。
5. `std::chrono`命名空间是C++标准库的一部分，因此它具有跨平台的兼容性，并且在不同的操作系统中都能正常工作。

### 2.基本组成部分

时间库的基本组成部分包括**duration（时间段）**、time_point（时间点）和**clock（时钟）**。它们相互配合，用于表示和处理时间的不同方面。

1. **duration（时间段）**
   duration是时间库中表示时间段的类。它表示两个时间点之间的时间差。时间段可以用秒（seconds）、毫秒（milliseconds）、微秒（microseconds）等不同的单位来表示。**duration类的模板参数包括时间单位和所需的精度**。比如：`std::chrono::duration<int, std::ratio<1, 1000>>`表示毫秒级别的时间段。在使用Duration时，可以进行加减、比较和表示等操作。
2. **time_point（时间点）**
   time_point表示一个特定的时间点，可以理解为时间的戳记。时间点和时间段之间可以进行加减运算，用于计算时间的差异或延迟。time_point类的模板**参数包括所采用的时钟类型和时间单位**。比如：`std::chrono::time_point<std::chrono::system_clock, std::chrono::nanoseconds>`表示系统时钟下的纳秒级时间点。可以获取当前的时间点、比较不同时间点的顺序，以及对时间点进行格式化等操作。
3. **clock（时钟）**
   clock是时间库中的时钟类，用于提供时间的基准和计量。不同的时钟类型提供不同的时间精度和功能。常用的时钟类型有系统时钟（system_clock）、稳定时钟（steady_clock）和高精度时钟（high_resolution_clock）。系统时钟提供了与操作系统相关的时间，稳定时钟提供了稳定的、不受系统时间变化影响的时间，而高精度时钟提供了更高的时间精度。时钟类可以获取当前时间，计算时间的间隔和延迟等。

这三个基本组成部分相互配合，使时间库具有了强大的时间处理能力。Duration表示时间段，Time_point表示时间点，而Clock则提供了时钟的基准。通过使用它们，可以对时间进行准确的计算、比较和操作，从而灵活地处理时间相关的任务和逻辑。

## 3.`duration`的使用详解

### 1.概念和使用方法

Duration（时间段）是时间库中表示时间间隔的类，用于表示两个时间点之间的时间差。

#### 1.表示和定义duration

   duration类是一个模板类，模板参数包括时间单位和精度。时间单位可以是秒（seconds）、毫秒（milliseconds）、微秒（microseconds）或纳秒（nanoseconds），精度可以是整数类型（int、long）、浮点类型（float、double）等。例如，可以定义一个表示毫秒级别的时间段：`std::chrono::duration<int, std::milli>`。

#### 2.创建duration对象

   可以通过直接给Duration对象赋值来创建它。对Duration对象的赋值可以使用整数、浮点数、其他duration对象，以及乘法、除法、加法和减法等操作。例如：

```cpp
std::chrono::duration<int, std::milli> duration1(500); // 创建一个表示500毫秒的duration对象
std::chrono::duration<double, std::ratio<1, 1000>> duration2 = std::chrono::milliseconds(2.5); // 创建一个表示2.5毫秒的duration对象
std::chrono::duration<float, std::ratio<1>> duration3 = duration1 + duration2; // 创建一个表示3秒的duration对象
```

注意：`std::chrono::duration<double>(2.5)` 默认表示2.5秒，因为没有指定时间单位。 将一个表示秒的duration对象赋值给一个表示毫秒的   duration对象时，需要进行单位转换。

#### 3.访问duration的值:

可以使用成员函数count()来访问Duration对象的值。count()函数返回Duration对象表示的时间段值，以它所定义的时间单位返回。例如：

```cpp
std::chrono::duration<int, std::milli> duration(500);
int milliseconds = duration.count(); // 返回500
```

#### 4.操作duration

可以使用各种数学运算符对duration对象进行加法、减法、乘法和除法等操作。这些操作在逻辑上保持了时间单位的一致性。例如：

```cpp
std::chrono::duration<int, std::milli> duration1(500);
std::chrono::duration<double, std::nano> duration2(1.5);
std::chrono::duration<int, std::micro> duration3 = duration1 + duration2; // 表示 500,000 微秒。

std::chrono::duration<int, std::milli> duration4 = duration1 * 2; // 表示1000毫秒
std::chrono::duration<double, std::milli> duration5 = duration2 / 2; // 表示 0.00000075 毫秒。
```

#### 5.比较duration:

可以使用比较运算符（<、<=、>、>=、==、!=）来比较duration对象之间的大小关系。比较操作是基于Duration对象所表示的时间单位进行的。例如：

```cpp
std::chrono::duration<int, std::milli> duration1(500);
std::chrono::duration<double, std::nano> duration2(1.5);
bool result = duration1 > duration2; // 返回true，因为500毫秒大于1.5纳秒
```

### 2.各种单位和精度选项

#### 1.时间单位（Time Units）

时间单位表示Duration所表示时间间隔的度量单位。时间单位包括：

- 纳秒（nanoseconds）：`std::chrono::nanoseconds`
- 微秒（microseconds）：`std::chrono::microseconds`
- 毫秒（milliseconds）：`std::chrono::milliseconds`
- 秒（seconds）：`std::chrono::seconds`
- 分钟（minutes）：`std::chrono::minutes`
- 小时（hours）：`std::chrono::hours`

这些单位可以提供不同精度的时间间隔表示。

#### 2.精度（Precision）

精度表示duration所使用的数值类型，可以是整型（整数类型）或浮点型（浮点数类型）。可以使用标准数值类型（如int、long、float、double）作为Duration的数值类型，并与所选的时间单位进行配对。

例如，可以选择使用以下精度选项：

- 整数类型精度：`std::chrono::duration<int, TimeUnit>`
- 长整数类型精度：`std::chrono::duration<long, TimeUnit>`
- 浮点类型精度：`std::chrono::duration<float, TimeUnit>`
- 双精度类型精度：`std::chrono::duration<double, TimeUnit>`

例如，如果需要表示毫秒级别的时间间隔，可以选择`std::chrono::duration<int, std::milli>`，它使用整数类型表示毫秒。

下面是一些示例，展示了如何使用不同的时间单位和精度选项：

```cpp
using namespace std::chrono;

// 表示10毫秒的duration，使用整数类型精度
duration<int, std::milli> duration1(10);

// 表示5秒的duration，使用长整数类型精度
duration<long, std::seconds> duration2(5);

// 表示2.5秒的duration，使用浮点类型精度
duration<float, std::seconds> duration3(2.5);

// 表示1分钟的duration，使用双精度类型精度
duration<double, std::minutes> duration4(1);

// 可以使用auto关键字自动推导出duration的类型
auto duration5 = duration<int, std::micro>(100);
```

### 3.使用示例

以下是一些使用Duration的具体示例，涵盖时间计算和延时操作：

#### 1.时间计算示例

```cpp
#include <iostream>
#include <chrono>

int main() {
    using namespace std::chrono;

    // 创建两个时间点
    steady_clock::time_point start = steady_clock::now();
    std::this_thread::sleep_for(std::chrono::seconds(2)); // 模拟耗时操作
    steady_clock::time_point end = steady_clock::now();

    // 计算时间间隔
    duration<double> duration = duration_cast<duration<double>>(end - start);

    // 输出时间间隔
    std::cout << "Elapsed time: " << duration.count() << " seconds\n";

    return 0;
}
```

上述示例中，使用steady_clock来获取当前时间点，并通过`duration_cast`将时间间隔转换为秒。最后，使用`count()`函数获取时间间隔的值并进行输出。

#### 2.延时操作示例

```cpp
#include <iostream>
#include <chrono>
#include <thread>

int main() {
    using namespace std::chrono;

    std::cout << "Start" << std::endl;

    // 进行延时操作，暂停程序执行
    std::this_thread::sleep_for(std::chrono::seconds(2));

    std::cout << "End" << std::endl;

    return 0;
}
```

使用`this_thread::sleep_for`函数来进行延时操作，程序会暂停执行2秒钟，然后继续往下执行。

## 4.`time_point`的使用详解

### 1.概念

time_point（时间点）是`std::chrono`库中用于表示具体时间的类型。它表示了某个具体时刻的时间点，可以用于比较不同时间点的时间先后或时间间隔的计算。`time_point`由两部分组成：时钟（Clock）和表示时间的持续时间（Duration）。

1. **时钟（Clock）**
   时钟是`std::chrono`库中的一种类型，用于测量时间的流逝。`std::chrono`库提供了几种不同的时钟类型，包括steady_clock（稳定时钟）、system_clock（系统时钟）和high_resolution_clock（高分辨率时钟）等。不同的时钟类型提供了不同的时间精度和适用范围。
2. **表示时间的持续时间（Duration）**
   Duration表示时间的长度或时间间隔，可以是纳秒、微秒、毫秒、秒、分钟、小时等不同的时间单位。Duration类的模板参数指定了时间长度的数值类型和时间单位。

### 2.使用方法

要创建一个time_point对象，需要指定时钟类型和持续时间。可以使用当前的时钟来获取当前时间点，也可以根据需求指定一个特定的时间点。示例：

```cpp
#include <iostream>
#include <chrono>

int main() {
    using namespace std::chrono;

    // 使用系统时钟获取当前时间点
    std::chrono::system_clock::time_point now = std::chrono::system_clock::now();

    // 创建一个表示特定时间点的time_point
    std::chrono::system_clock::time_point specific_time = 
        std::chrono::system_clock::time_point(std::chrono::seconds(1625100000));

    // 比较两个时间点的先后
    if (now > specific_time) {
        std::cout << "The current time is later than the specific time.\n";
    } else {
        std::cout << "The current time is earlier than the specific time.\n";
    }

    // 计算时间间隔
    std::chrono::duration<double> duration = now - specific_time;
    std::cout << "The duration between the two time points is: " << duration.count() << " seconds.\n";

    return 0;
}
```

通过`std::chrono`库中的system_clock获取了当前时间点，并通过手动指定一个特定的时间点。然后，可以比较这两个时间点的先后，并计算它们之间的时间间隔。

### 3.`time_point`与`duration`之间的关系

- time_point表示一个具体的时间点，可以视为时间的参考点或标记。它由两个组成部分构成：时钟（Clock）和持续时间（Duration）。时钟指定了时间的基准和精度，而持续时间表示两个时间点之间的时间间隔。

- duration表示一个时间长度或时间间隔，它可以是纳秒、微秒、毫秒、秒、分钟、小时等不同的时间单位。duration模板类的参数指定了时间长度的数值类型和时间单位。持续时间的正负值决定了时间间隔是向前还是向后。


time_point和duration之间的关系：

1. 通过time_point和duration的组合，可以表示一个时间点，也可以计算两个时间点之间的时间间隔。
2. 可以在time_point上添加或减去某个duration，以获得新的time_point。例如，可以将一个time_point向前推进一个duration，或者将一个duration加上一个time_point来计算未来的时间点。
3. 可以通过计算两个time_point之间的时间间隔，得到一个duration对象。这是通过减去一个time_point（较早的时间点）从另一个time_point（较晚的时间点）来实现的。

下面是一个使用time_point和duration的示例，展示了它们之间的关系：

```cpp
#include <iostream>
#include <chrono>

int main() {
    using namespace std::chrono;

    // 获取当前时间点
    system_clock::time_point start = system_clock::now();

    // 进行一些耗时操作
    std::this_thread::sleep_for(std::chrono::seconds(2));

    // 获取后续的时间点
    system_clock::time_point end = system_clock::now();

    // 计算时间间隔
    duration<double> duration = duration_cast<duration<double>>(end - start);

    // 输出时间间隔
    std::cout << "Elapsed time: " << duration.count() << " seconds\n";

    return 0;
}
```

说明：使用system_clock获取了开始和结束的时间点，然后通过减法操作计算时间间隔duration。最后，使用duration的count()方法获取时间间隔的值，并输出结果。这个示例演示了如何结合使用time_point和duration来计算时间间隔。

### 4.如何创建、比较和操作time_point对象

演示了如何创建、比较和操作time_point对象：

```cpp
#include <iostream>
#include <chrono>

int main() {
    using namespace std::chrono;

    // 创建一个time_point对象 - 使用系统时钟获取当前时间点
    system_clock::time_point now = system_clock::now();

    // 创建一个time_point对象 - 手动指定一个特定时间点
    system_clock::time_point specific_time = system_clock::time_point(seconds(1625100000));//这是一个时间持续量，表示从system_clock的起始时间（1970年1月1日00:00:00 UTC）开始经过的秒数。

    // 比较两个time_point对象的先后
    if (now > specific_time) {
        std::cout << "The current time is later than the specific time.\n";
    } else {
        std::cout << "The current time is earlier than the specific time.\n";
    }

    // 操作time_point对象，计算时间间隔
    system_clock::time_point future = now + hours(48);
    duration<double> duration = duration_cast<duration<double>>(future - now);
    std::cout << "The duration between now and future is: " << duration.count() << " seconds.\n";

    return 0;
}
```

说明：使用system_clock获取了当前时间点，并通过手动指定一个特定的时间点创建了另一个time_point对象。然后，比较这两个time_point对象的先后关系，并输出结果。接下来，操作time_point对象，通过将一个duration（48小时）加到当前时间点上，得到一个未来的时间点。最后，我们计算了当前时间点和未来时间点之间的时间间隔，并输出结果。

注意：在计算时间间隔时，使用了duration_cast将时间间隔转换为所需的duration类型（在这里是double类型）。

## 5.clock的使用详解

### 1.不同类型的clock

在std::chrono库中，存在三种不同类型的时钟：system_clock、steady_clock和high_resolution_clock。它们都用于表示时间点和测量时间间隔，但在实际应用中会有一些区别。

#### 1.system_clock

- system_clock是系统级别的时钟，它表示实时时钟，也就是指示当前时间的时钟。它的时间点是与系统的时钟相关联的，可能受到时钟调整和时区的影响。
- system_clock用于获取当前的系统时间，可以用来进行日常时间计算和显示。它通常被用作默认的时钟类型。
- system_clock的最小时间单位取决于系统，可能是秒、毫秒或微秒。

#### 2.steady_clock

- steady_clock是一个单调递增的时钟，不受任何时钟调整或时区的影响。它提供了一个稳定、可靠的时间基准，适合用于测量时间间隔和计算算法的执行时间。
- steady_clock的最小时间单位取决于实现，通常是纳秒或微秒级别。

#### 3.high_resolution_clock

- high_resolution_clock是一个可用于测量小时间间隔的时钟。它通常使用最高分辨率的时钟源来提供更高的时间精度。在大部分平台上，high_resolution_clock是steady_clock的别名，因此也是一个单调递增的时钟。
- high_resolution_clock的最小时间单位取决于实现，通常是纳秒或微秒级别。

使用不同类型的时钟的示例：

```cpp
#include <iostream>
#include <chrono>

int main() {
    using namespace std::chrono;

    // 使用system_clock获取当前时间
    system_clock::time_point system_now = system_clock::now();

    // 使用steady_clock获取开始时间
    steady_clock::time_point steady_start = steady_clock::now();

    // 一些操作...

    // 使用steady_clock获取结束时间
    steady_clock::time_point steady_end = steady_clock::now();

    // 使用high_resolution_clock获取开始时间
    high_resolution_clock::time_point high_res_start = high_resolution_clock::now();

    // 一些操作...

    // 使用high_resolution_clock获取结束时间
    high_resolution_clock::time_point high_res_end = high_resolution_clock::now();

    // 输出时间间隔
    duration<double> steady_duration = duration_cast<duration<double>>(steady_end - steady_start);
    duration<double> high_res_duration = duration_cast<duration<double>>(high_res_end - high_res_start);

    std::cout << "Steady duration: " << steady_duration.count() << " seconds.\n";
    std::cout << "High resolution duration: " << high_res_duration.count() << " seconds.\n";

    return 0;
}
```

说明：使用system_clock获取了当前时间，使用steady_clock和high_resolution_clock获取了开始和结束时间。然后，通过减法操作计算了时间间隔，并使用duration_cast将时间间隔转换为double类型的秒数。最后，输出了steady_clock和high_resolution_clock的时间间隔。

### 2.每种clock的特点和适用场景

不同类型的时钟(system_clock、steady_clock和high_resolution_clock)具有不同的特点和适用场景

#### 1.system_clock

- 特点：system_clock是一个系统级别的时钟，用于表示实时时钟，它的时间点是与系统相关联的。它可以受到时钟调整和时区的影响。
- 适用场景：system_clock适用于获取当前的系统时间、进行日常时间计算和显示。它通常被用作默认的时钟类型。

#### 2.steady_clock

- 特点：steady_clock是一个单调递增的时钟，不受任何时钟调整或时区的影响，提供了一个稳定、可靠的时间基准。
- 适用场景：steady_clock适用于测量时间间隔、计算算法的执行时间等希望得到稳定和可靠时间测量的场景。由于不受时钟调整的影响，它特别适合用于计算程序的运行时间、测量短时间间隔等要求精确性的计时操作。

#### 3.high_resolution_clock

- 特点：high_resolution_clock是一个可用于测量小时间间隔的时钟，通常使用最高分辨率的时钟源来提供更高的时间精度。在大部分平台上，high_resolution_clock是steady_clock的别名，因此也是一个单调递增的时钟。
- 适用场景：high_resolution_clock可以用于需要更高时间精度的场景，比如测量微小的时间间隔、对性能进行优化的任务，或者需要尽可能精确的时间测量。

注意：不同的平台可能对这些时钟的实现有所不同，最小时间单位也可能有所不同。可以使用`duration_cast`将时间间隔转换为所需的时间单位（例如秒、毫秒、纳秒等）。如果需要表示当前实时时间、进行日常时间计算和显示，可以使用system_clock。而如果需要测量时间间隔、计算算法的执行时间等，可以使用steady_clock。如果需要更高的时间精度，可以使用high_resolution_clock。

## 6.应用示例

### 1.定时任务

可以使用std::this_thread::sleep_for函数来创建定时任务。每隔一秒打印一次消息的示例：

```cpp
#include <iostream>
#include <chrono>
#include <thread>

int main() {
    while (true) {
        std::cout << "Hello, World!" << std::endl;
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
```

### 2.测量代码执行时间

使用std::chrono::steady_clock可以测量代码块的执行时间。测量排序算法的执行时间：

```cpp
#include <iostream>
#include <chrono>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> nums = {5, 2, 8, 1, 9};

    auto start = std::chrono::steady_clock::now();
    std::sort(nums.begin(), nums.end());
    auto end = std::chrono::steady_clock::now();

    std::chrono::duration<double> diff = end - start;
    std::cout << "Sorting took " << diff.count() << " seconds." << std::endl;

    return 0;
}
```

### 3.使代码跨平台

使用std::chrono可以实现跨平台的时间处理，**避免依赖于特定平台的系统调用**。获取当前时间点并打印出来：

```cpp
#include <iostream>
#include <chrono>

int main() {
    auto now = std::chrono::system_clock::now();
    std::time_t time = std::chrono::system_clock::to_time_t(now);

    std::cout << "Current time: " << std::ctime(&time) << std::endl;

    return 0;
}
```

### 4.时间格式化

std::chrono库提供了一些用于格式化时间的函数和类。可以使用std::put_time函数将时间对象格式化为字符串，并指定所需的时间格式。它接受一个时间对象和格式化字符串作为参数，返回一个格式化后的字符串。示例代码如下：

```cpp
#include <iostream>
#include <chrono>
#include <iomanip>

int main() {
    auto now = std::chrono::system_clock::now();
    std::time_t t = std::chrono::system_clock::to_time_t(now);
    std::cout << "Current time: " << std::put_time(std::localtime(&t), "%c") << std::endl;
    return 0;
}
```

说明：将当前时间格式化为日期和时间的字符串，并以本地时间格式（“%c”）进行输出。

## 7.总结

C++的std::chrono时间库提供了处理时间相关操作的功能。

### 1.核心概念

1. 时钟（Clock）：表示时间的源头，提供了时间的基准和刻度。常见的时钟有系统时钟（system_clock）、稳定时钟（steady_clock）和高精度时钟（high_resolution_clock）。
2. 时间点（Time Point）：表示特定时钟上的一个时间。时间点可使用时钟的成员函数now()获取，也可以通过时钟的to_time_point()函数从时间表示转换得到。
3. 时间间隔（Duration）：表示一段时间的表示，可以是秒、毫秒、微秒、纳秒等等。时间间隔的类型为duration，比如duration<int, std::ratio<1, 1000>>表示毫秒。

### 2.使用方法

（1）获取当前时间点：使用时钟的now()成员函数可以获取当前时间点，返回一个时间点对象。

```cpp
std::chrono::system_clock::time_point now = std::chrono::system_clock::now();
```

（2）计算时间间隔：使用时间点对象相减可以计算时间间隔，返回一个时间间隔对象。

```cpp
std::chrono::duration<double> diff = end - start;
double seconds = diff.count();
```

（3）休眠指定时间：使用std::this_thread::sleep_for()函数可以使当前线程休眠指定的时间间隔。

```cpp
std::this_thread::sleep_for(std::chrono::seconds(1));
```

（4）转换时间表示：可以通过时钟的成员函数to_time_t()将时间点对象转换为time_t表示，或使用ctime()函数将time_t转换为字符串表示。

```cpp
std::time_t time = std::chrono::system_clock::to_time_t(now);
std::cout << "Current time: " << std::ctime(&time) << std::endl;
```

# C++多线程

传统的C++（C++11标准之前）中并没有引入线程这个概念，在C++11出来之前，如果我们想要在C++中实现多线程，需要借助操作系统平台提供的API，比如Linux的，或者windows下的。C++11提供了语言层面上的多线程，包含在头文件中。它解决了跨平台的问题，提供了管理线程、保护共享数据、线程间同步操作、[原子操作](https://so.csdn.net/so/search?q=原子操作&spm=1001.2101.3001.7020)等类。C++11 新标准中引入了5个头文件来支持多线程编程，如下图所示：

![6ff198ce5e3668b31e6dd7ae04f5e9fa.png](https://i-blog.csdnimg.cn/blog_migrate/9ddead4412c551dbd816ee91d7a4164a.png)

## 1.多进程与多线程

### 1.多进程并发

使用多进程并发是将一个应用程序划分为多个独立的进程（每个进程只有一个线程），这些独立的进程间可以互相通信，共同完成任务。由于操作系统对进程提供了大量的保护机制，以避免一个进程修改了另一个进程的数据，使用多进程比使用多线程更容易写出相对安全的代码。但是这也造就了多进程并发的两个缺点：

1. 在进程间的通信，无论是使用信号、套接字，还是文件、管道等方式，其使用要么比较复杂，要么就是速度较慢或者两者兼而有之。
2. 运行多个进程的开销很大，操作系统要分配很多的资源来对这些进程进行管理。
3. 当多个进程并发完成同一个任务时，不可避免的是：**操作同一个数据和进程间的相互通信**，上述的两个缺点也就决定了多进程的并发并不是一个好的选择。所以就引入了多线程的并发。

### 2.多线程并发

多线程并发指的是在同一个进程中执行多个线程。

- **优点**
  有操作系统相关知识的应该知道，线程是轻量级的进程，每个线程可以独立的运行不同的指令序列，但是线程不独立的拥有资源，依赖于创建它的进程而存在。也就是说，同一进程中的多个线程共享相同的地址空间，可以访问进程中的大部分数据，指针和引用可以在线程间进行传递。这样，同一进程内的多个线程能够很方便的进行数据共享以及通信，也就比进程更适用于并发操作。
- **缺点**
  由于缺少操作系统提供的保护机制，在多线程共享数据及通信时，就需要程序员做更多的工作以保证对共享数据段的操作是以预想的操作顺序进行的，并且要极力的避免死锁(deadlock)。

## 2.创建线程

创建线程很简单，只需要把函数添加到线程当中即可。

- 方法1

  ```c++
  std::thread myThread (thread_fun);
  //函数形式为void thread_fun()
  myThread.join();
  //同一个函数可以代码复用，创建多个线程
  ```

- 方法2

  ```c++
  std::thread myThread (thread_fun(100));
  myThread.join();
  //函数形式为void thread_fun(int x)
  //同一个函数可以代码复用，创建多个线程
  ```

- f：

```c++
std::thread (thread_fun,1).detach();
//直接创建线程，没有名字
//函数形式为void thread_fun(int x)
```

- For Example

```c++
using namespace std;
void thread_1(){
	cout<<"子线程1"<<endl;
}
void thread_2(int x){
	cout<<"x:"<<x<<endl</x<<;
	cout<<"子线程2"<<endl;
}
int main()
{
	thread first (thread_1); // 开启线程，调用：thread_1()
	thread second (thread_2,100); // 开启线程，调用：thread_2(100)
	thread third(thread_2,3);//开启第3个线程，共享thread_2函数。
	std::cout << "主线程\n";
  	first.join(); //必须说明添加线程的方式            
  	second.join(); 
  	std::cout << "子线程结束.\n";//必须join完成
  	return 0;
}
```

## 3.join与detach方式

- detach方式，启动的线程自主在后台运行，当前的代码继续往下执行，不等待新线程结束。
- join方式，等待启动的线程完成，才会继续往下执行。

可以使用`joinable`判断是join模式还是detach模式。

```c++
if (myThread.joinable()) foo.join();
```

#### （1）join举例

下面的代码，join后面的代码不会被执行，除非子线程结束。

```c++
using namespace std;
void thread_1()
{
  while(1)
  {
  	cout<<"子线程1"<<endl;
  }
}
void thread_2(int x)
{
  while(1)
  {
  	cout<<"子线程2222"<<endl;
  }
}
int main()
{
    thread first ( thread_1); // 开启线程，调用：thread_1()
    thread second (thread_2,100); // 开启线程，调用：thread_2(100)
    first.join(); // pauses until first finishes 这个操作完了之后才能destroyed
    second.join(); // pauses until second finishes//join完了之后，才能往下执行。
    while(1)
    {
      std::cout << "主线程\n";
    }
    return 0;
}
```

#### （2）detach举例

下列代码中，主线程不会等待子线程结束。如果主线程运行结束，程序则结束。

```c++
using namespace std;
void thread_1()
{
  while(1)
  {
      cout<<"子线程1"<<endl;
  }
}
void thread_2(int x)
{
    while(1)
    {
        cout<<"子线程2"<<endl;
    }
}
int main()
{
    thread first (thread_1);  // 开启线程，调用：thread_1()
    thread second (thread_2,100); // 开启线程，调用：thread_2(100)
    first.detach();                
    second.detach();            
    for(int i = 0; i < 10; i++)
    {
        std::cout << "主线程\n";
    }
    return 0;
}
```

## 4.this_thread

this_thread是一个命名空间，它有4个功能函数，具体如下：

| 函数        | 使用                                                  | 说明                                        |
| ----------- | ----------------------------------------------------- | ------------------------------------------- |
| get_id      | std::this_thread::get_id()                            | 获取线程id                                  |
| yield       | std::this_thread::yield()                             | 放弃线程执行，回到就绪状态                  |
| sleep_for   | std::this_thread::sleep_for(std::chrono::seconds(1)); | 暂停1秒。chrono翻译为时钟，也是一个命名空间 |
| sleep_until | 如下                                                  | 暂停直到某个时刻                            |

## 5.mutex

mutex头文件主要声明了与互斥量(mutex)相关的类。mutex提供了4种互斥类型，如下表所示。

| 类型                       | 说明                |
| -------------------------- | ------------------- |
| std::mutex                 | 最基本的 Mutex 类。 |
| std::recursive_mutex       | 递归 Mutex 类。     |
| std::time_mutex            | 定时 Mutex 类。     |
| std::recursive_timed_mutex | 定时递归 Mutex 类。 |

std::mutex 是C++11 中最基本的互斥量，std::mutex 对象提供了独占所有权的特性——即不支持递归地对 std::mutex 对象上锁，而 std::recursive_lock 则可以递归地对互斥量对象上锁。

### 2.1、lock与unlock

mutex常用操作：

> - lock()：资源上锁
> - unlock()：解锁资源
> - trylock()：查看是否上锁，它有下列3种类情况：
>
> （1）未上锁返回false，并锁住；
>
> （2）其他线程已经上锁，返回true；
>
> （3）同一个线程已经对它上锁，将会产生死锁。

死锁：是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。

下面结合实例对lock和unlock进行说明。

同一个mutex变量上锁之后，一个时间段内，只允许一个线程访问它。例如：

```

#include// std::cout



#include// std::thread



#include// std::mutex



 



 



std::mutex mtx;  // mutex for critical section



void print_block (int n, char c) 



{



// critical section (exclusive access to std::cout signaled by locking mtx):



    mtx.lock();



    for (int i=0; i



    {



       std::cout << c; 



    }



    std::cout << '\n';



    mtx.unlock();



}



int main ()



{



    std::thread th1 (print_block,50,'');//线程1：打印*



    std::thread th2 (print_block,50,'$');//线程2：打印$







 



    th1.join();



    th2.join();



    return 0;



}
```

输出：

```

**************************************************



$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
```

如果是不同mutex变量，因为不涉及到同一资源的竞争，所以以下代码运行可

能会出现交替打印的情况，或者另一个线程可以修改共同的全局变量！

```

#include // std::cout



#include // std::thread



#include // std::mutex



 



 



std::mutex mtx_1; // mutex for critical section



std::mutex mtx_2;  // mutex for critical section



int test_num = 1;



 



 



void print_block_1 (int n, char c) 



{



// critical section (exclusive access to std::cout signaled by locking mtx):



    mtx_1.lock();



    for (int i=0; i



    {



        //std::cout << c;



        test_num = 1;



        std::cout<<test_num<<std</test_num<<::endl;



    }



        std::cout << '\n';



    mtx_1.unlock();



}



 



 



void print_block_2 (int n, char c) 



{// critical section (exclusive access to std::cout signaled by locking mtx):



    mtx_2.lock();



    test_num = 2;



    for (int i=0; i



    {



    //std::cout << c;



      test_num = 2;



      std::cout<<test_num<<std</test_num<<::endl;



    }



    mtx_2.unlock();



}



 



 



int main ()



{



    std::thread th1 (print_block_1,10000,'*');



    std::thread th2 (print_block_2,10000,'$');



 



 



    th1.join();



    th2.join();



    return 0;



}
```

2.2、lock_guard

创建lock_guard对象时，它将尝试获取提供给它的互斥锁的所有权。当控制流离开lock_guard对象的作用域时，lock_guard析构并释放互斥量。

lock_guard的特点：

- 创建即加锁，作用域结束自动析构并解锁，无需手工解锁
- 不能中途解锁，必须等作用域结束才解锁
- 不能复制

代码举例

```

#include 



#include 



#include 



int g_i = 0;



std::mutex g_i_mutex;  // protects g_i，用来保护g_i



 



 



void safe_increment()



{



    const std::lock_guard<std::mutex> lock(g_i_mutex);



    ++g_i;



    std::cout << std::this_thread::get_id() << ": " << g_i << '\n';// g_i_mutex自动解锁}int main(){



    std::cout << "main id: " <<std::this_thread::get_id()<<std::endl;



    std::cout << "main: " << g_i << '\n';



 



 



    std::thread t1(safe_increment);



    std::thread t2(safe_increment);



 



 



    t1.join();



    t2.join();



 



 



    std::cout << "main: " << g_i << '\n';



}
```

说明：

1. 该程序的功能为，每经过一个线程，g_i 加1。
2. 因为涉及到共同资源g_i ，所以需要一个共同mutex：g_i_mutex。
3. main线程的id为1，所以下次的线程id依次加1。

### 2.3、unique_lock

简单地讲，unique_lock 是 lock_guard 的升级加强版，它具有 lock_guard 的所有功能，同时又具有其他很多方法，使用起来更加灵活方便，能够应对更复杂的锁定需要。

unique_lock的特点：

- 创建时可以不锁定（通过指定第二个参数为std::defer_lock），而在需要时再锁定
- 可以随时加锁解锁
- 作用域规则同 lock_grard，析构时自动释放锁
- 不可复制，可移动
- 条件变量需要该类型的锁作为参数（此时必须使用unique_lock）

所有 lock_guard 能够做到的事情，都可以使用 unique_lock 做到，反之则不然。那么何时使lock_guard呢？很简单，需要使用锁的时候，首先考虑使用 lock_guard，因为lock_guard是最简单的锁。

下面是代码举例：

```

#include 



#include 



#include 



struct Box {



    explicit Box(int num) : num_things{num} {}



    int num_things;



    std::mutex m;



};



void transfer(Box &from, Box &to, int num)



{



    // defer_lock表示暂时unlock，默认自动加锁



    std::unique_lock<std::mutex> lock1(from.m, std::defer_lock);



    std::unique_lock<std::mutex> lock2(to.m, std::defer_lock);//两个同时加锁



    std::lock(lock1, lock2);//或者使用lock1.lock()



 



 



    from.num_things -= num;



    to.num_things += num;//作用域结束自动解锁,也可以使用lock1.unlock()手动解锁



}



int main()



{



    Box acc1(100);



    Box acc2(50);



 



 



    std::thread t1(transfer, std::ref(acc1), std::ref(acc2), 10);



    std::thread t2(transfer, std::ref(acc2), std::ref(acc1), 5);



 



 



    t1.join();



    t2.join();



    std::cout << "acc1 num_things: " << acc1.num_things << std::endl;



    std::cout << "acc2 num_things: " << acc2.num_things << std::endl;



}
```

``说明：

- 该函数的作用是，从一个结构体中的变量减去一个num，加载到另一个结构体的变量中去。
- std::mutex m;在结构体中，mutex不是共享的。但是只需要一把锁也能锁住，因为引用传递后，同一把锁传给了两个函数。
- cout需要在join后面进行，要不然cout的结果不一定是最终算出来的结果。
- std::ref 用于包装按引用传递的值。
- std::cref 用于包装按const引用传递的值。

3、condition_variable

condition_variable头文件有两个variable类，一个是condition_variable，另一个是condition_variable_any。condition_variable必须结合unique_lock使用。condition_variable_any可以使用任何的锁。下面以condition_variable为例进行介绍。

condition_variable条件变量可以阻塞（wait、wait_for、wait_until）调用的线程直到使用（notify_one或notify_all）通知恢复为止。condition_variable是一个类，这个类既有构造函数也有析构函数，使用时需要构造对应的condition_variable对象，调用对象相应的函数来实现上面的功能。

| 类型               | 说明                                         |
| ------------------ | -------------------------------------------- |
| condition_variable | 构建对象                                     |
| 析构               | 删除                                         |
| wait               | Wait until notified                          |
| wait_for           | Wait for timeout or until notified           |
| wait_until         | Wait until notified or time point            |
| notify_one         | 解锁一个线程，如果有多个，则未知哪个线程执行 |
| notify_all         | 解锁所有线程                                 |
| cv_status          | 这是一个类，表示variable 的状态，如下所示    |

```cs
enum class cv_status { no_timeout, timeout };
```

3.1、wait

当前线程调用 wait() 后将被阻塞(此时当前线程应该获得了锁（mutex），不妨设获得锁 lck)，直到另外某个线程调用 notify_* 唤醒了当前线程。

在线程被阻塞时，该函数会自动调用 lck.unlock() 释放锁，使得其他被阻塞在锁竞争上的线程得以继续执行。另外，一旦当前线程获得通知(notified，通常是另外某个线程调用 notify_* 唤醒了当前线程)，wait()函数也是自动调用 lck.lock()，使得lck的状态和 wait 函数被调用时相同。

代码示例：

```

#include // std::cout



#include // std::thread, std::this_thread::yield



#include // std::mutex, std::unique_lock



#include // std::condition_variable



 



 



std::mutex mtx;



std::condition_variable cv;



int cargo = 0;



bool shipment_available() 



{



    return cargo!=0;



}



void consume (int n) 



{



    for (int i=0; i



    {



        std::unique_lock<std::mutex> lck(mtx);//自动上锁



        //第二个参数为false才阻塞（wait），阻塞完即unlock，给其它线程资源



        cv.wait(lck,shipment_available);// consume:



        std::cout << cargo << '\n';



        cargo=0;



    }



}



int main ()



{



    std::thread consumer_thread (consume,10);



    for (int i=0; i<10; ++i) 



    {



        //每次cargo每次为0才运行。



        while (shipment_available())  std::this_thread::yield();



        std::unique_lock<std::mutex> lck(mtx);



        cargo = i+1;



        cv.notify_one();



    }



 



 



    consumer_thread.join();



    return 0;



}
```

说明：

1. 主线程中的while，每次在cargo=0才运行。
2. 每次cargo被置为0，会通知子线程unblock(非阻塞)，也就是子线程可以继续往下执行。
3. 子线程中cargo被置为0后，wait又一次启动等待。也就是说shipment_available为false，则等待。

### 3.2、wait_for

与std::condition_variable::wait() 类似，不过 wait_for可以指定一个时间段，在当前线程收到通知或者指定的时间 rel_time 超时之前，该线程都会处于阻塞状态。而一旦超时或者收到了其他线程的通知，wait_for返回，剩下的处理步骤和 wait()类似。

```

template <class Rep, class Period>



  cv_status wait_for (unique_lock& lck,



                      const chrono::duration& rel_time);
```

另外，wait_for 的重载版本的最后一个参数pred表示 wait_for的预测条件，只有当 pred条件为false时调用 wait()才会阻塞当前线程，并且在收到其他线程的通知后只有当 pred为 true时才会被解除阻塞。

```

template <class Rep, class Period, class Predicate>



    bool wait_for (unique_lock& lck,



         const chrono::duration& rel_time, Predicate pred);
```

``代码示例：

```

#include // std::cout



#include // std::thread



#include // std::chrono::seconds



#include // std::mutex, std::unique_lock



#include // std::condition_variable, std::cv_status



 



 



std::condition_variable cv;



int value;



void read_value() 



{



    std::cin >> value;



    cv.notify_one();



}



int main ()



{



    std::cout << "Please, enter an integer (I'll be printing dots): \n";



    std::thread th (read_value);



 



 



    std::mutex mtx;



    std::unique_lock<std::mutex> lck(mtx);



    while (cv.wait_for(lck,std::chrono::seconds(1))==std::cv_status::timeout) 



    {



        std::cout << '.' << std::endl;



    }



    std::cout << "You entered: " << value << '\n';



 



 



    th.join();



    return 0;



}
```

- 通知或者超时都会解锁，所以主线程会一直打印。
- 示例中只要过去一秒，就会不断的打印。

4、线程池

### 4.1、概念

在一个程序中，如果我们需要多次使用线程，这就意味着，需要多次的创建并销毁线程。而创建并销毁线程的过程势必会消耗内存，线程过多会带来调动的开销，进而影响缓存局部性和整体性能。

线程的创建并销毁有以下一些缺点：

- 创建太多线程，将会浪费一定的资源，有些线程未被充分使用。
- 销毁太多线程，将导致之后浪费时间再次创建它们。
- 创建线程太慢，将会导致长时间的等待，性能变差。
- 销毁线程太慢，导致其它线程资源饥饿。

线程池维护着多个线程，这避免了在处理短时间任务时，创建与销毁线程的代价。

### 4.2、线程池的实现

因为程序边运行边创建线程是比较耗时的，所以我们通过池化的思想：在程序开始运行前创建多个线程，这样，程序在运行时，只需要从线程池中拿来用就可以了．大大提高了程序运行效率．

一般线程池都会有以下几个部分构成：

1. 线程池管理器（ThreadPoolManager）:用于创建并管理线程池，也就是线程池类
2. 工作线程（WorkThread）: 线程池中线程
3. 任务队列task: 用于存放没有处理的任务。提供一种缓冲机制。
4. append：用于添加任务的接口

线程池实现代码：

```

#ifndef _THREADPOOL_H



#define _THREADPOOL_H



#include 



#include 



#include 



#include 



#include 



#include 



#include //unique_ptr



#include



const int MAX_THREADS = 1000; //最大线程数目



template <typename T>



class threadPool



{



public:



    threadPool(int number = 1);//默认开一个线程



    ~threadPool();



    std::queuetasks_queue; //任务队列



    bool append(T *request);//往请求队列＜task_queue＞中添加任务



private:



//工作线程需要运行的函数,不断的从任务队列中取出并执行



    static void *worker(void arg);



    void run();



private:



    std::vector<std::thread> work_threads; //工作线程



 



 



    std::mutex queue_mutex;



    std::condition_variable condition;  //必须与unique_lock配合使用



    bool stop;



};//end class//构造函数，创建线程



template <typename T>



threadPool::threadPool(int number) : stop(false)



{



    if (number <= 0 || number > MAX_THREADS)



        throw std::exception();



    for (int i = 0; i < number; i++)



    {



        std::cout << "created Thread num is : " << i <<std::endl;



        work_threads.emplace_back(worker, this);



        //添加线程



        //直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。



    }



}



template <typename T>



inline threadPool::~threadPool()



{



    std::unique_lock<std::mutex> lock(queue_mutex);



    stop = true;



    



    condition.notify_all();



    for (auto &ww : work_threads)



        ww.join();//可以在析构函数中join



}



//添加任务



template <typename T>



bool threadPool::append(T *request)



{



    //操作工作队列时一定要加锁，因为他被所有线程共享



    queue_mutex.lock();//同一个类的锁



    tasks_queue.push(request);



    queue_mutex.unlock();



    condition.notify_one();  //线程池添加进去了任务，自然要通知等待的线程



    return true;



}//单个线程



template <typename T>



void threadPool::worker(void *arg)



{



    threadPool pool = (threadPool *)arg;



    pool->run();//线程运行



    return pool;



}



template <typename T>



void threadPool::run()



{



while (!stop)



{



    std::unique_lock<std::mutex> lk(this->queue_mutex);



    /*　unique_lock() 出作用域会自动解锁　/



    this->condition.wait(lk, [this] 



    { 



      return !this->tasks_queue.empty(); 



    });//如果任务为空，则wait，就停下来等待唤醒//需要有任务，才启动该线程，不然就休眠



    if (this->tasks_queue.empty())//任务为空，双重保障



    {  



        assert(0&&"断了");//实际上不会运行到这一步，因为任务为空，wait就休眠了。



        continue;



    }else{



        T *request = tasks_queue.front();



        tasks_queue.pop();



        if (request)//来任务了，开始执行



            request->process();



          }



    }



}



#endif
```

``说明：

- 构造函数创建所需要的线程数
- 一个线程对应一个任务，任务随时可能完成，线程则可能休眠，所以任务用队列queue实现（线程数量有限），线程用采用wait机制。
- 任务在不断的添加，有可能大于线程数，处于队首的任务先执行。
- 只有添加任务(append)后，才开启线程condition.notify_one()。
- wait表示，任务为空时，则线程休眠，等待新任务的加入。
- 添加任务时需要添加锁，因为共享资源。

测试代码：

```

#include "mythread.h"



#include



#include



using namespace std;



class Task



{



public:



    void process()



{



        //cout << "run........." << endl;//测试任务数量



        long i=1000000;



        while(i!=0)



        {



            int j = sqrt(i);



            i--;



        }



    }



};



int main(void){



    threadPoolpool(6);//6个线程，vector



    std::string str;



    while (1)



    {



        Task *tt = new Task();//使用智能指针



        pool.append(tt);//不停的添加任务，任务是队列queue，因为只有固定的线程数



        cout<<"添加的任务数量："<<pool.tasks_queue.size()<<endl</pool.tasks_queue.size()<<;  



        delete tt;



    }



}
```

·················· END ··················

为便于交流，我创建了几个高质量的技术群，里面有很多大佬。

如果你也想加入，可以扫描以下二维码，**加我个人微信（iwaleon），邀请入群**

# Log4cplus

## 1.Log4cplus简介

​	log4cplus是用C++编写的[开源](https://edu.csdn.net/cloud/pm_summit?utm_source=blogglc&spm=1001.2101.3001.7020)的日志系统，前身是java编写的log4j系统，受Apache Software License保护，作者是Tad E. Smith。log4cplus具有线程安全、灵活、以及多粒度控制的特点，通过将日志划分优先级使其可以面向程序调试、运行、测试、和维护等全生命周期。且其可以选择将日志输出到屏幕、文件、NT event log、甚至是远程服务器；并通过指定策略对日志进行定期备份等等。

##  2.安装方法

1. 解压: `gzip -cd log4cplus-x.x.x.tar.gz` | `tar -xvf xxx.tar`

2. 进入log4cplus根目录: `cd log4cplus-x.x.x`

3. 产生Makefile: `./configure --prefix=/where/to/install -enable-threads=no`

   如果需要指定安装路径可使用--prefix参数, 否则将缺省安装到/usr/local目录下。另外，如果需要单线程版本可通过参数-enable-threads=no指定, 否则默认将安装多线程版本。

4. 创建: `make`

5. 创建/log4cplus/tests目录下的测试用例: `make check`

6. 安装: `make install`

7. 安装成功后将在/usr/local目录或指定的目录下创建include和lib两个子目录及相应文件。其中include目录包含头文件，lib目录包含最终打包生成的静态和动态库。<u>在动态连接log4cplus库时请使用-llog4cplus选项。</u>

## 主要类说明

| 类名      | 说明                                                         |
| --------- | ------------------------------------------------------------ |
| Filter    | 过滤器，过滤输出消息。过滤器，解决哪些信息需要输出的问题，比如DEBUG，WARR,INFO等的输出控制 |
| Layout    | 布局器，控制输出消息的格式。格式化输出信息,解决了如何输出的问题。 |
| Appender  | 挂接器，与布局器和过滤器紧密配合，将特定格式的消息过滤后输出到所挂接的设备终端如屏幕，文件等等)。接收日志的各个设备,如控制台、文件、网络等。解决了输出到哪里去的问题 |
| Logger    | 记录器，保存并跟踪对象日志信息变更的实体，当你需要对一个对象进行记录时，就需要生成一个logger。日志模块,程序中唯一一个必须得使用的模块，解决了在哪里使用日志的问题。 |
| Hierarchy | 分类器，层次化的树型结构，用于对被记录信息的分类，层次中每一个节点维护一个logger的所有信息。 |
| LogLevel  | 优先权，包括TRACE,  DEBUG, INFO, WARNING, ERROR, FATAL。     |

[Log4Cplus 学习笔记 - 配置文件的使用_log4cplus 格式化字符串-CSDN博客](https://blog.csdn.net/kakiebu/article/details/105501833)

## 输出格式控制(layout)

​	log4cplus通过布局器（Layouts）来控制输出的格式，log4cplus提供了三种类型的Layouts，分别是SimpleLayout、PatternLayout、和TTCCLayout。

### SimpleLayout

​	一种简单格式的布局器，在输出的原始信息之前加上LogLevel和一个"-"，如果初始化时没有将布局器附加到挂接器，则默认使用SimpleLayout。

```shell
#比如：
DEBUG - This is  the simple formatted log message...
```

### PatternLayout

​	一种有词法分析功能的模式布局器，类似于C语言的printf()函数，能够对预定义的转换标识符（conversion specifiers）进行解析，转换成特定格式输出。

#### 转换标识符

- "%%"，转义为%, 即std::string pattern = "%%" 时输出"%"。

- "%c"，输出logger名称，比如std::string pattern ="%c" 时输出: "test_logger.subtest",也可以控制logger名称的显示层次，比如"%c{1}"时输出"test_logger"，其中数字表示层次。

- "%D"，显示本地时间，当std::string pattern ="%D" 时输出:"2004-10-16 18:55:45"，%d显示标准时间，所以当std::string pattern ="%d" 时输出"2004-10-16 10:55:45" （因为北京时间位于东8区，比标志时区早8个小时）。

- %d{...}，自定义更详细的显示格式，比如%d{%H:%M:%s}表示要显示小时:分钟:秒。大括号中可显示的预定义标识符如下：

  ```txt
  %a -- 表示礼拜几，英文缩写形式，比如"Fri"
  %A -- 表示礼拜几，比如"Friday"
  %b -- 表示几月份，英文缩写形式，比如"Oct"
  %B -- 表示几月份，"October"
  %c -- 标准的日期＋时间格式，如 "Sat Oct 16 18:56:19 2004"
  %d -- 表示今天是这个月的几号(1-31)"16"
  %H -- 表示当前时刻是几时(0-23)，如 "18"
  %I -- 表示当前时刻是几时(1-12)，如 "6"
  %j -- 表示今天是哪一天(1-366)，如 "290"
  %m -- 表示本月是哪一月(1-12)，如 "10"
  %M -- 表示当前时刻是哪一分钟(0-59)，如 "59"
  %p -- 表示现在是上午还是下午， AM or PM
  %q -- 表示当前时刻中毫秒部分(0-999)，如 "237"
  %Q -- 表示当前时刻中带小数的毫秒部分(0-999.999)，如 "430.732"
  %S -- 表示当前时刻的多少秒(0-59)，如 "32"
  %U -- 表示本周是今年的第几个礼拜，以周日为第一天开始计算(0-53)，如 "41"
  %w -- 表示礼拜几，(0-6, 礼拜天为0)，如 "6"
  %W -- 表示本周是今年的第几个礼拜，以周一为第一天开始计算(0-53)，如 "41"
  %x -- 标准的日期格式，如 "10/16/04"
  %X -- 标准的时间格式，如 "19:02:34"
  %y -- 两位数的年份(0-99)，如 "04"
  %Y -- 四位数的年份，如 "2004"
  %Z -- 时区名，比如 "GMT"
  ```

- "%F"，输出当前记录器所在的文件名称，比如std::string pattern ="%F" 时输出: "main.cpp"。

- "%L"，输出当前记录器所在的文件行号，比如std::string pattern ="%L" 时输出: "51"

- "%l"，输出当前记录器所在的文件名称和行号，比如std::string pattern ="%l" 时输出"main.cpp:51"。

- "%m"，输出原始信息，比如std::string pattern ="%m" 时输出: "teststr"，即上述代码中LOG4CPLUS_DEBUG的第二个参数，这种实现机制可以确保原始信息被嵌入到带格式的信息中。

- "%n"，换行符，没什么好解释的。

- "%p"，输出LogLevel，比如std::string pattern ="%p" 时输出: "DEBUG"。

- "%t"，输出记录器所在的线程ID，比如std::string pattern ="%t" 时输出: "1075298944"。

- "%x"，嵌套诊断上下文NDC (nested diagnostic context) 输出，从堆栈中弹出上下文信息，NDC可以用对不同源的log信息（同时地）交叉输出进行区分，关于NDC方面的详细介绍会在下文中提到。

  - ​	格式对齐，比如std::string pattern ="%-10m"时表示左对齐，宽度是10，此时会输出"teststr  "，当然其它的控制字符也可以相同的方式来使用，比如"%-12d"，"%-5p"等等。

### TTCCLayout

​	是在PatternLayout基础上发展的一种缺省的带格式输出的布局器，其格式由时间，线程ID，Logger和NDC 组成（consists of time, thread, Logger and nested diagnostic context information, hence the name），因而得名。
​	TTCCLayout在构造时，有机会选择显示本地时间或GMT时间，缺省是按照本地时间显示：`TTCCLayout::TTCCLayout(bool use_gmtime  = false)`。如果需要构造TTCCLayout对象时选择GMT时间格式，则传入`true`

## 输出重定向(appender)

### 重定向到控制台

log4cplus默认将输出到控制台，提供ConsoleAppender用于操作。

### 重定向到文件

log4cplus提供了三个类用于文件操作，它们是FileAppender类、RollingFileAppender类、DailyRollingFileAppender类。

#### FileAppender

实现了基本的文件操作功能，构造函数如下：

```c++
FileAppender::FileAppender(const log4cplus::tstring& filename,LOG4CPLUS_OPEN_MODE_TYPE mode =
LOG4CPLUS_FSTREAM_NAMESPACE::ios::trunc,bool immediateFlush = true);

/*
@filename: 文件名
@mode:     文件类型，可选择的文件类型包括app、ate、binary、in、out、trunc，因为实际上只是对stl的一个简单包装，这里就不多讲了。缺省是trunc，表示将先前文件删除。
@immediateFlush: 缓冲刷新标志，如果为true表示每向文件写一条记录就刷新一次缓存，否则直到FileAppender被关闭或文件缓存已满才更新文件，一般是要设置true的，比如你往文件写的过程中出现了错误（如程序非正常退出），即使文件没有正常关闭也可以保证程序终止时刻之前的所有记录都会被正常保存。
*/
```

#### RollingFileAppender

实现可以滚动转储的文件操作功能，构造函数如下：

```cpp
RollingFileAppender::RollingFileAppender(const log4cplus::tstring& filename,long maxFileSize,int maxBackupIndex,
bool immediateFlush=true)
/*
@filename: 文件名
@maxFileSize: 文件的最大尺寸,单位为字节，规定最小为200k==1024*200，不足200k则自动设置为200k
@maxBackupIndex: 最大记录文件数
@immediateFlush: 缓冲刷新标志
*/
```

`RollingFileAppender`类可以根据你预先设定的大小来决定是否转储，当超过该大小，后续log信息会另存到新文件中，除了定义每个记录文件的大小之外，你还要确定在RollingFileAppender类对象构造时最多需要多少个这样的记录文件(maxBackupIndex+1)，当存储的文件数目超过maxBackupIndex+1时，会删除最早生成的文件，保证整个文件数目等于maxBackupIndex+1。然后继续记录，比如以下代码片段：

```cpp
#define LOOP_COUNT 200000
 SharedObjectPtr<Appender> _append(new RollingFileAppender("Test.log", 5*1024, 5));

_append->setName("file  test");

Logger::getRoot().addAppender(_append);

Logger root =  Logger::getRoot();
Logger test =  Logger::getInstance("test");
Logger subTest =  Logger::getInstance("test.subtest");

for(int i=0; i < LOOP_COUNT; ++i)  {
    LOG4CPLUS_DEBUG(subTest, "Entering  loop #"  << i)
}
```

输出结果：

```txt
运行后会产生6个输出文件，Test.log、Test.log.1、Test.log.2、Test.log.3、Test.log.4、Test.log.5其中Test.log存放着最新写入的信息，而最后一个文件中并不包含第一个写入信息，说明已经被不断更新了。
```

<u>需要指出的是，这里除了Test.log之外，每个文件的大小都是200K，而不是我们想像中的5K，这是因为log4cplus中隐含定义了文件的最小尺寸是200K，只有大于200K的设置才生效，<= 200k的设置都会被认为是200K。</u>

#### DailyRollingFileAppender

实现根据频度来决定是否转储的文件转储功能，构造函数如下：

```cpp
DailyRollingFileAppender::DailyRollingFileAppender(const log4cplus::tstring& filename,DailyRollingFileSchedule schedule,bool immediateFlush,int maxBackupIndex)

/*
@filename: 文件名
@schedule : 存储频度
@immediateFlush  : 缓冲刷新标志
@maxBackupIndex : 最大记录文件数
*/
```

DailyRollingFileAppender类可以根据你预先设定的频度来决定是否转储，当超过该频度，后续log信息会另存到新文件中，这里的频度包括：MONTHLY（每月）、WEEKLY（每周）、DAILY（每日）、TWICE_DAILY（每两天）、HOURLY（每时）、MINUTELY（每分）。maxBackupIndex的含义同上所述，比如以下代码片段：

```c++
SharedObjectPtr<Appender> SharedAppenderPtr  _append(new  DailyRollingFileAppender("Test.log", MINUTELY, true, 5));
_append->setName("file  test");
Logger::getRoot().addAppender(_append);
Logger root =  Logger::getRoot();
Logger test =  Logger::getInstance("test");
Logger subTest =  Logger::getInstance("test.subtest");
for(int i=0; i < LOOP_COUNT; ++i) {
    LOG4CPLUS_DEBUG(subTest, "Entering  loop #"  << i)
}
```

输出结果：

```txt
运行后会以分钟为单位，分别生成名为Test.log.2004-10-17-03-03、Test.log.2004-10-17-03-04和Test.log.2004-10-17-03-05这样的文件。
```

需要指出的是这里的"频度"并不是你写入文件的速度，其实是否转储的标准并不依赖你写入文件的速度，而是依赖于写入的那一时刻是否满足了频度条件，即是否超过了以分钟、小时、周、月为单位的时间刻度，如果超过了就另存。

### 嵌入诊断上下文NDC

​	log4cplus中的嵌入诊断上下文（Nested Diagnostic Context），即NDC。对log系统而言，当输入源可能不止一个，而只有一个输出时，往往需要分辩所要输出消息的来源，比如服务器处理来自不同客户端的消息时就需要作此判断，NDC可以为交错显示的信息打上一个标记(stamp)，使得辨认工作看起来比较容易些。这个标记是线程特有的，利用了线程局部存储机制，称为线程私有数据（Thread-Specific Data，或TSD）。相关定义如下，包括定义、初始化、获取、设置和清除操作:

## 基本使用步骤

1. 实例化一个封装了输出介质的appender对象；
2. 实例化一个封装了输出格式的layout对象；
3. 将layout对象绑定(attach)到appender对象；如省略此步骤，默认是简单布局器SimpleLayo对象会绑定到logger。
4. 实例化一个封装了日志输出logger对象,并调用其静态函数getInstance()获得实例,log4cplus::Logger::getInstance("logger_name")；
5. 将appender对象绑定(attach)到logger对象；
6. 设置logger的优先级，如省略此步骤，默认各种有限级的日志都将被输出。

## 使用示例

```c++
/*
*标准使用，严格实现步骤1-6。
*/
#include <log4cplus/logger.h>
#include <log4cplus/consoleappender.h>
#include <log4cplus/layout.h>
#include <log4cplus/loggingmacros.h>
#include <unistd.h>
using namespace log4cplus;
using namespace log4cplus::helpers;
int main()
{
    /*实例化一个挂接器对象*/
    SharedObjectPtr<Appender> _append (new ConsoleAppender());
    _append->setName("append for  test");   

    /*实例化一个布局器对象*/
    std::string pattern = "%d{%Y-%m-%d %H:%M:%S} [%t] %-5p %c - %m%n";
    std::unique_ptr<Layout> _layout(new PatternLayout(pattern));    
 

    /*将挂接器与布局器连接*/
    _append->setLayout( std::move(_layout) );   
 
    /*实例化一个名为test的日志追踪器对象*/
    Logger _logger = Logger::getInstance("test");   
 
    /* step 5: Attach the appender object to the  logger  */
    _logger.addAppender(_append);   
 
    /* step 6: Set a priority for the logger  */
    _logger.setLogLevel(ALL_LOG_LEVEL);  
 
    /* log activity */
    LOG4CPLUS_DEBUG(_logger, "This is the  FIRST log message...");
    sleep(1);
    LOG4CPLUS_WARN(_logger, "This is the  SECOND log message...");
 
    return 0;
}


输出：
2024-12-13 06:54:50 [single] DEBUG test - This is the  FIRST log message...
2024-12-13 06:54:51 [single] WARN  test - This is the  SECOND log message...
```

## 脚本配置

​	除了通过程序实现对log环境的配置之外，log4cplus通过**PropertyConfigurator**类实现了基于脚本配置的功能。通过脚本可以完成对logger、appender和layout的配置，因此可以解决怎样输出，输出到哪里的问题。

### 基本配置

​	基本配置语法主要针对包括rootLogger和non-root logger。

#### 根Logger的配置

```properties
log4cplus.rootLogger=[LogLevel], appenderName, appenderName, ...
```

#### 非根Logger的配置

```properties
log4cplus.logger.logger_name=[LogLevel|INHERITED], appenderName, appenderName, ...
```

<u>说明：INHERITED表示继承父Logger的日志级别。</u>

### 高级配置

#### Appender配置

```properties
log4cplus.appender.appenderName=fully.qualified.name.of.appender.class

fully.qualified.name.of.appeneder.class可用值：
```

| log4cplus::ConsoleAppender          | 终端输出     |
| ----------------------------------- | ------------ |
| log4cplus::FileAppender             | 一般文件输出 |
| log4cplus::RollingFileAppender      | 日志大小输出 |
| log4cplus::DailyRollingFileAppender | 日期输出     |
| log4cplus::SocketAppender           | 网络端口输出 |

**文件通用选项**

| 选项           | 作用                                                         |
| -------------- | ------------------------------------------------------------ |
| ImmediateFlush | 是否立即刷新（默认为true）log4cplus.appender.ALL_MSGS.ImmediateFlush=true |
| File           | 使用的文件名log4cplus.appender.ALL_MSGS.File=all_msgs.log    |
| Append         | 是否追加到之前的文件log4cplus.appender.ALL_MSGS.Append=true  |
| ReopenDelay    | 先将日志缓存起来，等指定时间之后再往文件中插入，减少文件的保存次数。log4cplus.appender.ALL_MSGS.ReopenDelay=10【单位为秒】 |
| UseLockFile    | 是否使用加锁的方式去写文件，默认是falselog4cplus.appender.ALL_MSGS.UseLockFile=true |
| LockFile       | 使用的加锁文件名log4cplus.appender.ALL_MSGS.LockFile=fuck_are_you.lock[文件名没有具体要求] |
| Locale         | 使用的字符集log4cplus.appender.ALL_MSGS.Locale=chs【en，其他参数具体见imbue参数】 |
| Threshold      | 指定日志消息的输出最低层次log4cplus.appender.ALL_MSGS.Threshold=DEBUG |

**DailyRollingFileAppender相关配置**

| 选项           | 作用                                                         |
| -------------- | ------------------------------------------------------------ |
| Schedule       | 文件保存频率可选值：MONTHLY,  WEEKLY, DAILY,TWICE_DAILY, HOURLY, MINUTELYlog4cplus.appender.ALL_MSGS.Schedule=MINUTELY |
| MaxBackupIndex | 最多文件个数log4cplus.appender.ALL_MSGS.  MaxBackupIndex=10  |
| DatePattern    | 指定文件名的日期格式1)'.'yyyy-MM: 每月2)'.'yyyy-ww: 每周 3)'.'yyyy-MM-dd: 每天 4)'.'yyyy-MM-dd-a: 每天两次5)'.'yyyy-MM-dd-HH: 每小时6)'.'yyyy-MM-dd-HH-mm: 每分钟log4cplus.appender.ALL_MSGS.DatePattern='.'yyyy-ww |

**RollingFileAppender相关配置**

| 选项           | 作用                                                         |
| -------------- | ------------------------------------------------------------ |
| MaxFileSize    | 最大文件大小，当小于200kb的时候，默认为200kb，单位有（MB、KB）log4cplus.appender.ALL_MSGS.  MaxFileSize=10 |
| MaxBackupIndex | 最多文件个数log4cplus.appender.ALL_MSGS.  MaxBackupIndex=10  |

#### Filter配置

Appender可以附加Filter组成的链表，如果Filter链中存在过滤器Filter， log4cplus在输出日志之前将调用链表中Filter的过滤方法decide(),根据该方法的返回值决定是否过滤该输出日志。

```properties
log4cplus.appender.appenderName.Filters.FilterNumber=fully.qualified.name.of.Filter.class

log4cplus.appender.appenderName.Filters.FilterNumber.FilterCondition=value.of.FilterCondition

log4cplus.appender.appenderName.Filters.AcceptOnMatch=true|false
```

举例：

```properties
log4cplus.appender.append_1.filters.1=log4cplus::spi::LogLevelMatchFilter

log4cplus.appender.append_1.filters.1.LogLevelToMatch=TRACE

log4cplus.appender.append_1.filters.1.AcceptOnMatch=true
```

目前log4plus提供的过滤器包括DenyAllFilter 、LogLevelMatchFilter、LogLevelRangeFilter、和StringMatchFilter。

- LogLevelMatchFilter根据特定的日志级别进行过滤。
  过滤条件包括LogLevelToMatch和AcceptOnMatch（true|false）， 只有当日志的LogLevel值与LogLevelToMatch相同，且AcceptOnMatch为true时才会匹配。

- LogLevelRangeFilter根据根据日志级别的范围进行过滤。
  过滤条件包括LogLevelMin、LogLevelMax和AcceptOnMatch，只有当日志的LogLevel在LogLevelMin、LogLevelMax之间同时AcceptOnMatch为true时才会匹配。

- StringMatchFilter根据日志内容是否包含特定字符串进行过滤。
  过滤条件包括StringToMatch和AcceptOnMatch，只有当日志包含StringToMatch字符串 且AcceptOnMatch为true时会匹配。

- DenyAllFilter则过滤掉所有消息。

过滤条件处理机制类似于**Linux**中**IPTABLE**的**Responsibility chain**机制，（即先deny、再allow）不过执行顺序刚好相反，后写的条件会被先执行，比如：

```properties
log4cplus.appender.append_1.filters.1=log4cplus::spi::LogLevelMatchFilter

log4cplus.appender.append_1.filters.1.LogLevelToMatch=TRACE


log4cplus.appender.append_1.filters.1.AcceptOnMatch=true


#log4cplus.appender.append_1.filters.2=log4cplus::spi::DenyAllFilter
```

会首先执行filters.2的过滤条件，关闭所有过滤器，然后执行filters.1，仅匹配TRACE信息。

#### Layout配置

可以选择不设置、TTCCLayout、或PatternLayout，如果不设置，会输出SimpleLayout格式的日志。

设置TTCCLayout的语法 ：

```properties
log4cplus.appender.ALL_MSGS.layout=log4cplus::TTCCLayout
```

设置PatternLayout的语法：

```properties
log4cplus.appender.append_1.layout=log4cplus::PatternLayout

log4cplus.appender.append_1.layout.ConversionPattern=%d{%m/%d/%y %H:%M:%S,%Q} [%t] %-5p - %m%n
```

## 脚本配置的动态加载

​	多线程版本的log4cplus提供了实用类ConfigureAndWatchThread，该类启动线程对配置脚本进行监控，一旦发现配置脚本被更新则立刻重新加载配置。

类ConfigureAndWatchThread的构造函数定义为：

```cpp
ConfigureAndWatchThread(const log4cplus::tstring& propertyFile, unsigned int millis = 60 * 1000);
//第一个参数propertyFile为配置脚本的路径名，第二个参数为监控时两次更新检查相隔的时间，单位为耗秒ms。
```

# SFINAE

## 介绍

​	SFINAE，即`Substitution Failure Is Not an Error!`可以理解为匹配失败不是错误，更严格的说应该是**<u>参数匹配失败不是一个编译时错误</u>**。即对于通过匹配参数去特化（实例化）模版的时候，匹配失败时不会报错，还会继续去找其他的模版，但当特化好模版后，就相当于生成了对应的代码，此时编译对应代码时如果碰到错误直接报错，因为这已经不属于模版特化参数匹配的问题了。

```cpp
#include <iostream>
using namespace std;
void print( int iNum ) {
     cout<<"void print( int )"<< endl;
}
template < typename _Ty >
void print( _Ty tt ){
      typename _Ty::value_type vt_someval;
      cout<<"template < typename _Ty >"<< endl;
}
int main()
 {
     short siNum = 10;
     print( siNum );
     return 0;
}
```

​    这段代码能否通过编译呢？实践证明，这段代码无法通过编译,出现如下错误：

```shell
main.cpp: In instantiation of ‘void print(_Ty) [with _Ty = short int]’:
main.cpp:14:19: required from here
main.cpp:8:32: error: ‘short int’ is not a class, struct, or union type typename _Ty::value_type vt_someval;

#即调用函数时，编译器发现没有short类型的重载函数，就会利用模版去生成，但又发现模版类型不匹配因此直接报错。
```

​    如何解决这个编译错误呢?有很多方法，比如说我们可以特化short类型:

```cpp
template <>
void print<short>( short st )
{
     cout<<"short st"<<endl;
}
```

​    实践证明，这可以解决这个错误，但是我们这里讨论的是SFINAE。看下面这段代码：

```cpp
#include <iostream>
using namespace std;
void print( int iNum )
{
     cout<<"int print( int )"<< endl;
}
template < typename _Ty >
 void print( _Ty tt, typename _Ty::value_type* pvt_dummy = NULL )
{
      typename _Ty::value_type vt_someval;
      cout<<"template < typename _Ty >"<< endl;
}

int main() {  
   short siNum = 10;
   print( siNum );
   return 0;
}
```

​    如果译器没有问题，那么这段程序是可以通过编译的。为什么编译器会放弃使用short去实例化print模板而选择提升short为int去执行第一个print呢？
​     这个就是SFINAE，C++的一个特性。
​     SFINAE最早由Daveed Vandevorde和Nicolai Josuttis提出，它意味着宁可对有问题的类型不考虑函数的重载也不要产生一个编译时错误。如果这里参数的类型中有一个value_type的嵌套类型，那么它就是重载决议集合的一部分。换句话说：编译器在辨认函数模板时，假如有一个特化会导致编译时错误（即出现编译失败），只要还有别的选择可以被选择，那么就无视这个特化错误而去选择另外的可选选择。比如下面这样使用：

```cpp
class Test {};
int main()
{
	Test a;
	print( a );
	return 0;
} 
```

   那么编译器给出的错误是:   error C2664: “print”: 不能将参数 a从“Test”转换为“int”， 之所以报错，因为这是函数调用问题，而不是与模板特化相关的问题。
   这是C++一个非常重要的特性，如果没有这个特性会对早期的很多代码造成破坏（因为当时没有模板），而且还会产生很多难以理解的代码。
     回过头去看为什么把value_type作为参数的一部分或者是返回值编译器就可以发觉我们提供的类型不能适合语义，而最初的代码又不能被发觉呢？这取决于模板实例化的过程，如果返回值和参数都可以匹配那么这个实例化就等同于成功了，此时此刻就表示编译器已经选择了模板特化而不是其它选择，既然实例化成功了，后面就相当于生成了函数，如果函数中存在参数不匹配问题则直接报错，因为此时不再是模版特化而是函数调用的问题了；但当约束位于参数或者是返回值的时候，如果发现参数不匹配，模板参数匹配的时候就会直接失败，因此这就产生了一个编译时错误，也就相当于实例化失败，失败后继续去匹配模版参数，仍然属于模版特化的问题，这个时候编译器就会按照SFINAE原则去看是否还有其它选择。

# Boost::asio

参考：[Boost Asio介绍-CSDN博客](https://blog.csdn.net/feikudai8460/article/details/107771155)

## 简介

​	asio (asynchronous input and output)，它提供了一个一致的接口来处理<u>网络通信、定时器、文件I/O</u>等异步操作。

​	Boost Asio库提供了平台无关性的异步数据处理能力（当然它也支持同步数据处理）。

## I/O services 和 I/O objects

​	Boost.Asio异步数据处理主要基于 I/O services 和 I/O objects。

​	I/O services抽象系统I/O接口,提供异步数据传输的能力，是应用程序和系统I/O接口的桥梁。I/O objects 用来初始化某些特定操作，如TCP socket，提供TCP方面可靠数据传输的能力。Boost.Asio只提供**一个类实现 I/O services**, boost::asio::io_service(io_context)。提供多**个I/O objects对象**，如`boost::asio::ip::tcp::socket和boost::asio::deadline_timer`

```c++
#include <boost/asio.hpp>
#include <iostream>
void handler(const boost::system::error_code &ec)
{
    std::cout << "5 s." << std::endl;
}
int main()
{
    boost::asio::io_service io_service;
    boost::asio::deadline_timer timer(io_service, boost::posix_time::seconds(5));
    timer.async_wait(handler);
   /* @param handler:The handler to be called when the timer expires. Copies
   * will be made of the handler as required. The function signature of the
   * handler must be:
   * @code 
   *void handler(const boost::system::error_code& error // Result of operation.); 
   *@endcode
   */
    io_service.run();
}
```

 	在调用 `async_wait()`之后，I/O service调用了run方法因为我们必须把控制权交给操作系统，以便在5s之后调用handler方法。`也就是说，async_wait()`在调用后立即返回，**run()调用后实际阻塞了**。许多操作系统都是通过一个阻塞的函数来实现异步的操作。

## asio两种编程方式

- 同步和异步，同步简单效率高，异步最主要的使用方式。
- io_service调用底层API，io_service有两个作用：跟操作底层打交道，跟IO对象打交道，socket接口调用比如send之类的通知到io_service,io_service再调用底层API

##  steady_timer（定时器）

```c++
typedef basic_waitable_timer<std::chrono::steady_clock> steady_timer;
 /// Constructor.
  /**
   * This constructor creates a timer without setting an expiry time. The
   * expires_at() or expires_from_now() functions must be called to set an
   * expiry time before the timer can be waited on.
   *
   * @param io_service The io_service object that the timer will use to dispatch
   * handlers for any asynchronous operations performed on the timer.
   */
  explicit basic_waitable_timer(boost::asio::io_service& io_service)
      
  
      
//定时时间点，到具体时间点启动
  basic_waitable_timer(boost::asio::io_service& io_service,const time_point& expiry_time)
//定时时间时长，过多久启动
  basic_waitable_timer(boost::asio::io_service& io_service,const duration& expiry_time)
```

## 多线程

​	采用boost::asio::io_service调用run()方法，**和boost::asio::io_service相关联的handler将会在同一线程内触发**。通过采用多线程，应用程序可以同时调用多个run()方法。一旦某个异步操作完成，对应的I/O service将会执行某个线程中的handler方法。如果第二个异步操作在第一个结束后很快完成，I/O service 可以立刻执行其对应的handler,而不用等待第一个handler执行完毕。

```c++
#include <boost/asio.hpp>
#include <boost/thread.hpp>
#include <iostream>
void handler1(const boost::system::error_code &ec)
{
    std::cout << __FUNCTION__<<":5 s." << std::endl;
}
void handler2(const boost::system::error_code &ec)
{
    std::cout << __FUNCTION__<< ":5 s." << std::endl;
}
boost::asio::io_service io_service;
void run()
{  io_service.run();}
int main() 
{
    boost::asio::deadline_timer timer1(io_service, boost::posix_time::seconds(5));
    timer1.async_wait(handler1);
    boost::asio::deadline_timer timer2(io_service, boost::posix_time::seconds(5));
    timer2.async_wait(handler2);
    boost::thread thread1(run);
    boost::thread thread2(run);
    thread1.join();
    thread2.join();
}
```

```shell
g++ main.cpp -lboost_system -lboost_thread
./a.out
handler1:5 s.
handler2:5 s.
```



# Boost::test

## boost::test简介和基本概念

test库是用于单元测试、命令行测试的一系列组件，全称Unit Test Framework(UTF)，优点很多，可以胜任不同强度的测试功能。

1. 一个测试模块大致分为四部：**测试安装**、**测试主体**、**测试清理**、**测试运行器**
2. **测试主体**是实际运行部分，通常包含多个**测试套件**，而测试套件又由多个**测试用例**组成
3. **测试套件**，**测试用例**组合成**测试树**，根节点称为**主测试套件**。进而可以理解以**主测试套件**为根节点，**测试套件**为非叶子节点，**测试用例**为叶子节点**整个主体**。

## 测试模块

1. **主测试套件**必须要有，用`BOOST_TEST_MAIN`或者`BOOST_TEST_MODULE`，而且必须位于头文件#include <boost/test/unit_test.hpp>之前！！！