# 	1.数据的表示

## 				1.数值数据表示

- **数码**：表示数的符号如：1 ，2，3    

- **基**：  数码的个数,，比如10进制有10个数码0-9

- **位权**  

- **数制(进制)**

  ```c
  0Bxxxx//四位二进制数，4*1bit大小
  
  0Oxxxx//四位八进制数，4*3bit大小
  
  0x xxxx//四位16进制数，4*4bit大小
  ```

## 				2.进制与进制间的转换

- **十进制与其他进制互转**：
  		连续除以目标进制的基数，从低到高记录余数，直至商为0，反之，每一位乘以该位位权再相加的总和。
- **二进制与2^n进制互转**：
          对于二进制，每n位为一组计算的结果作为目标进制的一位，反之每一位拆成n为二进制。
- **其他进制与其他进制互转**：
          利用十进制或者二进制作为中间结果，即先其他进制转二进制或者十进制，再由十进制或二进制转其他进制。

## 1.3.计算机中数据的单位

内存的最小单位为**字节**(B),每个字节的空间都有一个地址，类似于每个字节是每个房间，地址就是每个房间的房间号。

## 				1.4.原码，反码，补码

- 计算机中存的是补码形式——两个绝对值相同的正负数的补码相加舍去最高位的进位的结果为全0

- 正数：原码（除了符号位，其余位是该数的绝对值的二进制），反码，**补码**均一样

- 负数：原码（除了符号位，其余位是该数的绝对值的二进制），反码符号位(最高位)与原码一样，其余位为原码取反，**补码**为反码+1

- **示例**：

  ```c
  int a=0xffffffec;
  	//则为变量a所开辟的内存中存的就是0xffffffec，用%d打印==>0xffffffec==>0x10000014==>转十进制-20，用%#x打印==>直接打印0xffffffec
          
          
  int a=-20; 
  	//赋值用的-20,是10进制有符号整数,则a在计算机中存的就是20转16进制再转补码==>0xffffffec，用%#x打印将-20转32位的补码形式(也即在内存中存的数据）==>转16进制==>打印
  ```
  
  汇编编译的结果：
  
  ```bin
  0x00000000  E3E02013  MVN       R2,#0x00000013
  0x00000004  E59F3014  LDR       R3,[PC,#0x0014]
  0x00000008  E5832000  STR       R2,[R3]
  
  
  0x0000000C  E3E02009  MVN       R2,#0x00000009 
  0x00000010  E59F300C  LDR       R3,[PC,#0x000C]
  0x00000014  E5832000  STR       R2,[R3]
  
  注:只有10进制可以用+，-来表示符号，而其他进制的符号位都是最高位用0，1表示正负的，所以其他进制赋值给变量时，这个值本身就是它的补码。不需要对其进行额外的补码转换，因为它已经是以补码形式表示的有符号整数。内存存的就是该进制转16进制的样子，不需要进行补码的转换。而10进制存时，需要进行补码的转换。
  ```

# 	2.C语言数据类型

在 C 语言中，数据类型指的是用于声明不同类型的变量或函数的一个广泛的系统。**变量的类型决决定变量的存储空间及数据范围**。

## 2.1.分类

- **基本数据类型**：整型、字符型、浮点型
- **构造类型**：数组类型、结构体类型、共用体类型、枚举类型
- **指针类型**
- **空类型**

## 		2.2.整型家族

有符号和无符号的char、short、int、long、long long均可以存储整数类型数据，其中short、int、long、longlong均属于整型家族的不同类型，32位和64位的区别仅在于long分别为4，8个字节。

### 		2.2.1整型变量

- int、unsigned int  
- short、unsigned short  
- long、unsigned long
- long long、unsigned long long

### 2.2.2 整型常量（4字节）

- **带前缀的常量：区分进制**
  十进制：不需要任何前缀
  八进制：0开头的前缀
  16进制：0x开头的前缀
- **带后缀的常量：区分有无符号，区分长短整型**
  L或l==>长整型
  U或u==>无符号整型

## 			2.3.字符型家族

### 2.3.1字符变量

可以直接理解成占一个字节的整型变量。

`char `（0~255）、`unsigned char`（-128~127 ）

**人为规定**：
				有符号字符变量存放其最小值-128时，其内存存的是10 000 000

### 2.3.2 字符常量（4字节）

用单引号括起来的ASCII码表中的字符。

### 					2.3.3 截断

将一个整型数据存储到char变量里面，由于char变量是一个字节大小，对于四个字节大小的整数，会发生截断，只**<u>保留补码的最后8位。</u>**

### 					2.3.4 整形提升

将截断后的8位补充到32位，并不是说给char类型变量的空间申请32bit的空间，而是进行运算时系统cpu把它进行整型提升再计算（这里的计算不单单是算术运算，打印也算是运算），并非真正的内存中提升。什么数据类型固定在计算机中存的几个字节就是几个字节，其他补位无非就是要用到该数据时，从内存里拿出该数据后再进行整型提升后再送到cpu里运算。

对char这种有符号位的采用左补24个符号位（截断后的8个比特位的符号位)。对unsigned char 这种无符号位的采用直接左补24个0。

## 					2.4 整型/字符型的打印

1. **%u**
   %u是以无符号的形式打印整数，所以我们整形提升后得到的32位补码直接可以作为原码打印。
2. **%d**
   %d是以有符号的形式打印整数，所以，我们整形提升后得到的32位补码，要先观察32的第一位，如果是1，则是**负数，需要将这32位补码转化为原码**；如果是0，则**是正数**，直接打印即可。
3. 只有**整型和字符型**才有有符号和无符号之分。

## 2.5 浮点型家族

### 2.5.1浮点型变量（8字节）

float-4字节，double-8字节 ，long double（c99新增，大小看编译器）

### 2.5.2 浮点数常量

**浮点型常量默认是`double`类型的**

0.008==8E-3       8000==8E+3

### 2.5.3浮点数表示

f=(-1)^s\*M\*2^E

```c
							float   double

​	s(占一位）：符号位  			1     1

​	E：指数           				8(127偏移量)    11(1023偏移量)

​	M:尾数，有效数位(规格化成1.xxxxxx，把1.去掉就是M)   			23    52
      
      
 0.125 == 0.001 = 1.000 * 2^-3
  
 s == 0
 E == -3+1023 = 1020 == 011 1111 1100
 M == 000 == 000000000000000000000... ...
```

### 				2.5.4 浮点类型比较

当一个小数可以精确表示时，`double`和`float`类型取同一个小数是相等的；当一个小数不可以精确表示时，`double`和`float`类型是不相等的。**浮点数做比较，利用差值的绝对值来与人为规定的精度来做比较**。

```c
#include <stdio.h>
#include <stdlib.h>
int main(){
    float a = 0.2;
    float b = 0.5;
    printf("%.15f,%.15f\n",a,b);
    if (a == 0.2)         
        printf("a == 0.2\n");
    else
        printf("a != 0.2\n");
    if (b == 0.5)
        printf("b == 0.5");
    if (abs(a - 0.2) <= 0.00001)//才是严谨写法
        printf("a == 0.2\n");
    return 0;
}
//  0.200000002980232,0.500000000000000
//  a != 0.2
//  b == 0.5
//  a == 0.2
```

## 		2.6 布尔类型_Bool

### 2.6.1布尔变量（1字节）

占一个字节

### 2.6.2布尔常量

只有 0 和 1

<u>**头文件stdbool.h中**</u>为`bool`，也定义了1为`true` 0为`false`

## 		2.7 void类型

作为函数返回值或者参数，指针类型，但是，不能***直接对 `void `型指针进行解引用***，而要先将其转换为特定类型的指针。可以有`void*`变量，但不能用`void`变量。

```c
void a = 5;
	//报错
void *a = "abcdef";
int b = 3;
void *a = &b
    //void类型变量不能接受任何赋值，但void型指针可以接受任何类型指针赋值
```

# 3.C语言类型转换

## 3.1.自动类型转换

- 赋值操作：结果转为`=`左边操作数的类型
- 二元运算：结果数转为精度高的类型

## 3.2.强制类型转换

`(type_name)expression`

## 				3.3.指针类型转换

数据类型大的转数据类型小的指针，可以利用指针查看数据类型大的指针里面存的是啥，比如`int a; char p = &a;p+1`，每次只移动一个字节，但`a`有四个字节，所以`printf("%u",p)`就可以看a的每个字节是怎么存的，从而判断大小端。`char`类型的转`int`类型的访问，会出错，类似于越界（超出指针所指空间范围）出错，故得到的值是随机的。

# 	4.运算符

## 4.1.分类

- 算术运算符(**结果均为右值**)：`+`、`-`、`*`、`/`、`%`、`++`、`--`
- 关系运算符:`>`、`<`...
- 逻辑运算符
- 赋值运算符：赋值，算术复合赋值，位运算赋值
- 特殊运算符：三目条件运算符，逗号运算符, **`sizeof`运算符**

## 4.2.自增

`[]++`看成，先`[]`参与运算（只参与一次运算，随之i就++），然后再`[] = [] + 1`，结果返回的**是右值，即x存的内容，是常量**。

`++[]`，先`[]=[]+1`，然后`[]`再参与运算，结果返回的是**左值，是[]自身。**

```c
int a[7] = {1,2,3,4,5,6,7};
int *p = &a[1];
int y;
y = (*--p)++;
//--优先级大于*==>【】这一坨是（*--p)，故先执行y = 【】，然后【】++，【】又拆成先p-1,再参与*,所以【】这一坨结果是a[0],
//故,y = a[0],a[0] = a[0] + 1
y = (*p--)++;
//有先算括号里的，然后用括号里的结果把【】这一坨换了即可！！
//(*p--)的结果是*p,虽然执行了*p,p--,但其返回结果p--并不参与后续运算
```

## 			4.3.取余

操作数只能是整数

## 			4.4.位运算

- **应用**：修改一个数a的第n位的值，需要用到另一个数b而另一个数b可由（0`>>`n)来得到，其中n表示要修改的是第几位。

- **操作数类型**：只能是整型和字符型

- **左移**：有/无符号：左移多少位，补多少个0

- **右移**：无符号，补0，称为逻辑移位；有符号，左边补最高位（符号位），称为算术移位

- **异或**：交换两个数

  ```c
  //原地交换两个数的值:
  a=a^b;
  b=a^b;
  a=a^b;
  //注意a和b不是同一个变量，他们的值可以一样，但他们所开辟的空间不能是同一个。
  ```

## 		4.5.逻辑运算

逻辑短路：

```c
int a = 0;
int b = -1,d = 0;
c = a++ && ++b && d++;
printf("%d,%d,%d,%d\n",a,b,d,c)
// 1，-1,0,0
```

## 4.6.逗号运算符

多个表达式用逗号分开，每个表达式的值分别运算，但整个表达式的值是最后一个表达式的值。

```c
while((0,0,printf("Ha Ha\n")));
//死循环，一直打印Ha Ha
```

# 5.构造类型

## 5.1.一维数组

### 5.1.1.定义和初始化，引用

```c
#include <stdio.h>
int main(){
    /*不初始化*/
    int a[5];                //全局数组默认是0，局部数组不确定
    /*定义时初始化,部分初始化*/
    int b[5] = {1,2,3};     //被初始化的元素为给定值，其余全为0
    int c[5] = {0}或者{};   //局部数组全部初始化为0
    /*定义后初始化*/
    int i;
    int d[5];
    for (i = 0; i < 5;i++)
        d[i] = i;
    /*缺省数组大小初始化*/
    int e[] = {1,2,3};      //数组大小赋值时给了几个元素大小就是几，这时不能定义后再赋值
    
    /*数组引用*/
    for (i = 0; i < 5;i++){
         a[i] = i;
    }
    return 0;
}
//数组大小一旦给定，不能再改变。
```

### 5.1.2.一维数组的内存分配

1. 数组的元素是连续存储的
2. 数组占用内存空间 = 数组元素个数*`sizeof`(数据类型)

### 5.1.3.数组名的含义a

1. 数组名代表整个数组，是常量，不能被修改
2. 数组名代表整个数组的首地址
3. 数组占用内存空间 = `sizeof`(数组名)
4. 数组元素个数 = `sizeof`(数组名)/`sizeof`(数组元素的数据类型)

### 5.1.4.数组越界

数组越界编译不报错，数组越界访问运行不报错，数组越界修改运行会报断错误。

## 5.2.二维数组

### 5.2.1.二维数组的定义和初始化a

```c
#include <stdio.h>
int main(){
    /*定义*/
	int a[2][2];
    /*初始化*/
    int a[2][2] = {{1,3},{2,4}};
    printf("%d %d\n",a[0][0],a[0][1]);
    printf("%d %d\n",a[1][0],a[1][1]);
    int b[2][2] = {{1},{4}};//未初始化的地方系统赋值为0
    printf("%d %d\n",b[0][0],b[0][1]);
    printf("%d %d\n",b[1][0],b[1][1]);
    int c[][2] = {{1,2},{2,4}};//不能省略列数
    printf("%d %d\n",c[0][0],c[0][1]);
    printf("%d %d\n",c[1][0],c[1][1]);
    /*
    	按行且连续存储，即每行最后一个元素地址与下一行第一个元素地址相邻
    	故当赋值只有最外层{}时，默认从第一个元素依次往下赋值，没有赋值到的地方
    	默认为0
    */
    printf("%p %p\n",&a[0][0],&a[0][1]);
    printf("%p %p\n",&a[1][0],&a[1][1]);
    int d[1][3] = {1,2};
    printf("%d %d %d\n",d[0][0],d[0][1],d[0][2]);
 	return 0;   
}
/*运行结果*/
1 3
2 4
1 0
4 0
1 2
2 4
0x7ffd580bd3b0 0x7ffd580bd3b4
0x7ffd580bd3b8 0x7ffd580bd3bc
1 2 0
```

### 5.2.2.二维数组的理解

`a`是二维数组名，由三个元素组成，每个元素`a[i]`由包含4个元素的一维数组组成，`a[i]`是每个一维数组的名字。

取下标[]等价于\*（），*()与&可以相抵，对于二维数组：a\[i][j]==\*(a[i]+j)，即\*加（）相当于取下标。

a为数组名,

- 如果a为一维数组：\*a==a[0];\*(a+i)==a[i]==元素内容；
- 如果为二维数组:\*a==a[0],\*(a+i)==a[i],a[i]为第i个一维数组的数组名，\*a[i]==a\[i][0],\*(a[i]+j)=a\[i][j];
- 数组名代表数组首地址，和整个数组

- 数组占用内存空间=sizeof(数组名)

- 数组行数=sizeof(a)/sizeof(a[0])

- 数组列数=sizeof(a[0])/sizeof(元素类型)

## 5.3.字符数组

### 5.3.1.定义

元素的数据类型是字符型

### 5.3.2.初始化

一维二维同int型数组一样，缺省地方赋值为'\0'

```c
char ch[5] = {'H','e','l','l','o'};
char ch[5] = {'B','o','y'};//缺省的地方默认为'\0'
```

## 5.4.字符串（常量-sizeof==所占空间，包含\0）

### 5.4.1.定义

C语言中无字符串变量，一般用字符数组处理字符串，结束标志'\0

```c
/*大小均为6*/
char ch[6] = {"Hello"};
char ch[6] = "Hello";//字符串常量初始化
char ch[] = "Hello";
/*不严谨*/
char ch[5] = "Hello";

char ch[6];
ch = "Hello" //error
注意:字符串不可以直接赋值给字符数组数组名。此时用strcpy函数，类似于用循环遍历字符数组，一个字符一个字符赋值.
    printf打印字符串%s只适用于有\0的字符串，对于没有\0的不是字符串而是字符数组，只能老老实实地通过for循环打印
```

### 5.4.2.字符串长度判断

- \0有两种含义，一种是字符串结束表示，还一种是表示八进制的前缀0.
- 077，会被认为是0，7，7，三个字符，但\077，则会被认为是一个八进制字符。
- 同时由于编译器的算法默认匹配最长的字符，故\077不会被看成\0 和7 、7三个字符，而是以最长优先的原则来匹配。
- 如果是\08，则是两个字符\0和8，因为八进制最大数码为7.

## 结构体

### 								结构体赋值

- 声明结构体变量后赋值

  ```c
  1)对每个成员依次赋值
          stu1.sno = 123;
  	    strcpy(stu1.name,"Tom");
  	    stu1.age = 18;
  2)用{}进行一次性赋值，但要进行强转
          stu1 = (struct student){123,"Tom",18};   
  ```

- 声明结构体变量时赋值

  ```c
  1)要与结构体属性定义顺序保持一致
  		struct st stu={值1,值2,值3}
  2)字符串可以直接赋值给字符数组数组名	
  		struct st stu={.属性1=值1,.属性3=值3}
  ```

- 定义结构体并声明结构体变量时赋值

  ```c
  struct st{
  	属性1;
  	属性2;
  	属性3;
  }stu1=赋值方法2,stu2=赋值方法2
  ```

# 				字节对齐

**含义**：字节对齐主要针对结构体而言，通常编译器自动对其成员变量进行对齐，以此提高存储效率。让计算机在特定的内存地址去拿特定的数据类型。

**数据类型永远只是用来决定对齐数的**

**作用**：比如64位系统，一个指针也即一个地址大小为8字节，故当数据对齐8字节时，如果数据类型大小正好8字节，则访问一次内存就可以全部读取出来，其他小于8字节的，一定是2的倍数，故访问一次内存可以读取好几个数，如果不对齐，可能一个数据占两个地址，就需要访问两次内存。降低访存次数，以空间换时间。

**注意：**对齐会浪费空间，故应该能减少浪费就该减少浪费，通过调整成员的声明顺序等。

```c
/*结构体对齐后，其大小一定为最大字节数数据类型的字节数的整数倍*/
/*每个成员的起始地址（偏移量）为有效对齐的倍数，能整除有效地址*/
           自    默(64位)    有   大小

char       1     8     		1     8

double     8     8     		8     8

int        4     8     		4     4

int 	   4 	 8     		4	  4

char       1     8      	1     8
//自身对齐：数据类型本身的大小
//默认对齐：跟系统有关，64为为8字节，32位为4字节
//有效对齐：min(自身对齐，默认对齐）   
```

**1.如果嵌套结构体**：嵌套的结构体对齐到自己的最大对齐数的整数倍处，即嵌套结构体的对齐数是自己成员的最大对齐数，并不是对齐到该结构体自身大小的整数倍处，结构体的整体大小就是所有最大对齐数（包含嵌套结构体的对齐数）的整数倍。

**2.如果成员是数组**，其有效对齐位就是为啥数据类型的数组，其对齐位就是啥，数组无非就是n个相邻数据类型相同的数，并不改变对齐位。

### 取消字节对齐

1.在GCC编译器中，可以使用__attribute__((packed))属性来强制结构体成员非字节对齐。

在C语言中，结构体（struct）和联合体（union）的成员通常会根据编译器的默认对齐规则进行对齐。对齐规则的目的是提高内存访问效率，但有时会导致结构体或联合体占用更多的内存空间。例如，一个包含不同大小成员的结构体可能会在成员之间插入填充字节（padding），以确保每个成员的地址满足特定的对齐要求。  __attribute__((packed))   的作用使用   __attribute__((packed))   可以禁用这种对齐填充，使得结构体或联合体的成员紧密排列，不插入任何填充字节。这在某些情况下非常有用，例如：• 当你需要精确控制数据结构的内存布局时（如在嵌入式系统或与硬件交互的场景中）。• 当你需要确保数据结构的大小与特定的协议或文件格式一致时。

2.**#pragma pack****（push****，1****）//** **设置对齐方式为1****字节**

**#pragma pack****（pop****）//** **恢复之前的对齐方式** 

### 结构体数组

赋值语法：

```c
struct 结构体名 数组名[] = {{},{},{}...};
struct 结构体名 数组名[] = {[0] = {},[1] = {},[2] = {},...};
```

## 		位域

### 			位域的定义

一个字节8位被分为几块区域，每块区域可以取一个名字并存放不同的信息，即一个字节存放多种信息，从而大大节省空间。

位域的定义：

```c
struct A{
    unsigned char a:2;
    unsigned char b:3;
    unsigned char c:3;//成员类型只能是整数类型(包括char)和枚举类型
};

//赋值使用方式同结构体一样

struct A t;
t.a = 3;//取值范围位0~3
t.b = 2;//0~7
t.c = 5;//0~7
printf("%d %d %d\n",t.a,t.b,t.c)
```

### 位域的大小计算

一个位域成员不允许跨越两个 unsigned int 的边界，如果成员声明的总位数超过了一个 unsigned int 的大小， 那么编辑器会自动移位位域成员，使其按照 unsigned int 的边界对齐。

不要被位域成员前面的数据类型大小迷惑，成员具体大小还是要看其占多少位，记住，**数据类型永远只是用来决定对齐数的**。

```c
struct S1{
  int a:16; 
  int b:16;
  int c:16;
  char d;
};
sizeof(S1) = 8;
```

## 共用体

### 		定义作用

共用体也叫联合体，就是不同数据类型的数据使用共同存储区域，其大小为最大数据类型的空间。

作用：
			1.发数据包之前不知道发什么数据类型，事先定义好几种数据类型，但都占用同一块空间。
			2.当老师和学生可以用同一个结构体时，不必声明两个结构体变量来分别存贮老师和学生，只需要定一个共同体来存贮即可		

```c
struct person{
    char name[10];
    int age;
    char sex[5];
    char phone[11];
};
//赋值使用方式同结构体一样


union un
{
	int num;
    char ch;
    struct person student;
    struct person teacher;
};

//共用体上的那些成员都是共享一块内存空间的。
//共用体的大小为其成员，包括结构体成员的大小的最大值，且该最大值为对齐数的倍数，对齐数计算方法同结构体一样
```

### 		共用体与结构体的区别

1.  大小计算不一样

   ```c
   union un{
       int num;
       char s[7];
   };
   //最大对齐数为4，而成员所占最大空间为7，故要对齐到8位,sizeof(union un) == 8
   union un{
   	char a;
       char b[7];
   }
   //最大对齐数为1，而成员所占最大空间为7，故只要对齐到7位，sizeof(union un) == 7
   ```

2. 赋值方式

   ```c
   如果用{.成员1=值1，.成员2=值2} 的方式赋值，则最后共用体的所有成员的值为值2；
   
   如果用共用体变量 = {值} 的方式赋值，则{}里只能有一个值。
   ```

## 枚举型

### 		 定义

```c
enum e {
	one,//第一个成员值默认为0，可以指定他的值
   	two,//其他成员默认都是在前一个成员的基础上加1，也可以指定他的值.
   	three,
   	four，//，号不是分号
    five
};

//定义和赋值同结构体一样
enum e t;
t = one;
printf("%d\n",t);

//即确定某个变量只能是某几个值，则可以为枚举型。
//同一程序下，不同枚举类型的成员不能重名

枚举成员是一个常量，可以将其作为定义数组的长度大小，也可以将其作为一个整型值初始化或赋值给一个整型变量，甚至将其作为表达式的一部分
```

###   		特点

   	1.默认第一个成员从0开始，后面成员依次+1
   	
   	2.有特定值的成员后面，从特定值开始依次+1
   	
   	3.同一个枚举类型中，成员值可以相同
   	
   	4.不同枚举类型中，成员名不能一样（成员重复定义）。

# 6.指针类型

## 6.1.指针的基本用法

### 6.1.1指针的作用

- 使程序简洁，紧凑，高效
- 有效地表示复杂的数据结构
- 动态分配内存
- 能直接访问硬件
- 能够方便的处理字符串
- 得到多于一个函数的返回值

### 6.1.2.内存地址

在计算机中存储器的容量是以字节为基本单位的，内存的每个字节给一个编号，内存编号也叫内存地址。

### 6.1.3.指针和指针变量

1. 指针就是内存地址
2. 指针变量，存放内存地址的变量

### 6.1.4.指针的目标

指针指向谁，谁就是指针的目标

### 6.1.5.指针的解引用

- *p <==>指针的目标
- p<==>指针变量

- &p<==>指针变量自己占用的存储区域


### 6.1.6.指针的大小

看系统多少位，32位系统，大小4字节；64位系统，大小8字节

## 6.2.空指针

空指针可以接受任何类型指针的赋值。

## 6.3.指针的运算

### 6.3.1指针的赋值

只能赋地址常量或者指针变量，不能是普通整数，0除外

- 把一个普通变量的地址赋值给相同数据类型的指针
- 一个已有地址值的指针变量赋值给相同类型的指针
- 一个数组的地址赋值给相同数据类型的指针

### 6.3.2指针的算术运算

指针运算是以指针所存放的地址作为运算量而进行的；

指针运算的实质就是地址的计算。

移动步长是指针的目标，指针+1移动多少空间，究其本质还是要看指针目标的类型是啥。

指针有自增，自减，两个指针相减，但没有两个指针相加。

- 自增自减
  \*p++和(\*p)++不一样，一个指针变量自身++，变了；一个指针变量自身没变，但其所指目标++，变了

- \*++p和++\*p

  ```c
  ++ 优先级高于*
  *p++;//等价于先p++再*p，即指针先参与*，再++。
  (*p)++;//等价于p的内容++
  ++*p;==++(*p)
  *++p;==++p->*p
  *（p++）==*p++
  //记住（）并不影响后置的++/--仍然后执行的特性。
  ```

- **应用**：大小端问题

### 6.3.3.指针的关系运算

大小的比较比的就是地址的大小，不是地址内容的大小。

指针的运算是以指针所指向的类型的数据的个数为单位去描述的，并非是对指针所指向的地址的字节为单位运算的。即p+1，的结果并非p的地址+1，而是要看p所指空间存的是啥类型数据，改类型数据所指空间是n个字节，则p+1是移动n个字节。指针的比大小比的是其所指向的地址的大小，而不是地址里存的数据的大小。

## 6.4.指针与数组

### 6.4.1.指针与一维数组

数组指针是指数组在内存中的起始地址，数组元素的地址是指数组元素在内存中的起始地址。

一维数组的数组名就是一维数组的指针

int a[ ],*p; p = a; *p == a[0]  == *(a+0) == p[0];

即[ ] == * ==解引用

### 6.4.2.指针与二维数组

1. 一级指针与二维数组
   用一级指针遍历的依据在于二维数组在内存中是连续存储的。

2. 数组指针与二维数组

   `a`是二维数组名，由三个元素组成，每个元素`a[i]`由包含4个元素的一维数组组成，`a[i]`是每个一维数组的名字，即a[i]也是数组名，不能a[i]++     

   二维数组名代表二维数组起始地址，数组名加一，是移动一行元素。因此二维数组名也被称为行地址。

   行指针变量，存放行地址的指针变量，int(\*p)[3],[ ]里的3指的是指针加一移动一行，一行有3个元素。

3. 行指针，int(\*p)[x] 行指针**(也叫数组指针），**p+1指针移动x个元素数据；

4. 一维数组名取&变成行地址；二维数组名表示行地址，取解引用变为一维数组名。

   ```c
   int a = 10;		
   int *p = &a;
       //p所指空间存的是a的值，一个整数10，但p是int型，故p+1移动4个字节
   	//a+1 == 11
   int a[5] = {0};
   int (*p)[5] = &a;
   	//p所指空间存的是数组a，一个数组a[5]的首地址，但p是int型的行指针，故p+1移动4*5个字节
   	// a+1 == &a[6]
   int *p = (int*)&a;
   	//p所指空间存的是a,一个数组a[5]的首地址,但p是int型的指针，故p+1移动4个字节
   	//a+1 == &a[6],
   ```

### 6.4.3.数组名与指针的区别

- 含义不同
  数组名代表一个数组，存放相同类型的元素；指针代表存储地址的变量。

- 使用不同
  数组名是地址常量，不能修改；指针是变量，可以存储其他变量，也可以自增。

- 长度不同
  sizeof数组名 == 整个数组所占空间大小，sizeof指针 == 指针大小，与操作系统有关

- 本质不同

  指针是变量，数组名是常量

### 6.4.4.数组指针与指针数组的区别

int \*p[5]指针数组，是一维数组，每个元素都是int*

指针数组经常结合二维数组使用，存储每行首元素地址，本质是数组，存储的内容是指针而已。

int (*p)[5]数组指针，指向的内容是含有5个元素的一维数组，本质是指针，一维数组名取地址，或者二维数组名都可以赋值给它。

## 			6.5.字符指针与字符串

任何指针能够进行存取数据的前提是其内容，也即其指向的是一块与指针相同类型的空间，该空间可以是malloc动态申请的，也可以是声明该类型变量时为该变量开辟的空间（不能是局部变量的空间，因为局部变量的会被释放）。

char *s = "hello",并不是把字符串赋值到指针中，而是把字符串的首地址给p了。

```c
char *s="hello";
	//s为字符指针，其所指的地址是字符串常量地址，常量存放在内存的常量区，也即静态区，其可以访问，但不可修改，否则会报段错误。这里说的常量不是指这个指针是常量不可变的，而是指针所指的内容是常量不可变的
char s[]="hello";
    //s为数组名，其所指空间为一个数组变量，即所指内容可以改变，故scanf（"%s",s)可以。
char *s="hello"
    //s为字符指针，其所指向的是一个字符串常量，即所指内容不可变，故scanf("%s",s)不可以，否则会报段错误
```

## 			6.6.多级指针

int **p == int\*  *p,\*p代表p是一个指针，int\*代表p所指空间存的是int\*类型，即是指针。

多级指针的运算也是以指针目表为单位的。即以指针的大小8字节（64位系统）为单位的

## 6.7.void指针

- 万能指针其实就是void*类型的指针，而void\*指针一般被称为通用指针或叫泛指针。
- void指针不属于任何类型，不可以对其进行算术运算，因为编译器不知道要增减多少个字节，必须强制为其他类型才可运算解引用等。
- 使用前必须初始化，被初始化时，其他类型指针赋值给void指针不报错，但是使用初始化好了的void指针进行运算比如解引用，赋值等时必须强转。

## 			6.8.const指针

- 由const修饰的数据就是常量了，不能修改，为只读。
- 修饰变量：
  const int  var,修饰的是int，即var空间里的int类型的值不能直接修改，但可以通过指针int的指针间接修改
- 修饰指针：
  const int*p,const修饰的是int，即指针p指向的是常量int的地址，也即指针p所指向的地址的内容不能变，但可以改变p所指向的地址，也即p指向另外一个常量的地址。
- int\* const p修饰的是指针p，即指针p是常量，也即不可以改变p的内容也就是p所指向的地址，但可以改变p所指向地址的内容。

## 6.9.函数指针

- 存放了函数的入口地址，函数名代表了函数的入口地址，类似于数组名；

- 函数指针定义： 
      char (*p)(形参1，形参2);即一定要加（），赋初值：p=fun,   使用：p(形参1，形参2)
- 函数指针数组定义：
      在函数指针p后面加上[数组大小].char(*p[N])(形参1，形参2)比如，p[0] = add ;p[1] = sub......
- 作用：
      相同类型的好几个函数比如加减乘除，用p来改变所指向的函数来进行操作。

# 7.程序控制结构

- <u>判断条件(（赋值语句））多加一个括号告诉编译器我=就是赋值，不是==手误漏写了一个=</u>
- `if`不加花括号时，默认只匹配一条语句，而`if else`算作一套C语句。
- **浮点型**不能做 `switch`的参数类型
- `continue`语句是循环控制语句，表示结束本次循环，进行下一次循环，而不终止整个循环的执行。`switch`语句是条件分支语句，做多条件判断，不能使用循环控制语句。
- break跳出的是最里面的一层循环

# 	8.输入输出专题

## 			8.1.行缓冲(scanf)

- 当我们使用`scanf`函数输入数据时，输入的字符首先被放入到一个缓冲区中。这个缓冲区是行缓冲的，意味着输入的字符会在这里被暂时存储，直到我们按下回车键进行换行，然后才会进行I/O操作。
- 例如，如果我们使用`scanf`输入一个整型数据`10`，当我们按下回车后，标准输入缓冲区中实际上存储的是“10\n”，其中`\n`是换行字符。

## 			8.2.匹配和读取(scanf)

- `scanf`函数内部有两个“扫描探头”：一个工作在匹配字符串上（匹配探头），另一个工作在输入流上（输入探头）。
- 匹配探头首先读取格式字符串中的第一个匹配字符（如`%d`、`%f`等）。如果它是一个格式符，那么输入探头就开始工作，从输入流中读取相应类型的数据，如果不是格式符，是其他字符如空白符，逗号等，输入也需要空白符换行符来匹配，如scanf里显示地写了逗号，则输入也要，号，否否则直接结束。
- ```c
  int ret,a,b;
  ret = scanf("%d,%d\n",&a,&b);
  //输入12 2 回车---->a = 12   /,匹配到空格-->sacnf直接结束/ret = 1
  //输入12,2 回车---->a = 12 ,b = 2,回车不会结束scanf，此时不会在最后一个字符遇到\n时停止，需要再输入其他的非\n的字符才可以结束输入
  ```

- 输入探头会扫描输入流中的字符，并将它们存放到一个输入缓存区中。然后，输入缓存区会判断现存的这些字符是否与当前的格式符匹配。

## 			8.3.转换和存储(scanf)

- 在`scanf`函数中，空格（包括空格符、制表符`\t`和换行符`\n`）通常被用作输入字段之间的分隔符，但它们的具体行为取决于格式说明符（如`%d`, `%s`, `%c`等）和输入缓冲区的状态。

  1. **对于`%d`、`%f`等数值类型**：
     当`scanf`读取一个数值类型（如整数或浮点数）时，它会跳过任何前置的空白字符（**<u>包括空格、制表符和换行符</u>**），然后开始读取数值。一旦读取到一个非数值字符（如字母或符号），它就会停止读取并返回。但是，这个非数值字符（以及任何后续的字符）仍然会留在输入缓冲区中。
  2. **对于`%s`字符串类型**：
     当`scanf`使用`%s`格式说明符读取字符串时，它会读取直到遇到第一个空白字符（空格、制表符或换行符）为止。这意味着，如果输入字符串中包含空格，`%s`将只会读取到第一个空格之前的部分。而且，任何读取字符串后的空白字符都会留在输入缓冲区中。
  3. **对于`%c`字符类型**：
     当`scanf`使用`%c`格式说明符读取字符时，它会读取并返回下一个可用的字符，不论它是什么。这包括空格、制表符和换行符。因此，如果你试图使用`%c`读取一个字符后立刻读取另一个字符，但中间有一个换行符，`%c`将会读取并返回这个换行符。
  4. **对于换行符（`\n`）**：
     如果`scanf`的格式字符串中没有显式地包含`%c`来读取换行符，并且输入中包含了换行符，那么换行符通常会被留在输入缓冲区中，直到下一次读取操作。但是，如果`scanf`的格式字符串中包含了`%*c`（其中`*`表示跳过该输入项），并且放在适当的位置，它可以用来跳过并丢弃换行符。

  总的来说，空格和换行符在`scanf`中的行为取决于你使用的格式说明符和输入缓冲区的内容。如果你需要更精细地控制输入，可能需要考虑使用其他函数（如`fgets`）来读取一行输入，然后使用字符串处理函数（如`sscanf`、`strtok`等）来解析输入。

- ```c
  #include <stdio.h>
  #include <string.h>
  int main(){
      int ret;
      int a,b;
      char c;
      memset(&ret,0,13);
      ret = scanf("%d%d%c",&a,&b,&c)//12#32\n
      printf("%d\n",a);//12
      printf("%d\n",b);//0
      printf("%d\n",c);//0
      printf("%c\n",getchar());//#
      printf("%c\n",getchar());//3
      printf("%c\n",getchar());//2
      printf("%c\n",getchar());//\n
      return 0;
  }
  ```

  

- 转换后的数据会被存储在提供给`scanf`函数的变量中，供后续程序使用。

- `scanf`函数会根据格式字符串中的格式说明符的顺序，按照变量的地址顺序将数据存储到相应的变量中。

### 			8.4.scanf的返回值

- `scanf`函数返回成功读入的数据项数。如果所有的数据项都成功读入，那么返回值就是格式字符串中格式说明符的数量；如果只有部分数据项被成功读入，返回值就是实际成功读入的数据项数；如果读入失败或遇到文件结束符，返回值就是EOF（End Of File）。

# 	9.函数

## 				9.1.函数的基本用法

- 函数的调用
  函数名(实际的参数)，如果函数有返回值，可以作为一个运算量出现在表达式中;
- 函数的声明
  函数类型 函数名（形参），其中形参的变量名可以与函数定义的一样，可以不一样，甚至可以省略.只保留变量的数据类型

## 				9.2.函数的传参

将实参的值或者地址传递给形参的过程

### 9.2.1.全局变量

全局变量就是在函数体外说明的变量，全局变量一经定义后就会在程序的任何地方可见。

### 9.2.2.值传递

调用函数将实参传递给被调用函数，被调用函数将为形参开辟新的存储空间，在函数中改变形参不会影响到实参的值。

### 9.2.3.指针传递

### 9.2.4.一维数组传参

- 全局传参，即定义数组为全局数组
- 指针传参，即实参传入数组的首地址即数组名，形参为相同类型的指针
- 数组名传参，`fun(int array[],int size)`，**形参int array[]本质上也是一个指针变量，不是真正的数组名，不具有数组名`sizeof(array)`==数组总大小的性质。**

### 9.2.5.字符数组传参

与一维数组传参一样，唯一不同的是不要size，因为字符串本身带有'\0'来作为结束符。

### 9.2.6.二维数组传参

- 普通的一级指针作为形参，二维数组的a[i]作为实参,`fun(int *a,int n,int m);fun(a[i],n,m)`
- 行级指针作为形参，二维数组名作为实参；`void fun(int (*a)[n],int m,int n)或者void fun(int a[][n],int m ,int n)`
- 普通二级指针作为形参，`int *p={a[0],a[1],a[2]),fun(p,m,n),void fun(int* *a,int m,int sn)`

## 				9.3.指针函数

### 9.3.1.概念及用法

数据类型 *fun（形参1，形参2........）,返回值为地址量。

指针函数返回值只能返回如下地址：

1. 全局变量的地址
2. 字符串常量的地址
3. static变量的地址
4. 堆的地址（用malloc函数动态申请的内存）
5. 主调函数的内存地址:char* fun(char \*s){return s}

### 				9.3.2.函数指针

- 存放了函数的入口地址，函数名代表了函数的入口地址，类似于数组名；

- 函数指针定义： 
      char (*p)(形参1，形参2);即一定要加（），赋初值：p=fun,   使用：p(形参1，形参2)
- 函数指针数组定义：
      在函数指针p后面加上[数组大小].char(*p[N])(形参1，形参2)比如，p[0] = add ;p[1] = sub......
- 作用：
      相同类型的好几个函数比如加减乘除，用p来改变所指向的函数来进行操作。

### 9.3.3.函数指针与指针函数的区别

理解这两个概念的关键在于注意它们的声明和使用方式。函数指针的声明中，括号的位置决定了它是指向函数的指针；而指针函数的声明则明确指出它返回的是一个指针。

# 			10.关键字

## 10.1.typedef

使用：typedef已有数据类型新的数据类型；

```c
//修饰行指针
typedef int (*PTR)[3]; 
PTR p;
//函数指针
typedef (*ptr_to_fun)(形参1，形参2..,,,,); 
ptr_to_fun p;
```

## 				10.2.define

\#define M 2+3 与#define N （2+3）的区别

### 								10.2.1.define与const 常量的区别

- 宏没有分号，不需要等号赋值，而const有分号，且需要等号赋值。

- 宏在预处理时进行文本替换，而const是在程序运行时使用。

- 宏不会分配内存，而const会分配内存。

- 宏定义可以用undefine取消而失效，而const在作用范围内永久有效。

- #define不受作用域范围限制，哪怕写道某个函数内部，在外部也能用。

### 								10.2.2.宏函数的使用

```shell
gcc -E xxx.c -o xxx.i//预处理，即将用到宏的地方全部进行简单的文本替换
```

```c

#define debug printf("Hello,world\n")   //不带参宏，不带分号
#define debug(s) printf("%s\n",s)   //带参宏，不带分号
#define MAX(a,b) ((a)>(b)?(a):(b))	//带多个参宏，不带分号
int main(){
    char s[] = "Hello,world"
    debug;
    debug(s);
    return 0;
}
//注意：
	1.如果define后面的语句不与define在同一行的话要加上反斜杠\，以表示连接
    2.对于带参数的宏，如果函数体用到了参数进行计算，一定要加括号
	#define SQUARE(n) (n)*(n)
     	//计算平方和，SQUARE(3+4)这样的计算结果才不会出错
    3.#define do{printf("hello");printf("world\n");printf("...");}while(0)
 //用do-while的原因是把多条语句合并成一条语句！！
```

### 10.2.3.宏函数与普通函数的区别

 1).宏调用效率比函数高的多
        2).但宏参没有类型与类型检查
        3).函数可以递归，但宏不可以

## 		10.3.typedef与define的区别

1. 语法不同
   typedef是关键字，其语句后面有分号，define是预处理指令后面没有分号。
2. 执行时间不同
   typedef在编译阶段执行，会进行类型检查，而define在预处理时执行，只会进行简单的文本或标识符的替换，不进行类型检查
3. 作用域不同
   typedef在函数外定义，则其作用域范围从定义开始至文件结尾，而当其定义在函数内时，作用范围从定义开始至文件结束，而define无论在哪里定义，其作用范围为从定义开始至文件末尾。

## 10.4.volatile关键字

### 10.4.1.C语言中变量的定义

存储类型 特征修饰 数据类型 变量名  static volatile int value

### 10.4.2.存储类型	

决定变量的存储位置

​	auto 	 只能修饰局部变量。存在栈

​	static 	既可以全局也可以局部。存在静态区DATA。只能在本文件用

​	extern   只能修饰全局变量告诉编译器不用再申请空间了，因为它在其他文件已经申请空间了

​	register 只能局部且整型，不能浮点型，没有地址

### 10.4.3.特征修饰	

决定变量的特征属性

const只读，被修饰的变量本质还是变量，只读变量，不是常量

volatile,被修饰的变量表示该变量值随时都有可能发送变化。![image-20240726202038065](C:\Users\z3254406361\AppData\Roaming\Typora\typora-user-images\image-20240726202038065.png)

![image-20240726202110043](C:\Users\z3254406361\AppData\Roaming\Typora\typora-user-images\image-20240726202110043.png)

![image-20240726203229480](C:\Users\z3254406361\AppData\Roaming\Typora\typora-user-images\image-20240726203229480.png)

### 10.4.4.数据类型	

决定变量的存储空间及数据范围

### 10.4.5.变量名字	

决定变量的引用标识

## 10.5.volatile应用场合

1. 中断

   中断处理程序中若修改其他程序使用的变量，需要volatile来修饰该变量

2. 多线程
   多个线程都要访问的变量也需要用volatile修饰

3. 硬件寄存器
   硬件寄存器的值可能随着硬件的状态变化而变化，需要volatile修饰

## 10.6.extern

extern是C语言中的一个关键字，它主要用于声明一个变量或函数是在其他文件（或同一文件的其他位置）中定义的，以便在当前文件中引用它们，使得变量和函数的跨文件共享成为可能，从而提高了代码的可维护性和可重用性。告诉编译器不用再申请空间了，因为它在其他文件已经申请空间了。**extern的原理很简单，就是告诉编译器：**“你现在编译的文件中，有一个标识符虽然没有在本文件中定义，但是它是在别的文件中定义的全局变量，你要放行！”

优点：不就不会引入大量头文件，进而不会引入大量的无关函数。这样做的一个明显的好处是，会加速程序的编译（确切的说是预处理）的过程，节省时间。

# 		11.变量作用域和生命周期

## 11.1.变量的存储类型

变量的存储类别决定了变量的作用域，生命周期以及默认初始值。

- auto
      常在函数体中或循环体复合语句中，不能是全局变量，作用域即在函数体内或者复合语句中。
- register
      定义在局部。处于寄存器中，不能用&来取地址。
- static
      定义在全局/局部，在内存中以固定地址存放，程序运行期间一直存在，默认初始值为0，其所修饰的全局变量或者函数不能被其他文件用extern进行引用。下次再调用该值时仍然保存上次的值。
- extern
      声明的文件引用另一个文件中的全局变量，且声明的文件并不会再开辟新的空间，而是在文件链接时直接引用，也可以声明函数。

## 11.2.变量作用域

在C语言中，当在函数内部引用一个变量时，编译器会首先查找该函数内部是否有该名称的变量。如果在函数内部找到了同名变量，则使用该变量；否则，编译器会在更广泛的作用域（如全局作用域）中查找该变量。

由于局部变量val（值为30）在main函数的作用域内是可见的，并且覆盖了全局变量val=20，因此printf会打印局部变量val的值，即30。同一作**用域中**，变量不能重名。

# 12.内存管理

## 12.1.内存管理的意义

不同分区存放的数据，赋予不同的生命周期，带来了更大的灵活性。

## 		12.2.内存分区

```shell
#可以用size命令查看内存区域大小
size a.out
```

- 代码区text（运行前）
  存放函数体的二进制代码，cpu要执行的二进制机器指令，共享只读。

- 全局静态区 （运行前）
  存放全局变量和静态变量(函数体内外的静态)以及常量(包含const，字符串常量等)，生命周期为整个程序运行期间。BSS(blocks started by symbols)：
      全局/静态未初始化数据，
  data:

  ​    全局/静态初始化数据，文字常量，字符串常量。

- 栈区stack（运行后）
  编译器自动分配，存放函数参数，返回值和局部变量；

- 堆区heap（运行后）
  malloc，手动分配释放，不主动释放则要等程序结束自动释放

## 		12.3.动态内存使用

函数体中局部变量，存放在栈区，空间随着函数结束而释放，故函数返回值为该变量的**地址**是不安全的，故函数体内要利用动态申请**堆区**的内存，其生命周期更长，并作为函数的返回值地址。

## 12.4.堆栈的区别

1.管理方式不同，栈由操作系统自动分配释放，无需我们手动控制；堆的申请和释放工作由程序员控制，容易产生内存泄漏；

2.分配方式不同，堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。

3.空间大小不同，栈的大小要远远小于堆的大小。

4.生长方向不同，堆的生长方向向上，内存地址由低到高；栈的生长方向向下，内存地址由高到低

## 12.5.野指针

野指针产生的原因：

1、指针定义时未被初始化：指针在被定义的时候，如果程序不对其进行初始化的话，它会指向随机区域，因为任何指针变量（除了static修饰的指针变量）在被定义的时候是不会被置空的，它的默认值是随机的。

2、指针被释放时没有被置空：我们在用malloc开辟内存空间时，要检查返回值是否为空，如果为空，则开辟失败；如果不为空，则指针指向的是开辟的内存空间的首地址。指针指向的内存空间在用free()或者delete（注意delete只是一个操作符，而free()是一个函数）释放后，如果程序员没有对其置空或者其他的赋值操作，就会使其成为一个野指针。

3、指针操作超越变量作用域：不要返回指向栈内存的指针或引用，因为栈内存在函数结束的时候会被释放，

## 12.6.内存泄漏

内存泄漏（Memory Leak）是指程序在运行过程中，已动态分配的堆内存由于某种原因未被释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。这一现象并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误或疏忽，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。

# 	13.GCC编译

## 		 13.1.GCC简介

GNU C Complie编译器

## 13.2.GCC编译过程

1. gcc -E(预处理)    .c ---> .i
2. gcc -S(编译:检查语法错误) .i ---> .s(汇编文件)
3. gcc -c(汇编)     .s-->.o(二进制文件)
4. gcc(链接)         各种.o-->可执行文件.elf

所有的.c文件都有经过预处理，编译，汇编三个步骤独立（不依赖不依靠其他文件的功能，库函数，即不是说别的函数调用了stdio库，我就可以不调了）生成.o文件，然后所有.o文件链接形成一个可执行文件。

## 13.2.常用GCC命令

```shell
gcc -I（大小i） 指定头文件的路径：指定头文件

gcc -l（小写L） 库名 ：链接库
	#gcc tets.c -lpthread

gcc -L 指定库的路径

gcc -O/O2  优化代码，同volatile里优化意思一样

gcc -g     进行调试---->gdb ./a.out
```

## 		13.3.条件编译

好处：通过命令传宏来决定执行哪些代码，省的总注释来注释去的,即相当于一个开关，常用于底层开发代码中。

```c
//1. 根据宏是否被定义来进行条件判断并进行条件编译
#ifdef
#ifndef

#endif
    
    
//2.根据宏的值。。。。。。。
#if VALUE//根据宏的值为真还是假来
#endif

gcc xxx.c -D 宏1    //相当于给程序里添加宏定义的语句即#define 宏1 
gcc xxx.c -D VAULE = 1   //把value的值赋值为1 
```

# 		14.GDB调试

## 14.1.进入调试模式

```shell
gdb 可执行文件名
```

## 14.2.设置断点

```shell
break 
#设置断点，后面可以跟函数名或行号，表示在某一行打断点
```

## 14.3.运行程序

```shell
1.
start  #进入程序的入口处，等待执行程序
continue #statrt后往后顺序执行，直到遇到一个断点处

2.
r(run):#直接让代码运行至断点处

3.
n(next) #从断点处开始一条一条的执行
```

## 14.4.打印信息

```shell
print (&)变量名 #查看变量的值，加上&查看变量的地址

x /nxb &s:打印变量s在内存存储的具体的内容，格式为从结构体首地址开始分别输出n个字节的内容，格式显示为16进制。

bt:打印调用栈



bt：查看栈

l(list):不记得代码了，敲一个l显示一段代码内容。
```


Edit



Step

Help

Quit



 

GDB调试程序

gcc -g xxx.c ：如果程序出错（非语法错误，比如越界，段错误)，则会生成core和a.out文件

gdb a.out core（core文件):在core文件里查看出错原因

gdb a.out -p 进程pid：调试**正在运行**的进程

![image-20240621124813998](C:\Users\z3254406361\AppData\Roaming\Typora\typora-user-images\image-20240621124813998.png)

![image-20240621125023445](C:\Users\z3254406361\AppData\Roaming\Typora\typora-user-images\image-20240621125023445.png)

# 15.Makefile

## 		15.1.makefile概述

1. **含义：**

   make是一个命令，是一个解释makefile中指令的命令,make，制作，当前目录已有，则用当前目录的，没有就根据制作规则语句进行制作。

2. **直接敲make**
   默认访问的是当前目录下名为makefile的文件；

3. **make -f 指定文件的文件名：**
   指定文件为makefile文件

4. **好处：**
   1.一旦写好makefile文件，只需一个make命令，整个工程完全自动编译，极大提高了软件开发的效率。

   2.提升编译效率：不是一步编译时，第二次make时，只编译修改了的文件。（利用文件时间戳来确定文件是否被修改过了）。

## 		15.2.makefile基本语法

### 		15.2.1.makefile 基本语法

target... : prerequisites ...

​	command

### 		15.2.2.解释

1. **target目标**
   它是我们要生成的东西，省略文件的路径时，默认为当前路径，目标文件可以是我们所需的最终文件或者可执行文件，也可以不是我们最终要生成的文件——伪目标。一个伪目标,仅仅是为了执行某条shell语句实现某个功能，并不生成文件。

2. **prerequisites**

   要生成那个target所需要的文件，默认在当前目录下找，如果没有则找有无生成该依赖的makefile语句，此时依赖就是另外一条语句的目标。

3. **command**

   任意shell命令，不一定是gcc命令，**@**作用是不显示命令再显示结果而是直接显示执行命令的结果。


### 		15.2.3.make解析规则

1. 只敲一个make，默认只找第一条目标，故只用make执行makefile有多条语句时，应把生成最终目标的语句放在最前面，因为make默认只识别makefile的第一条语句，找依赖文件，默认**在当前目录**下找，如果有该名称的文件，则直接用该文件，如果没有，则makefile中找是否有该依赖文件作为目标文件存在于另外一条语句中，有该语句，则先执行完该语句。

2. make  目标名：则寻找生成该目标的语句进行执行。

3. .PHONY（虚假的意思）:目标名
   解决**make默认执行的第一条语句**或者**指定执行的语句**中的目标名（可以是伪目标）与当前目录下文件名重名的冲突，此外新生成的文件会覆盖当前目录下重名的那个文件，以.PHONY做目标，会找并执行第一条伪目标语句。

## 		15.3.makefile变量

### 		1.创建变量的目的

用来代替一个**文本字符串**，该字符串可以是：

1.系列文件的名字

2.传递给编译器的参数

3.需要运行的程序

4.需要查找源代码的目录

5.需要输出信息的目录

6.etc

最终就是便于维护和修改makefile文件，改一处，实现多次改。

### 		2.自定义变量

1. 声明时就要赋值，赋值多个字符串时，用空格隔开。
2. 取值方式：$(x)或${x}==取x的值，$$表示打印真实的$符号。
3. SRC = $(shell pwd)/obj ：shell命令执行结果作为值给变量赋值，但$(shell pwd）会被立马执行，其结果为make执行的当前工作目录，当SRC传递其他目录下的文件时，传递的并不是$(shell pwd),而是make工作目录。

### 		3.变量赋值

- =一般赋值,多个条语句对同一变量赋值，最终结结果为最后一条语句的值
- ?=如果前面已经给该变量赋值了，则此次赋值失效，否则执行此次赋值 

- :=如果前面有值了则覆盖掉原来的值，与？=相反

- +=追加赋值

### 		4.自动变量

针对文件名，自动指变量的值会根据修改自动调整

#### 1.依赖文件

- $+所有依赖文件，可重复·    

- $^ 所有依赖文件，不重复      

- $<第一个依赖文件，按生成时间排序的第一个

- $?:所有时间戳比目标文件晚的依赖文件，即上一次修改时间比目标文件生成时间晚的文件，用于打印第二次编译时哪些依赖文件被修改了。

#### 2.目标文件

- $*：不包含后缀 ，用于打印，对于本身没后缀的无效，对于可执行文件a.txt，他还是没后缀，.txt也算文件名不算后缀名，故打印无后缀的只能用$@  
- $@目标文件完整名字，有后缀名的也包含后缀名，用于打印和编译        


 		作用：提高编程速度，每次只要写一句gcc命令再不断复制粘贴带有自动变量的相同的语句即可。makefile隐含变量,针对shell命令，可以赋值，不赋值则用默认值.

#### 3.命令（有默认值）

- CC：默认值--cc 赋值交叉编译 CC = arm-linux-gcc

- CPP：默认值--$(CC) -E预编译

- RM：默认值rm -f


#### 3.命令的选项（无默认值）

- CFLAGS= -c -g -Wall 

- CPPFLAGS

- CXXFLAGS

- LDFLAGS


**通配符**：<u>%.c ：%.o用通配符的前提是在通配符使用语句前已经出现过了%.c的范围是哪些.c文件，不然%可以匹配任意，那么有无穷多个目标了，此外通配符并不匹配路径！！，所以带有路径的文件通配，要自己加上路径</u>

## 	15.4.makefile的条件判断

1. ifeq（a,b）：a,b是否相等，if与（）间要隔开！！！

2. ifneq：是否不相等

3. ifdef  ARCH：只有ARCH**定义过且赋过值**才算定义过，无论是在文件中定义还是在传参时定义，规则都一样

4. ifndef   endif


## 	15.5.makefile常用函数

#### 1.格式

$(<函数名> <参数1,参数2>)或者${<函数名> <参数1,参数2>}

#### 2.举例

一个文件名应该 == 绝对路径/文件名，缺省绝对路径只有文件名默认都是当前目录下的文件，当文件名（无论有路径）赋值给变量时，其特性就不是文件了，就是一个字符串，赋值的时候缺省路径那么该字符串就没有路径，变量就是变量。

```shell
$(wildcard PATTERN)
	#功能：列出当前目录下所有符合模式PATTERN格式的文件名,比如*.c列出当前目录下所有.c文件
	#返回值：空格分割的，存在当前目录下的所有符合模式PATTERN格式的文件名,PATTERN是文件名，不是字串！！！	
	#PATTERN：可以使用shell下的可识别的所有通配符
作用：
	SRC = add.c sub.c test.c xxx.c.....www.c#此时SRC仅仅只是一串字符，不会说有默认当前目录下的这些文件这种说法
	取代：SRC = $(wildcard *.c),大大简洁了代码！！
$(pastsubst <pattern>,<repalcement>,<text>)
	#它用于将一个字符串中符合特定模式的子串替换为另一个字符串，不符合的字串就不换
	#text:要进行替换的对象，若有多个则用空格隔开，text是字串
	#pattern：替换对象满足的文件名字格式，pattern也是字串。
	#replacement：替换成什么格式的文件名，replacement也是字串。
	#返回值是替换后的文件名，包含没有被替换的，比如，text为1.c，2.cpp，pattern为*.c，则返回值为1.o,2.cpp
```

## 	15.6.makefile自定义函数 

​	**定义**：

​			define 函数名 

​				函数体		//用$(0….9)来获取第n个参数，第0个参数是函数名字

​			endef

​	**调用：**$(call 函数名 参数）

# 	16.make命令的使用

```shell
make #默认访问文件名为makefile的文件

make -f file#make文件名为file的文件

make -i #忽略所有执行出现的错误导致的停止，即使出错了，也会接着往下执行，不会在出错的地方直接停止了。这很重要，特别是当一个工程要编译几个小时时，编译了好久因为出错停了又得重来。

make -n #只打印要执行的命令有哪些，并不执行这些命令

make -s #只执行，不打印命令

make -w #当工程庞大分了好多文件目录时，打印当前的目录来表示当前编译进入到哪个目录了，告诉你从哪跳到哪了

make -C #指定哪个目录下有makefile(默认加了-w的功能)，让make去执行它    
```

#  	16.分目录管理源码(目录作为目标或依赖的问题)

```makefile
#*.c-->src目录
#*.o-->obj目录
#当前目录的make执行makefile时，也去执行其他目录下的makefile则当前目录下的makefile要用到   
make -C 目录名1 目录名2 目录名3.... 这条shell语句，又因为执行shell语句要用到目标：依赖这样的格式,则应为：
1.SRCDIR = ./src/
	$(SRCDIR):
		make -C $@
		#执行结果：
		'src/'已是最新
#一切皆文件，目录也是文件,则会出现重名的问题，解决办法，以SRCDIR为目标的语句中添加依赖，依赖不能是目录，不然也会出现同样问题。
 $(SRCDIR): ECHO
	make -C  $@
 ECHO:
 	echo Hello
 	
 	
2.利用.PHONY解决,一个makefile文件中只能使用一次
 .PHONY:$(SRCDIR)
  $(SRCDIR):
		make -C  $@
		
3.
export 变量1，变量2，变量…..#将当前makefile的变量传递给其他makefile文件使用
如果把带有路径的文件名赋值给变量，当该变量在一个文件夹中定义赋值，而在另外一个文件夹中使用时应该用绝对路径。
```

# 	17.makefile总结

- **默认条件**
  假设目标名是test，如果当前目录中有test.c（一定要是.c文件才可），即存在以目标名为前缀，.c为后缀的C源文件，哪怕有test.c,test.txt并存，只要有test.c,则都算满足默认条件。

- **默认语句**
  $(CC)  $(FLAGS)  xxx.c -o xxx，CC FLAGS可以赋值，也可以使用默认值，其中FLAGS没有默认值。

- **执行步骤**

  假设当前目录下有add.c   a.txt  b.txt  makefile  sub.c  test.c  test.txt这些文件


1.**只有一个目标，无依赖无命令**

```makefile
###1.目标满足默认条件
	test:
		#有以test为前缀,.c为后缀得test.c，且命令缺省，满足默认条件
		#执行结果：
		cc     test.c   -o test


###2.目标不满足默认条件
	a:
		#不存在以a为前缀,.c为后缀得a.c，不满足默认条件，且命令缺省。
		#执行结果：
		make: 对“a”无需做任何事。
```

**2.有目标，有依赖，但没命令**		

```makefile
	###1.目标满足默认条件，且缺省命令，且依赖当前目录存在，执行默认语句
		test:a.txt
			#执行结果：
			cc     test.c a.txt   -o test
			
			
	###2.目标满足默认条件，且缺省命令，但依赖不存在当前目录，则需要make依赖，创造成功但命令缺省，则执行默认语句，不过默认语句要加上依赖文件
		#2.1如果依赖作为目标满足默认条件，则先执行默认语句创造依赖，再执行本次make语句
		test:add
			#执行结果：
			cc     add.c   -o add
			cc     test.c add   -o test
		#2.2如果依赖作为目标不满足默认条件，且没有制作依赖的语句，则全报错
		test:a
			#执行结果：
			make: *** 没有规则可制作目标“a”，由“test” 需求。 停止。
		#2.3如果依赖作为目标不满足默认条件，且有制作依赖的语句，先执行创造依赖的语句，制作依赖的语句可以当作新的语句来继续进行判断是否制作成功，若成功，再执行本次make默认语句
		test:a
		a:add
			#执行结果：
			cc     add.c   -o add
			cc     test.c a   -o test
	
	
	
	###3.目标不满足默认条件，且缺省命令，先创建依赖，依赖创建规则同上，又因为缺省命令，所以此次make语句相当于不会执行，不是报错(此时叫伪目标)。
		a:add
			#执行结果：
			cc     add.c   -o add
		a:b
			#执行结果：
			make: *** 没有规则可制作目标“b”，由“a” 需求。 停止。
		a:b
		b:add
			#执行结果：
			cc     add.c   -o add
```

3**.有目标，有命令，但没依赖。**

不存在满不满足默认条件的问题，因为满足默认条件了，只是为了执行默认语句命令，都有了命令，肯定不是默认命令了啊，故目标满不满足默认条件不影响

```makefile
###无论目标满不满足默认条件，都会按照命令执行
	a:
		@echo hello
		#执行结果：
		hello
		
	test:
		@echo hello
		#执行结果：
		hello
		
		
###如果目标与当前目录下文件重名：解决办法.PHONY
	test.c:
		@ehoc hello
		#执行结果:
		make: “test.c”已是最新。
	
	.PHONY:test.c
	test.c:
		@ehoc hello
		#执行结果:
		hello
```

4.**有目标，有命令，有依赖**

```makefile
#先制作依赖，再根据命令不是默认命令制作目标!!,不存在满不满足默认条件的问题，因为满足默认条件了，只是为了执行默认语句命令，都有了命令，肯定不是默认命令了啊，故目标满不满足默认条件不影响
```

makefile每条语句生成的目标都只是作为中间结果，和最终的一个目标，这些中间结果和最终目标文件会不会在当前目录下创建是要看以它们为目标的语句所用的shell命令是不是会去在当前目录下创建文件。不会在当前目录下创建目标文件的语句：叫做伪目标语句。

# >>>>>>数据结构与算法>>>>>>

学习任何数据结构，要想清楚它属于什么逻辑结构，利用什么存储结构，以及如何组织各个数据属性作为结构体中的数据，这些都是对数据结构的组织定义。其次就是对组织好的结构数据进行增删查改，排序，就是算法了。

# 0.导学

## 1.分文件编程

- .h 数据结构的定义，以及声明有哪些操作
- .c 操作的具体实现
- main.c  主要调用.h里定义的函数实现主要逻辑

## 2.数据结构算法思路

1.确定算法函数的三要素：功能，返回值，形参

2.根据传入的参数，分别对处于临界之外（算法不处理），临界值（假设是临界值之内的值看看是否出错来确定应该属于临界值之外还是之内），临界之内（一般项，算法需处理的）做处理。

3.**画图**，根据已有思路进行关键步骤分析，写成形参为一般项时的取值范围，最后根据步骤编写相应代码。（当调用其他函数时，也要考虑其他函数返回值的情况）

4.思考返回值的值。

# 1.数据结构引入

## 1.1.数据结构种类

1. **可以找到任意多个元素，它们之间存在某种关系的**
   线性表，树，图

2. **元素之间除了同属于一个集合，再无其他关系**

   集合


## 1.2.数据结构理解

逻辑结构+存储结构+操作

### 1.2.1.逻辑结构

数据元素运算之间具体的抽象关系

- 线性结构(线性表，栈，队列）

- 集合

- 树形结构

- 图状结构


### 1.2.2.存储结构

在计算机中具体存储的实现方法

- 顺序存储：空间连续

- 链式存储

- 索引存储：存数据文件+索引表==书的内容+书的目录，根据索引表确定存取地址

- 散列存储：根据数据本身来确定存取地址


### 1.2.3.数据的操作

增删查改，排序

# 2.线性表

## 2.1.线性表的表示

- **一般表示**
  L=（a0，a1，……an-1），L为表名

- **二元组表示**

  L=（D|R)


## 2.2.操作

1）建空表

2）置空表

3）是否为空，是否为满

4）求表长

5）查找某个元素的值

6）定位

## 2.3.顺序表及其操作的实现

 

## 2.4.单链表及其操作的实现

### 2.4.1.结点组织定义

```c
typedef int Data_t;
typedef struct node{
	Data_t data;
	struct node *next;
}listnode,*linklist;
```

### 2.4.2.操作

- 链表的倒序

  链表一分为二，成为两个链表，不需要再`malloc`重新建一个新表了。  

### 2.4.3.带头结点和不带头结点的函数区别

- 一个返回值可以为void，一个返回值必须为linklist或者传二级指针
- 注意指针（不要以为传的是指针就不会）为形参时也会存在局部变量改变但不改变外部引用变量的情况 

# 3.队列

## 3.1.一般队列

先进先出

## 3.2.循环队列

### 3.2.1.判断队满队空

为了区分空队和满队，满队的最后一个空间不存元素。

队空：front=rear

队满：rear+1 == front

### 3.2.2.初始化

创建空队列，头和尾相等就可以，不一定要为0；

## 3.3.链式队列

带头结点的删除（两种方法）：

1.当只有一个结点时，删除后，还要让rear重新等于front

2.每次只删除头节点，队头front指向的元素作为删除后新表的新头结点。

栈和队列的应用：球钟问题

 

 

树：

递归程序特征：

1.有递归特征

2.有递归出口

查找：

顺序查找：ASL = o(n)

折半查找：ASL = o(log2(n+1)) 前提：顺序表有序

分块查找：块间有序，块内无序

哈希查找：key与记录的存放地址有关系 f:key->add add = H(key) key是自变量，add是因变量

​       1.选用什么样的哈希函数 （

保留除数法：H（key）= key%p p选取为质数，p大，则余数范围大，冲突概率小，但太大浪费空间

填充因子：α=n（记录个数）/m（表长）取值在0.7~0.8之间 p应该为不大于m的最大质数

）

​       2.有冲突了选用什么样的方法解决冲突

（1.开放地址法：H=(H(key)+d)%m 

   d的取法:

线性探测法

二次探测法

 2.链地址法：相同地址下按key值有序插值）

排序：

插入排序：

直接插入排序

二分插入排序

交换排序：

冒泡排序

快速排序



### Ncurses库：

#include  <curses.h>

——————————————————————

**1.initscr(void)**

​		//创建窗口，包括为窗口分配内存

**2.int endwin(void)**

​		//释放窗口

——————————————————————————

**3，int curs_set(int  visiblility)**

​		//设置光标是否可见

​		//visibility 0不可见，1可见

**4.int move(int dest_x,int dest_y)**

​	//移动到指定的行和列

**5.int addch(const chtype char)**

​	//在当前光标位置添加字符

————————————————————————————————————

**6.int refresh(void)**

​	//刷新物理屏幕，将获取的内容显示到显示器上

**7.int keypad(WINDOW *window_ptr,bool key_on)**

​	//启用F1-F12功能键

​	//example:keypad(stdscr,1)stdscr,当前工作界面，1启用设置

——————————————————————————————————————

**8.int getch(void)**

​	//读取键盘输入的一个字符，会阻塞等待！！

**9.chtype inch(void)**

​	//获取当前屏幕光标位置的字符，记得强转chtype为char型

**10 noecho();**

​	//不显示手动键盘输入的字符，当摁下q控制某个行为时，只执行该行为，不显示q

**11.int start_color(void);**

​	//启动color机制

**12int init_pair(short pair_number,shrort foreground,short background);**

​	//配置颜色对

​	//pair)number表示第几次调用init_pair函数，即第几组

​	1.黑COLOR_BLACK，品红

​	2红，青

​	3绿，白

​	4.黄，蓝

**13 int COLOR_PAIR(int pair_number)**

​	//设置颜色属性，设置完颜色对，可以通过此函数实现

**14int attron(COLOR_PAIR())**

**15 int attrof(COLOR_PAIR())**

