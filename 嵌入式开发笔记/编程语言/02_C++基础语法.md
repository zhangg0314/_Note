# ——C++面向过程——

# 第一个C++程序

## C++文件名格式

```shell
vim hello.cpp
#c++文件一般命名为.cpp文件,.cxx,.hpp,.cc
```

> [!NOTE]
> `.hpp`是函数声明和定义放一起的文件，是`.h`和`.cpp`的结合体。

## 程序内容介绍

> [!NOTE]
> 	c++ 使用IO相关的函数时的标准头文件类似于`stdio.h`
> 	c++ 风格的很多头文件在include的时候没有`.h`后缀
> 	c++兼容c，c++中可以使用c的`stdio.h`或者c++的`cstdio`

```c++
#include <iostream>
using namespace std;//命名空间
int main(int argc, char *argv[]){
	cout << "hello world" << endl;//类似于printf("hello world\n")，cout 输出对象，endl 相当于\n。
	return 0;
} 
```

## Linux编译命令

```shell
g++ hello.cpp -o hello

g++ hello.cpp -o hello -stdc++=11

gcc hello.cpp -o hello -lstdc++

./hello
```

> [!TIP]
> g++ `hello.cpp` -o hello -`stdc`++=11
> 指定使用c++11的标准编译，比如默认的编译器版本过高时，默认舍弃了一些用法如`auto_ptr<T>`指针，而代码中用到了这个指针，直接默认版本编译，会报错，因此要指针使用支持该指针语法的编译器版本即可。

# C++嵌套C语言

## extern "C"介绍

extern "C"起作用的时候是在C++调用C中的函数时候。由于C++和C是两种不同的编译和连接方法，所以在交叉调用的时候，就需要增加一些机制起到让两者无缝兼容的目的，而extern "C"正是这一种机制。
规定在编译C++源文件时，那些调用自C文件的部分（需要用extern "C"修饰其在头文件中的声明），按照与C文件编译兼容的方式进行。那么显然在不涉及C++调用C中函数的情况，extern "C"是不起作用的。
在编译C文件的时候，编译器是不会自动添加`__cplusplus`的宏定义；而在编译C++文件的时候，编译器会自动的对`__cplusplus`进行宏定义。

## 测试源码

- **add.c**

  ```c
  #include "add.h"
  void add_fun(int a,int b)
  {
      printf("%d\n",a + b);
  }
  ```

- **add.h**

  ```c
  #ifndef _ADD_H_
  #define _ADD_H_
  #include <stdio.h>
  void add_fun(int a,int b);
  #endif
  ```

- **main.cpp**

  ```c++
  #include "add.h"
  int main(int argc ,char** argv)
  {
      add_fun(1,2);
      return 0;
  }
  ```

- **编译**

  ```shell
  g++ -S main.cpp
  gcc -S add.c
  ```

- **编译结果_add.S**

  ```shell
  	.file	"add.c"
  	.section	.rodata
  .LC0:
  	.string	"%d\n"
  	.text
  	.globl	add_fun
  	.type	add_fun, @function
  add_fun:   #!!!!!!!!!!!
  .LFB0:
  	.cfi_startproc
  	pushq	%rbp
  	.cfi_def_cfa_offset 16
  	.cfi_offset 6, -16
  	movq	%rsp, %rbp
  	.cfi_def_cfa_register 6
  	subq	$16, %rsp
  	movl	%edi, -4(%rbp)
  	movl	%esi, -8(%rbp)
  	movl	-8(%rbp), %eax
  	movl	-4(%rbp), %edx
  	addl	%edx, %eax
  	movl	%eax, %esi
  	movl	$.LC0, %edi
  	movl	$0, %eax
  	call	printf
  	leave
  	.cfi_def_cfa 7, 8
  	ret
  	.cfi_endproc
  .LFE0:
  	.size	add_fun, .-add_fun
  	.ident	"GCC: (Ubuntu 4.8.4-2ubuntu1~14.04.4) 4.8.4"
  	.section	.note.GNU-stack,"",@progbits
  
  ```

- **编译结果_main.cpp**

  ```shell
  	.file	"main.cpp"
  	.text
  	.globl	main
  	.type	main, @function
  main:
  .LFB0:
  	.cfi_startproc
  	pushq	%rbp
  	.cfi_def_cfa_offset 16
  	.cfi_offset 6, -16
  	movq	%rsp, %rbp
  	.cfi_def_cfa_register 6
  	subq	$32, %rsp
  	movl	%edi, -20(%rbp)
  	movq	%rsi, -32(%rbp)
  	movl	$10, -8(%rbp)
  	movl	$5, -4(%rbp)
  	movl	-4(%rbp), %edx
  	movl	-8(%rbp), %eax
  	movl	%edx, %esi
  	movl	%eax, %edi
  	call	_Z7add_funii     #！！！！！！！！！！！！！！！
  	movl	$0, %eax
  	leave
  	.cfi_def_cfa 7, 8
  	ret
  	.cfi_endproc
  .LFE0:
  	.size	main, .-main
  	.ident	"GCC: (Ubuntu 4.8.4-2ubuntu1~14.04.4) 4.8.4"
  	.section	.note.GNU-stack,"",@progbits
  
  ```

- **链接结果**

  ```shell
  #在连接程序的最后阶段，出现错误提示：
  /tmp/cc7e9Shj.o：在函数‘main’中：
  main.cpp:(.text+0x28)：对‘add_fun(int, int)’未定义的引用
  collect2: error: ld returned 1 exit status
  ```

## 原因分析

因为`add.c`程序在编译的时候被翻译成了函数标号`add_fun`。也就是说`add.c`文件的add_fun()函数在编译的时候，其对应的标号是**add_fun**。而`main.cpp`文件调用该函数的地方，编译后却使用了标号**`_Z7add_funii`**。那么显然在连接的时候，连接器无法将这两个标号连接到一起，而出现上述错误。

## 使用extern “C”解决

  ```c
  //修改config.h，内容为
  #ifndef    __CONFIG_H
  #define    __CONFIG_H
  extern "C" void config(void);
  #endif
  ```

由于extern "C"修饰了void add_fun(void)，所以在`main.cpp`调用该函数的时候按照C文件的编译方式进行编译，所以其对应的标号为**add_fun**。add_fun函数所在的文件`add.c文件编译出的标号与之一致，就能成功的连接。

# 输入输出流

> [!NOTE]
> 输入流：从输入设备流向内存的字节序列。
> 输出流：从内存流向输出设备的字节序列。

`cout`和插入运算符`<<`：
	执行`cout`语句时遇到`<<`运算符就会将要输出的信息插入到输出流中去，优势在于**自动解析**要输出的数据类型。

`cin`和提取运算符>>：
	执行`cin`时遇到`>>`运算符会从输入字节流中取一个数据放到`>>`后面的变量中去。

> [!CAUTION]
> 假如ch是char类型，输入34，只有3会被存进去，4继续留在输入流中。
> 当要输入多个变量时，一直输入直到遇到数据类型不匹配时停止输入并把出错的那个变量直接赋值为0。

```c++
#include <iostream>
using namespace std;
int mian(){
    int a;
    float b;
    char c;
    cin >> a >> b >> c//12.34a
    cout << "a:" << a << "b:" <<b << "c:" << c
    return 0
}
//执行结果
    12 0.34 a
```

# 名字空间

## 作用

解决命名冲突的变量或者函数名，故不同名字空间里可以定义相同名字的变量或者函数。

## 语法

```c++
namespace ns1{
    int num;
    void func(void){
        cout << "fun1"<< endl;
    }
}
namespace ns2{
    int num;
    void func(void){
        cout << "fun1"<< endl;
    }
}
```

## 名字空间成员访问

1. `::`访问

   ```c++
   ns1::func();
   ```

2. 引用单个成员

   ```c++
   using ns1::func;  
   func();
   ```

3. 引用所有成员

   ```c++
   using namespace ns1
   ```

4. 匿名名字空间引用
   匿名空间用于限制变量、函数和类的作用域，使其仅在定义它们的文件中可见。这有助于减少全局命名空间的污染，提高代码的可读性和可维护性。通过使用匿名命名空间，可以实现文件局部性，同时保持代码的灵活性和可扩展性。

   ```c++
   namespace {
       int num;
       void func(void){
           cout << "fun1"<< endl;
       }
   }
   func()//即::前面无名字
   ```

5. 单`::`引用

   > [!NOTE]
   >  ::   作用域解析运算符前面没有任何东西时，表示的是全局作用域。这种用法在以下几种情况下非常有用：
   > 1）访问全局变量，避免局部变量的遮蔽。
   > 2）调用全局函数，避免局部函数的遮蔽。
   > 3）访问全局类型，避免局部类型的遮蔽。
   > 4）避免命名冲突，明确指定全局作用域。

   ```c++
   #include <iostream>
   
   int globalVar = 42;
   
   void printGlobalVar() {
       int globalVar = 100; // 局部变量，遮蔽了全局变量
       std::cout << "Local globalVar: " << globalVar << std::endl;
       std::cout << "Global globalVar: " << ::globalVar << std::endl; // 使用 :: 访问全局变量
   }
   
   int main() {
       printGlobalVar();
       return 0;
   }
   ```

6. 坑：

   ```c++
   #include <iostream>
   using namespace std;
   namespace ns1{
   	void func(void){
   		cout << "ns1 func" << endl;
   	}
   }
   namespace ns2{
   	void func(void){
   		cout << "ns2 func" << endl;
   	}
   }
   int main(int argc, char *argv[]){
       ns1::func();
   	using ns1::func;
   	func();//这个编译器知道一定是ns1的，因为此时ns2未引入
   	using ns2::func;
   	func();//此时两个名字空间都引入，但func编译器也不知道是哪一个名字空间的
   	return 0;
   }
   //error: call of overloaded ‘func()’ is ambiguous
   //故后用using引用方式要注意此情况，而ns1::func()需要用一次引入一次，但不会此情况
   ```

## 名字空间嵌套

```c++
#include <iostream>
using namespace std;
namespace ns1{
	void func(void){
		cout << "ns1 func" << endl;
	}
	namespace ns2{
		void func2(void){
			cout << "ns2 func" << endl;
		}
	}
}
int main(int argc, char *argv[]){
	using ns1::func;//using namesapce ns1
	func();
	using ns1::ns2::func2;//using ns2::func2
	func2();
	return 0;
}
```

------

# C++数据类型

## 对C数据类型的扩展

在C数据类型的基础上引入了字符串类型，对并对结构体，联合体，枚举，布尔类型做了改进。

## 结构体

- C++结构体中可以直接定义函数，谓之成员函数(方法)

- C++结构体定义好后再声明时可以省略struct，赋值方式同C

  ```c++
  struct Complex{
      double r;
      double i;
      void init(double rr,double ii){
          r = rr;
          i = ii;
      }//定义成员函数
      double real(){
          return r;
      }
      double image(){
          return i;
      }
  };
  Comlex a; //声明时省略关键字
  a.init(3,5);
  cout << a.real() << "+" <<a.image()<<"i"<<endl;//3+5i
  ```

## 联合体

- 一样可以省略union关键字

- 支持匿名联合体，即联合体没有名字，引用成员时直接用成员名

  ```c++
  #include <iostream>
  #include <cstring>
  union{
      char r;
      int i;
  };
  using namespace std;
  int main(int argc, char *argv[]){
  	i = 2;//把匿名联合体的成员当局部变量用
      cout << i << endl;
  }
  ```

## 枚举

- 可以省略enum

- C++的枚举类型是一个单独的数据类型，不是整型，不能当整型使用，如进行赋值，自加自减等

  ```c++
  #include <iostream>
  enum Complex{
      r,
      i
  };
  using namespace std;
  int main(int argc, char *argv[]){
  	Complex a;
  	a = r;
  	cout << a << endl;//0
  	a++; //error
      a = 3; //error
  	return 0;
  }
  //1.
  enum_t.cpp: In function ‘int main(int, char**)’:
  enum_t.cpp:11:10: error: no ‘operator++(int)’ declared for postfix ‘++’ [-fpermissive]
     11 |         a++;
        |         ~^~
  //2.
  enum_t.cpp: In function ‘int main(int, char**)’:
  enum_t.cpp:11:13: error: invalid conversion from ‘int’ to ‘Complex’ [-fpermissive]
     11 |         a = 3;
        |             ^
        |             |
        |             int
  
  ```

## 布尔类型

- C++布尔类型是基本数据类型，表示逻辑的真假。
- 单字节的整数，值为true为1和false为0，默认输出0或1，但输出加上`boolalpha` 后输出就是true或false。
- 任何其他数据类型可以隐式转为布尔类型，0为false，非0为true。

## 字符串

- 兼容了C的字符串处理方法和函数

- 专门设计了string类型表示字符串

- string的定义

  ```c++
  string s1 = "Hello";
  string s2("Hello");
  string s3 = string("Hello")  
  ```

- string的拷贝

  ```c++
  string s1 = "hello";
  string s2 = s1;
  ```

- string 的连接

  ```c++
  s1 +=s2;
  s1 = s1 + " " + s3;
  s2 = s2 + " " + s4;
  ```

- 字符串比较

  ```c++
  if (s1 == s2)
  ```

- 随机访问

  ```c++
  string s = "hello";s[0] = "H";
  ```

- 获取长度:`s.size()`,`s.length()`不算\0

- 转为C风格字符串：`const char* c_str()`;`const char*p = s.c_str()`;

- 字符串交换：`void swap(string &s1,string &s2)`

------

# 类型转换

也有隐式（编译阶段完成转换），显示转换

## 一般显示转换

```c++
int a = 4;
float b = (float)a;
float c = float(a);
```

## 强制转换操作符

> [!NOTE]
> 这是C++独有的类型转换，且更安全。

### `static_cast`

常用于基本数据类型的数据之间、`void*`与其他类型指针之间、有继承关系的类之间的转换，其他情况不允许用此转换。
**安全性**：相对安全，但不能在运行时检查类型转换的安全性。

```c++
double d = 3.14;
int i = static_cast<int>(d); // 将 double 转换为 int

class Base {};
class Derived : public Base {};

Base* b = new Derived();
Derived* d = static_cast<Derived*>(b); // 将 Base* 转换为 Derived*
```

### `dynamic_cast`

主要用于**具有多态**继承关系的**父子类**指针或引用之间的显示转换。
**安全性**：非常安全，因为运行时会检查类型转换的安全性。相比于其他转换的好处在于虽然**编译时不会报语法错误，但运行时会出错的话**，转换的指针就会被赋值为NULL。

> [!TIP]
> 此运算符是用于判断运行时是否出错，即不仅能检查语法上是否出错，也能检查执行时转换是否成功。即有了问题我可以分析出来。C语言的强制哪怕出错了，也不会告知，但这种类型强制出错了会返回null，我们就可以通过指针是否为null来编写强制出错处理的代码。

```c++
class C{};
class Base{
    virtual ~Base{};
};
class Derived:public Base{};
int main(){
    Base *pb,b;
    Derived *pd,d;
    C c;
    pb = &d;//向上造型，隐式转换
    pb = dynamic_cast<Base*>(&d);//向上造型，显示转换
    
    pb = dynamic_cast<Base*>(&c);//C类与Base类毫无关系，虽然编译时此处不报错，但是运行时转换失败，pd值为NULL。
    if(pb){
        cout << "ok" << endl;
    }else
    {
        cout << "error" << endl;
    }
}
//输出
error
```

### `const_cast`

用于修改变量的 `const `或 `volatile `属性，不改变变量的实际类型，只是改变其修饰符。
**安全性**：相对安全，但移除 `const `属性后，修改变量可能导致未定义行为。

```c++
const int ci = 42;
int* p = const_cast<int*>(&ci); // 移除 const 属性
```

### `reinterpret_cast`

用于在不同类型之间进行低级转换、指针和整数之间的转换，或不同类型指针之间的转换。

**安全性**：非常危险，可能导致未定义行为。

```c++
#include <iostream>
using namespace std;
int main(int argc, char *argv[]){
	float a = 2.3;
	int b = static_cast<int>(a);
	cout << "a:" << a << endl; //2.3
	cout << "b:" << b << endl; //2
	int *p = &b;
	void *q = static_cast<void*>(p);//正确
	void *p2 = &a;
	float *q2 = static_cast<float*>(p2);//正确
	float *q3 = static_cast<float*>(p);// error: invalid ‘static_cast’ from type ‘int*’ to type ‘float*’
    float *q3 = reinterpret_cast<float*>(p);//正确
    q3 = 0x20;//error: invalid conversion from ‘int’ to ‘float*’
    q3 = static_cast<float*>(0x20);//error: invalid ‘static_cast’ from type ‘int’ to type ‘float*’
    q3 = reinterpret_cast<float*>(0x20);//正确
	return 0;
}

int a = 100;
double b = static_cast<double>(a);
void* p = malloc(100);
char *p = malloc(100);
int *a = (int*)p //C
int *a = int*(p)//C++
int *a = static_cast<int*>(p)//error
int *a = reinterpret_cast<int*>(p)//可以
int a = static_cast<int>(p)//error
int a = reinterpret_cast<int>(p)//可以
    //整数与指针之间的转换相当于C中给指针赋值一个整数，可以认为直接赋值了一个地址
```

------

# 引用

## 定义

- 引用是某个对象/变量的别名

  ```c++
  int a = 10;
  int &ar = a;
  //给变量名取了别名，a和ar占用同一块位置空间
  cout << "&a:" << &a << "---" << a  << endl;
  //&a:0x7ffee37157ec---10
  cout << "&ar:" << &ar << "---" << ar  << endl;
  //&b:0x7ffee37157ec---10
  ```

- 引用在定义时就必须初始化

  ```c++
  int& c;
  //error: ‘c’ declared as reference but not initialized
  c = a;
  ```

## 引用的本质

引用的本质其实就是指针常量 :`<数据类型 >  *const p`,所以必须定义时赋初值，又因为指针常量指向哪个区域虽然不能改，但其所指向的区域的内容是可以改的。故其内容不能是常量，正因如此才不能赋值常量，因为常量不能改。

## 用途意义

1. 简化编程，用指针的地方可以用引用。
2. 引用作为函数的形参没有再申请内存空间，可以使系统开销更小。
3. 引用可以作为函数参数和函数返回值。

> [!CAUTION]
> 1.引用必须在定义时就初始化。
> 2.`const`常引用，一般引用是对左值如变量的引用，不能对右值如常量，表达式进行引用。
> 3.常引用，常引用可以引用变量和常量，表达式，也叫万能引用，但通过常引用变量不能修改变量的值。
>
> ```c++
> int &i = 10;
> //error: cannot bind non-const lvalue reference of type ‘int&’ to an rvalue of type ‘int’
> const int &i = 10
> //正确
> i++;
> //error: assignment of read-only reference ‘i’
> ```

## 引用型参数

即函数的形参是引用，如果不希望函数内部的实现对形参进行改动，则形参应该为常引用，此时，实参既可以传变量这些左值也可以传常量这些右值。

## 返回引用

在函数内部实现定义的变量，函数返回值是该变量的引用，但当函数执行完后，函数内部变量属于局部变量会被回收，故后续利用其引用可能会出错，相当于利用一个野指针，所以返回引用多用在后面面向对象实现类的成员函数或者运算符重载时返回的引用是外部传进来的变量的引用的情况。

## 指针和引用的区别

- 指针指向一块内存，它的内容是所指内存的地址；引用是某块内存的别名。 
- 指针是一个实体，而引用仅是个别名；引用使用时无需解引用（*），指针需要解引用； 
- 引用只能在定义时被初始化一次，之后不可变；指针可变； 
- 引用不能为空，指针可以为空； 
- `sizeof(引用)`得到的是所指向的变量（对象）的大小，而`sizeof(指针)`得到的是指针本身的大小；

------

# C++函数

## 缺省参数

在C++中，函数的形参列表中的形参是可以有默认值的。有默认值的参数即为默认参数。在函数调用时，有默认参数可以缺省。

```c++
int add(int x,int y ,int z = 100){
    return x+y+z;
}
int main(){
    cout << add(1,2,3) << endl;
    cout << add(1,2)   << endl;
    return 0;
}
```

> [!CAUTION]
> 1.传的实参中没有给实参，用默认值，传了就用指定值。
> 2.默认值靠右原则，即如果某个参数有默认值，其后面的都必须有默认值。
> 3.函数的声明和实现只能有一个位置去说明有默认参数，不然就报错。
>
> ```c++
> int add(int x,int y ,int z = 100);
> int add(int x,int y ,int z =100){//error: default argument given for parameter 3 of ‘int add(int, int, int)’ 
>     return x + y + z;
> }
> //倘若声明给的是z = 100，实现给的是 z = 200，编译器不知道到底要用哪个默认值，为了省事，干脆把声明和实现的缺省参数默认值一样的情况也归为此类错误。
> ```

## 哑元

### 定义

只有类型没有变量名的参数。

### 使用场景

- 兼容旧代码，保证函数的向下兼容性

  ```c++
  void fun(int i,int j){...}---> void fun(int i){...};//麻烦，函数升级，应用要修改代码
  void fun(int i,int j){...}---> void fun(int i,int /*哑元*/){...};
  ```

- 操作符重载，区分前后++和---

  ```c++
  Integer& operator++(){...};//前++
  Const Integer operator++(int){...};//后++
  ```

------

## 函数重载

### 重载定义

**同一作用域**中，函数**名称相同**，但参数表必须有所区分（形参的类型或个数或顺序不一样），将构成重载关系。故多个函数只要参数列表有区别，这些函数的函数名可以重名。

> [!CAUTION]
> 形参变量名不同，不**构成**重载关系。
> 函数返回值类型不同，不构成重载关系的要素，即不**影响**重载关系。

```c++
#include <iostream>
using namespace std;
void swap(int *a,int *b){
	int tmp = *a;
	*a = *b;
	*b = tmp;
}
void swap(char *a,char *b){
	char tmp = *a;
	*a = *b;
	*b = tmp;
}
int main(int argc, char *argv[]){
	int x = 10;
	int y = 20;
	swap(&x,&y);
	cout << x << " " << y <<endl; 
	return 0;
}
```

### 重载的实现

编译器将形参变量的类型作为最终函数名的一部分。

```shell
nm a.out

...
...
000000000000121a T _Z4swapPcS_
00000000000011e9 T _Z4swapPiS_
...
...
```

### 匹配选择优先级

1. **完全匹配**
   函数形参有与实参类型完全匹配的（最高优先级）
2. **常量转换**
   char实参，`const char`形参常量转换（较好优先级）
3. **升级转换**
   short实参匹配int形参升级转换（一般优先级）
4. 降级转换//较差
   降级转换是相对于省略匹配来讲的，即不能float在int和short里进行降级，而是在int和省略号里降级为int，或者在short和省略号里降级为short。
5. 省略号匹配//最差

```c++
#include <iostream>
using namespace std;
void bar(int a){
	cout << "bar(int)" << endl;
}
void bar(char a){
	cout << "bar(char)" << endl;
}
void bar(...){
	cout << "bar(...)" << endl;
}

void foo(int a){
	cout << "foo(int)" << endl;
}
void foo(const char a){

	cout << "foo(const char)" << endl;
}
int main(int argc, char *argv[]){
	char a = 'a';
	bar(a);  //bar(char),完全匹配
	foo(a);  //bar(const),常量转换
	float b = 2.3;
	bar(b);  
    //此时要注释掉bar(int)或者bar(char),那么执行结果是bar(char)或者bar(int)
    //即供选择的不能是两个不一样类型的比当前类型低级的类型，而必须是一个低级类型，一个省略号
	short c = 2;
	bar(c); 
	return 0;
}
```

### 二义性问题

- 默认类型转换带来的二义性
  即实参到形参都是升级或者降级转换

  ```c++
  void bar(int a){
  	cout << "bar(int)" << endl;
  }
  void bar(char a){
  	cout << "bar(char)" << endl;
  }
  float b = 2.3;
  bar(b);//解决问题，强转实参b
  
  In function ‘int main(int, char**)’:
  error: call of overloaded ‘bar(float&)’ is ambiguous
     21 |         bar(b);
        |         ~~~^~~
  note: candidate: ‘void bar(int)’
      3 | void bar(int a){
        |      ^~~
  note: candidate: ‘void bar(char)’
      6 | void bar(char a){
        |      ^~~
  ```

- 缺省参数带来的二义性

  ```c++
  void fun(int a,int b,int c = 100){...}
  void fun(int a,int b){...}
  fun(1,2)
      //ambisguos
  ```

## 内联函数

不需要建立函数调用的运行环境的栈空间，不需要进行参数传递，不需要跳转，让执行效率更高。

```c++
inline int add(int x,int y)
{//即加一个inline关键字
    return x + y;
}
int main(void){
    int ret = add(3,5)//int ret = 3 + 5,即直接把内联函数的执行逻辑展开，并不调用函数
}
```

> [!CAUTION]
> `inline`只是建议编译器内联，但编译器不一定会做内联。
>  调用内联函数之前，要先定义和声明好函数是内联的。
>  一般几行代码的函数用内联，但像递归和一些执行复杂逻辑的函数不用内联。

# 动态内存管理

## 申请内存

`new 或者 malloc`

```c++
int *p1,*p2,*p3;
p1 = new int;
	//p1 = (int*)malloc (sizeof(int));
p2 = new int(123);
	//申请一个int类型空间，并初始化为123,不是空间地址即p2的值为123，而是空间里存的是123
p3 = new int[123];
	//申请123个int类型内存空间,即申请数组
```

## 释放内存

`delete或者free`

```c++
delete p1;
delete p2;
/*释放整个大小为123的数组空间*/
delete []p3;
/*释放一个int型内存空间p3[0]*/
delete p3;
```

# ——C++面向对象——

面向对象更适合于开发大型软件，更有利于代码的复用。

# 面向对象三大特性

## 封装

将数据和操作数据的函数包装在一起的主要目的就是实现封装和隐藏。隐藏就是不让结构体外的函数直接修改结构体中的数据，只能通过结构体的成员函数对数据进行修改。

为了实现数据的隐藏，C++新增3三个访问权限限定符

- public公有的，函数和数据可以被结构体内外的任何函数包括main函数访问。
  <u>自己，子类以及外部都能访问</u>
- protected保护成员，与继承相关，能被派生类访问，但不能被类外的任何地方访问。
  <u>只能自己和子类访问，但外部不能访问</u>
- private （隐藏）私有的，只能被结构体内部函数访问。
  <u>只有自己能访问，子类以及外部不能访问</u>

## 	继承

## 	多态

------

# 面向对象实现手段

## 结构体

C++特有的内部可以调用或者实现函数的结构体。

- **`struct`关键字**
  用于定义结构体，它告诉编译器后面要定义的是一个自定义类型。
- **成员变量**
  成员变量是结构体中定义的数据项，它们可以是任何基本类型或其他自定义类型。<u>在`struct`中，这些成员默认是 public，可以直接访问。</u>
- **成员函数**
  结构体中也可以包含成员函数，这使得结构体在功能上类似于类。成员函数可以操作结构体的成员变量，提供对数据的封装和操作。
- **访问权限**
  与 class 类似，可以在`struct`中使用 public、private 和 protected 来定义成员的访问权限。在 `struct `中，默认所有成员都是 public，而 class 中默认是 private。

## 类

功能与`struct`相同，但更安全的一种全新数据类型，更安全是因为**类成员默认都为private，而结构体成员默认都为public。**

```c++
class class_name{
    private:
    	....
        ....
    public:
    	void fun1();
    	void fun2();
    	int fun3();
         ...
            
};
void class_name::fun1(){
    
}
void class_name::fun2(){
    
}
int class_name::fun3(){
    
}
//类内声明函数，类外定义函数
```

## 结构体与类对比

- **性能开销**

  结构体：通常更适合简单的数据结构，访问效率更高，因为它们的内存布局更紧凑，不需要额外的封装开销。
  类：虽然类的封装和继承机制可能会引入一些额外的开销，但这种开销通常是可以接受的，尤其是在需要封装和多态的场景中。

- **适用场景**

  结构体：适用于简单的数据聚合，没有方法或很少有方法，性能敏感的场景。
  类：适用于封装数据和行为，支持继承和多态，复杂的业务逻辑。

------

# 构造函数

## 构造函数初步

构造函数是与类同名的特殊成员函数，主要用来初始化对象的数据成员，即一次调用全部初始化好。当创建一个类的对象时，构造函数会自动被调用，从而省去了手动调用实现。

## 特点

- 与类同名（包括大小写）
- 没有返回类型，连void都不写
- 可以有0-多个参数
- 可以被重载
- 创建类对象时由系统自动调用，不允许在程序中显示调用

```c++
#include <iostream>  
using namespace std;  
class Box {  
public:  
    double length;   // 长度  
    double breadth;  // 宽度  
    double height;   // 高度  
    // 默认构造函数  
    Box() {  
        cout << "Default Constructor called." << endl;  
        length = breadth = height = 0.0;  
    }  
    // 参数化构造函数  
    Box(double l, double b, double h) {  
        cout << "Parameterized Constructor called." << endl;  
        length = l;  
        breadth = b;  
        height = h;  
    } 
};  
  
int main() {  
    Box Box1;           // 调用缺省/默认构造函数  
    Box Box2(3.3, 1.1, 1.5); // 调用参数化构造函数 
    Box Box3() //error，错误
    return 0;  
}
```

## 缺省构造函数

如果没在类里面实现构造函数，系统自动送一个构造函数一个无参数的构造函数，前提是没有在类里面自定义任何形式的构造函数，而这个被送的函数就是缺省构造函数。

```c++
#include <iostream>  
using namespace std;  
class Price{
	public:
		int ge;
		int shi;
		int bai;
		Price(){
			cout << "Default Constructor called2" << endl;
			ge = shi =bai = 0;
		}
};
class Box {  
	public:  
		int length;   // 长度  
		int breadth;  // 宽度  
		int height;   // 高度  
		Price  price;
};  

int main() {
	Box Box1;           // 调用缺省/默认构造函数  
	cout << Box1.length << " " << Box1.breadth << " " << Box1.height << endl;
    //Default Constructor called2
	//1956810952 29921 1956810376
	return 0;  
}
```

> [!CAUTION]
>
> - 如果一个类没有定义任何构造函数，那么编译器会为其提供一个缺省无参构造函数。
> - 对基本类型成员变量，缺省构造函数不做初始化（**<u>都没有构造函数，编译器不知道要赋什么样的初值，所以就不初始化</u>**）。
> - 对类类型成员变量，缺省构造函数将自动调用相应类的构造函数来初始化。
> - 如果一个类只要自定义了构造函数，无论是否有参数，编译器不再提供缺省构造函数。

## 重载构造函数

> [!TIP]
> 在类里面定义多个构成重载关系的构造函数。

```c++
#include <iostream>  
using namespace std;
struct Param{
	int l,b,h;
};
class Box {  
	public:  
		int length;   // 长度  
		int breadth;  // 宽度  
		int height;   // 高度  
		Box();
		Box(int l,int b,int h);
		Box(Param &param);
};
Box::Box(){
	cout << "defalut constrcutor" << endl;
}
Box::Box(int l,int b,int h){
	length = l;
	breadth = b;
	height = h;
	cout << "constrcutor(int,int,int)" << endl;
}
Box::Box(Param &param){
	length = param.l;
	breadth = param.b;
	height = param.h;
	cout << "constructor(Param &param)" << endl;
}

int main() {
	Box Box1;           // 调用缺省/默认构造函数  
	Box Box2(3,4,5);    //调用参数构造函数
	Param param;	   //调用结构体参数构造函数
	param.l = 3;
	param.b = 4;
	param.h = 5;
	Box Box3(param);
	return 0;  
}
defalut constrcutor
constrcutor(int,int,int)
constructor(Param &param)
```

## 类型转换构造函数

### 定义

将一个其他类型的变量或者常量直接赋值给类，编译器会优先找类中参数与该变量或者常量类型相同的构造函数，利用该变量或者常量通过该构造函数构造出一个类，这样就是类赋值给类，就不会报错了。

> [!NOTE]
> 类型转换构造函数特点就是只有一个参数。

```c++
#include <iostream>
#include <cstring>
using namespace std;
class A{
private:
	int i;
public:
	A(int para){
		i = para;
	}
	A(const char* s){
		i = strlen(s);
	}
	explicit A(char jj){
		i = static_cast<int>(jj);
	}
};
int main(int argc, char *argv[]){
	A a1 = 1;
	A a2 = "Hello";
	A a3 = A('A');
}
```

### `explicit`关键字

- 构造函数前面没加explicit关键字，赋值时写成下面两种形式均可。
- 如果加了explicit关键字，则必须写成强制转换形式

  ```c++
  Integer b = Integer(1);
  Integer b = 1;//error: conversion from ‘int’ to non-scalar type ‘Integer’ requested
  ```

## 拷贝构造函数

### 语法

> [!NOTE]
> 未自定义的话，编译器同样送一个缺省拷贝构造函数。

- 对基本类型成员变量，按字节复制（**<u>因毕竟有已经初始化好的对象赋值给我，我就可以直接调用它里面的基本数据成员的值作为此次拷贝的值）</u>**
- 对于类类型成员变量，调用相应类的拷贝函数。

> [!CAUTION]
> **拷贝构造函数调用时机**
>
> 1. 用已定义对象作为同类型对象的构造函数的实参`A a1(a2)`;
> 2. 以对象的形式向函数传递参数。
> 3. 从函数中返回对象。
>
> **拷贝构造过程风险高且效率低，设计应尽可能避免**
>
> 1. 避免和减少对象的拷贝
>
> 2. 传递对象形参，使用**引用型**参数
>
> 3. 从函数中返回对象，用**引用型返回值**


### 深拷贝与浅拷贝

- **浅拷贝**
  类中的缺省拷贝构造函数，对指针形式的成员变量按字节复制，而不会复制指针所指向的内容，这种拷贝方式称为浅拷贝。**系统给的默认拷贝构造函数为浅拷贝**

- **深拷贝**
  自定义拷贝函数，新建一个成员变量，重新为指针指向内容的申请一块空间，即自定义实现深拷贝。

  ```c++
  #include <iostream>
  using namespace std;
  class A{
  	private:
  		int *data;
  		int *price;
  	public:
  		A(){
  			cout << "A(void)" << endl;
  			data = new int(1);
  			price = new int(1.5);
  		}
  		A(const A &that){//深拷贝构造函数
  			cout << "A(const A)" << endl;
  			data = new int(*that.data);
  			price = new int(*that.price);
  		}
  		void print(){
  			cout << *data << " " << *price << endl;
  		}
  };
  ```

### 拷贝赋值

**含义**：
一个对象已经存在时，用另外一个已存在的对象给他赋值，就发生了拷贝赋值。比如已经声明并创建了对象`i1，i2`，当执行`i2 = i1`语句时,编译器会将其翻译成`i2.operator = (i1)`，即执行operator=成员函数进行处理。
**operator=函数**此函数称为拷贝赋值操作符函数，同样，**没有定义时编译器同样会自动分配，且为浅拷贝**。因此自定义拷贝赋值函数相当于进行等号运算符重载。

```c++
#include <iostream>
using namespace std;
class A{
	private:
		int *data;
		int *price;
	public:
		A(){
			cout << "A(void)" << endl;
			data = new int(1);
			price = new int(1.5);
		}
		A(int arg){
			cout << "A(int)" << endl;
			data = new int(arg);
			price = new int(arg);
		}
		A(const A &that){//深拷贝
			cout << "A(const A)" << endl;
			data = new int(*that.data);
			price = new int(*that.price);
		}
		void print(){
			cout << *data << " " << *price << endl;
		}
		A &operator=(const A &that){//深拷贝赋值
			cout << "A::operator" << endl;
			if(this != &that){
				delete data;  
				delete price;
				data = new int(*that.data);
				price = new int(*that.price);
			}
			return *this;//返回对象本身是为了支持i1 = i2 = i3这种链式连续赋值操作。
						//i2 =i3的返回结果是i2对象自身，故后面才能执行i1= i2;
		}
};
int main(int argc, char *argv[]){
	A a1;//A(void),无参构造函数
	A a2(a1);//A(const A),拷贝构造函数
	A a3 = a1;//A(cosnt A)，拷贝构造函数
	A a4;//A(void),无参构造函数
	a4 = 10;//A(int),类型转换函数，转成A，然后再拷贝赋值函数A operator
	a2 = a3;//A operator 拷贝赋值函数
	return 0;
}
```

## 构造函数总结

> [!NOTE]
> 编译器给的函数都是public权限的。

### 构造函数定义总结

- 构造函数说白了就是在声明类的时候，由系统自动调用构造函数就已经完成了类成员的初始化。

- 构造函数可以重载，从无参数的无参构造函数到有多个参数的一般构造函数；从基本数据类型的参数构造函数到复杂数据类型（如结构体）的参数的构造函数。

- 一般的构造函数 

  ```c++
  定义: A(形式参1，形参2，......){...};
  使用: A a(实参1，实参2，......);
  ```

- 类型转换构造函数

  ```c++
  定义:explict A(形参){...};
  使用：A a = A(实参);  
  //多用于结构体或者其他复杂数据类型赋值给类对象。
  ```

- 拷贝构造函数

  ```c++
  定义：A(const A& parm){...};
  使用：A a; A b = a ;A c(a);
  ```

- 拷贝，一般，类型转换构造函数都构成重载关系。


### 构造函数参数个数总结

1. 0个参数，无参构造函数(自定义)，系统给的缺省构造函数
2. 1个参数，带参构造函数(自定义)，拷贝函数(形参为const 类名& 形参名)，类型转换构造函数。
3. 2个及两个以上参数，带参构造函数(自定义)。

### 拷贝构造、拷贝赋值、类型转换构造区分

拷贝构造，是构造函数，只有当构造某个不存在的对象时才会调用。

拷贝赋值，是赋值函数，赋值的两个操作数对象都是先前已经存在的。

类型转换构造，也是构造函数，但与拷贝构造函数不同的是，拷贝构造函数的参数是一个已经存在的同类型对象，而类型转换函数，虽然把其他类型的参数强制转换成了类类型参数，但这并不算生成了一个后续可以被认为已存在的对象。

------

# 初始化列表

## 语法格式

`:成员1(值1)，成员2(值2)......`

```c++
Box::Box(int l,int b,int h){
	length = l;
	breadth = b;
	height = h;
	cout << "constrcutor(int,int,int)" << endl;
}
等价于
Box::Box(int l,int b,int h):length(l),breadth(b),height(h){
	cout << "constrcutor(int,int,int)" << endl;
}
```

## 必须用初始化列表的场景

- 如果A类a有B类类型成员b，而B类又没有无参构造函数，则必须通过初始化列表显示指明其初始化方式。

  > [!NOTE]
  > 即如果A类的构造函数没有用初始化列表，则调用A类构造函数时，也会自动调用B类构造函数，但是调用B类构造函数时，由于没有带参数给B类，故编译器会以为我们想调用B类的无参构造函数，但B类又没用无参构造函数，所以编译器报错。

- 继承时基类没有无参构造函数，由于继承是要在创建子类之前就把父类创建好，但父类没有无参构造函数，此时要在子类的构造函数中利用初始化列表初始化父类。

  ```c++
  #include <iostream>
  using namespace std;
  class B{
  public:
  	B(int data){
  		cout << "B(int)" << endl;
  	}
  };
  class A{
  private:
  	B  m_data;//error: no matching function for call to ‘B::B()’，由于已经定义了B的构造函数，系统不会分配缺省的无参构造函数，故此时这样声明编译器由于找不到无参构造函数而报错
  public:
  	A(void):m_data(1){//用初始化列表解决上述问题
  		cout << "defalut constructor(void)" << endl;
  	}
  };
  int main(int argc, char *argv[]){
  	A a;
  }
  ```

- **`const`修饰的成员变量**以及**引用型**成员变量必须在初始化列表中初始化。
  `const`修饰的成员变量以及引用(如`int const *p`)都是只读的，故必须在声明时就初始化，不能声明后初始化，因此要在系统调用构造函数时就给它们赋好值，因此要用到初始化列表。

  ```c++
  #include <iostream>
  int num = 100;
  using namespace std;
  class A{
  private:
  	const int m_c;
  	int &m_r;
  public:
  	A():m_r(num),m_c(1){
  		//m_c = 1;  //error:assignment of read-only variable ‘m_c’
  		//m_r = num;//error:assignment of read-only variable ‘m_r’
  
  		cout << "defalut constructor(void)" << endl;
  	}
  };
  int main(int argc, char *argv[]){
  	A a;
  }
  class A{
      public:
      	int& m_r;
      	const int m_c;
      	A(void):m_r(100),m_c(100){
          }
  };
  ```

## 初始化顺序

类中成员变量按声明顺序依次被初始化，而与初始化表中的顺序无关。

```C++
#include <iostream>

using namespace std;
class B{
public:
	B(int data){
		cout << "B(int)" << endl;
	}
	B(){
		cout << "B(void)" << endl;
	}
};
class A{
private:
	B  m_data;
	B  m_r;
public:
	A(void):m_r(),m_data(1){
		cout << "defalut constructor(void)" << endl;
	}
};
int main(int argc, char *argv[]){
	A a;
}
//执行结果
B(int)
B(void)
defalut constructor(void)
```

------

# this指针

## 定义

在程序运行时，类的成员函数存放在进程空间里的代码段里，而其他的私有数据会单独开辟一块空间。
​对于多个类的对象来说，只有私有数据占自己的一块内存空间，而成员函数是在进程代码段供同一进程中同一类的各个对象共享的，但是代码段里被共享的函数是如何区分传入的参数是哪个对象的呢？此时this指针就起到了作用。<u>**this是一个用于标识对象自身的隐式指针，代表对象自身的地址**。</u>

在编译类成员函数时，C++编译器会自动将this指针添加到成员函数的参数列表中。在用类的成员函数时，调用对象会把**自己的地址通过this指针传递给成员函数**。其实调用成员函数时，编译器会隐式地传入了this指针，访问的变量其实就是this->变量名。

```c++
#include <iostream>
using namespace std;
class A{
private:
	int m_data;
public:
	A(){
		this->m_data = 1;
	}
	void print(){
		cout << this->m_data << endl;
	}
};
int main(int argc, char *argv[]){
	A a1;
	a1.print();
	return 0;
}
```

## 使用场景

- 类中的成员变量和类成员函数形参变量名字一样，可以通过this指针区分。
- 从成员函数中返回调用对象自身（返回自引用），支持链式调用。
- 在成员函数中销毁对象自身（对象自销毁）。

```C++
#include <iostream>
using namespace std;
class Counter{
    private:
    	int count;
    public:
    	Counter(int count = 0){
            this->count = count;//成员变量与参数变量重名
        }
    	Counter &add(void){
            ++count;
            return *this;//返回对象本身
        }
    	void print(void){
            cout << count << endl;
        }
        void destroy(void){
        	delete this;//销毁对象本身
        }
}


int main(void){
    Counter cnt;//构造函数初始化为0
    cnt.print();//0
    cnt.add().add().add();//链式操作，3
    cnt.print();//3
    
    Counter* pcn = new Counter;
	pcn->print();
	pcn->destory();
}
```

------

# 常成员函数

## 定义

为了禁止成员函数修改成员数据的值，可以将它设置为常成员函数。设置方法就是在函数体之前加上`const`关键字。用于函数的操作只对成员变量进行读操作。**<u>其实`fun const{}`的本质就是把this变成`const this`</u>**

```c++
#include <iostream>
using namespace std;
class A{
private:
	int m_data;
public:
	A(){
		m_data = 1;
	}
	void add() const{//error: increment of member ‘A::m_data’ in read-only object

		m_data++;
	}
	void print(){
		cout << m_data << endl;
	}
};
int main(int argc, char *argv[]){
	A a1;
	a1.print();
	a1.add();
	a1.print();
	return 0;
}
```

## 注意事项

- 常对象只能调用常函数，非常对象既可以调用非常函数，也可调用常函数，且优先调用非常函数。
  常对象之所以为常对象，是其数据肯定不能变，故肯定不能调用非常对象，不然可能会调用到尝试修改自身数据的函数

  ```c++
  class A{
  private:
  	int m_data;
  public:
  	A(){
  		m_data = 1;
  	}
  	void add(){
  		m_data++;
  	}
  	void print() const{
  		cout << m_data << endl;
  	}
  };
  int main(int argc, char *argv[]){
  	A a1;
  	const A a2;
  	a2.print();
  	a2.add();//error: passing ‘const A’ as ‘this’ argument discards qualifiers 
  	return 0;
  }
  ```

- 函数名和形参表相同的成员函数，常函数和非常函数构成重载关系，因为区别在于this一个有const，一个没const。

- 被mutable修饰的成员又可以在常函数中被修改，相当于编译器开了个后门。

# 析构函数

## 定义

作用与构造函数相反，用于对象生存期结束时，完成对象的清理工作。析构函数的名字是：~类名。

```c++
~X(){...}
```

## 特点

- 无参数无返回值

- 不能重载

- 只能由系统调用，不能显示调用

  1.栈对象【自动调用】，离开其作用域时析构函数自动调用，如离开if分支，就是离开了if作用域。

  2.堆对象【手动调用】，执行delete操作时析构函数自动调用。

## 缺省析构函数

没有定义，操作系统送一个。

- 对基本数据成员，不做处理
- 对类对象成员，调用类的对应析构函数

```cpp
#include <iostream>
using namespace std;
class B{
public:
	B(){
		cout << "class B constructor(void)" << endl;
	}
	~B(){
		cout << "free B" << endl;
	}
};
class A{
private:
	int m_data;
	B b1;
public:
	A(){
		m_data = 1;
		cout << "class A constructor(void)" << endl;
	}
	~A(){
		cout << "free A" << endl;
	}
};
int main(int argc, char *argv[]){
	A a1;
	return 0;
}
//执行结果
class B constructor(void)
class A constructor(void)
free A
free B
```

## 对象创建和销毁顺序

对象创建：

- 分配内存
- 构造成员子对象
- 调用构造函数

对象销毁：

- 调用析构函数
- 析构成员对象
- 释放内存

# 智能指针

https://blog.csdn.net/qq_56896418/article/details/141301814

使用智能指针，主要是为了防止内存泄漏。特别是对应大型工程，难免会有遗漏`new`完之后忘记`delete`的地方，从而造成内存泄漏。

在现代C++编程中，智能指针是管理动态内存和资源的关键工具。<memory>头文件提供了几种智能指针，包括`std::unique_ptr`、`std::shared_ptr` 和 `std::weak_ptr`。每种智能指针有其独特的用途和特点。

## `unique_ptr`

`std::unique_ptr`是一种独享的智能指针（**一个指针只能指向一段内存**），它负责管理一个动态分配的对象的生命周期，并保证在 `std::unique_ptr`被销毁时，所管理的对象会被正确释放。`std::unique_ptr`不能被复制，但可以被移动。

### 创建智能指针

```cpp
//C++11: 
std::unique_ptr<Task> taskPtr(new Task(23));
//C++14: 
std::unique_ptr<Task> taskPtr = std::make_unique<Task>(34);
```

### 不能复制

`unique_ptr`不能直接复制，必须使用`std::move()`转移其管理的指针，转移后原unique_ptr为空。`std::unique_ptr<Task> taskPtr4 = std::move(taskPtr2);`

### 成员函数

| 成员函数  | 作用                                                         |
| --------- | ------------------------------------------------------------ |
| reset(q)  | 令智能指针p中存放指针q，即p指向q的空间，reset参数为空则重置unique_ptr为空，最后delete其原来关联的指针。 |
| release() | 仅仅只是释放关联指针的所有权，置unique_ptr为空，不delete关联指针，返回的是关联的普通指针。 |
| get()     | 获取普通指针，返回的是关联的普通指针                         |

### 防止内存泄漏

- `unique_ptr`是C++ 11提供的用于防止内存泄漏的智能指针中的一种实现，是一个装指针的容器，且拥有关联指针的唯一所有权，独享被管理对象指针所有权的智能指针。`unique_ptr`对象包装一个普通指针，并负责其生命周期。当该智能指针对象被销毁时，会在其析构函数中删除关联的普通指针。
- `unique_ptr`具有`->`和`*`运算符重载符，因此它可以像普通指针一样使用。由上一节可知，如果是处于堆上，new生成的对象。需要我们去手动delete，一个是如果代码量多，忘记delete了，那么很容易造成内存泄漏，且也要时刻注意是否需要delete语句很麻烦，所以引入unique_ptr指针，相当于自动delete。

```cpp
#include <iostream>
#include <memory>
struct Task {
    int mId;
    Task(int id ) :mId(id) {
        std::cout << "Task::Constructor" << std::endl;
    }
    ~Task() {
        std::cout << "Task::Destructor" << std::endl;
    }
};
int main()
{
    //利用普通指针创建unique_ptr实例
    std::unique_ptr<Task> taskPtr(new Task(23));
    //通过 unique_ptr 访问其成员
    int id = taskPtr->mId;
    std::cout << id << std::endl;
    return 0;
}

输出：
Task::Constructor
23
Task::Destructor
```

`unique_ptr<Task>`对象 `taskPtr`接受普通指针作为参数。现在当main函数退出时，该对象作为栈中的变量因超出作用范围就会调用其析构函数，在`unique_ptr`对象`taskPtr `的析构函数中，会删除关联的普通指针，这样就不用专门delete Task对象了。这样不管函数正常退出还是异常退出（由于某些异常），也会始终调用`taskPtr`的析构函数。因此，原始指针将始终被删除并防止内存泄漏。

## `shared_ptr`

`std::shared_ptr `是一种共享的智能指针，它允许多个` std::shared_ptr `实例共享对同一个动态分配对象的所有权。对象的生命周期由引用计数控制，当最后一个 `std::shared_ptr `被销毁时，对象才会被释放。

```cpp
#include <iostream>
class Ball {
public:
    Ball();
    ~Ball();
    void bounce();
};
Ball::Ball() {
    std::cout << "Ball init" << std::endl;
}

Ball::~Ball() {
    std::cout << "Ball destroy" << std::endl;
}

void Ball::bounce() {
    std::cout << "Ball bounce" << std::endl;
}
#include <iostream>
#include "Ball.h"
using namespace std;
#include <memory>
int main() {
    shared_ptr<Ball> ball1 = make_shared<Ball>();
    cout << "ball1 use count: " << ball1.use_count() << endl;
    shared_ptr<Ball> ball2 = ball1;
    cout << "ball1 use count: " << ball1.use_count() <<" ball2 use count: " << ball2.use_count() << endl;
    shared_ptr<Ball> ball3 = ball1;
    cout << "ball1 use count: " << ball1.use_count() <<" ball2 use count: " << ball2.use_count() <<" ball3 use count: " << ball3.use_count() << endl;
    ball1.reset();
    cout << "ball1 use count: " << ball1.use_count() <<" ball2 use count: " << ball2.use_count() <<" ball3 use count: " << ball3.use_count() << endl;
    ball2.reset();
    cout << "ball1 use count: " << ball1.use_count() <<" ball2 use count: " << ball2.use_count() <<" ball3 use count: " << ball3.use_count() << endl;
    ball3.reset();
    cout << "ball1 use count: " << ball1.use_count() <<" ball2 use count: " << ball2.use_count() <<" ball3 use count: " << ball3.use_count() << endl;
    return 0;
}
```

结果：

```bash
Ball init
ball1 use count: 1
ball1 use count: 2 ball2 use count: 2
ball1 use count: 3 ball2 use count: 3 ball3 use count: 3
ball1 use count: 0 ball2 use count: 2 ball3 use count: 2
ball1 use count: 0 ball2 use count: 0 ball3 use count: 1
Ball destroy
ball1 use count: 0 ball2 use count: 0 ball3 use count: 0
```

------

# 静态成员

## 定义

可以直接理解为**局限在类中的全局变量**，即为该类类型的任意对象均可以共享访问。类在实例化时，只有非静态成员变量才会有对应的内存空间，故即使没声明类对象，也能访问类的静态成员。

**类的静态成员(变量和方法)属于类本身，在类加载的时候就会分配内存，可以通过类名直接去访问；**

**非静态成员（变量和方法）属于类的对象，所以只有在类的对象产生（创建类的实例）时才会分配内存，然后通过类的对象（实例）去访问。**

## 静态成员变量

### 初始化

```c++
class 类名{
    static 数据类型 变量名;//声明
};
数据类型 类名::变量名 = 初值;//只能在类外面进行初始化
```

### 访问方式

- 类名::静态成员变量；

  ```c++
  cout << A::data << endl;
  ```

- 对象.静态成员变量；

  ```
  A a1;
  cout << a1.data << endl;
  ```

## 静态成员函数

- 静态成员函数可以在类的内部也可以在外部定义，定义和普通成员函数没啥区别。
- 静态成员函数**没有this指针，没有const属性**，可以把静态成员函数理解为限制在类中使用的全局函数。
- 静态成员函数只能访问静态成员，**因为没有this指针，所以访问不了非静态成员变量**，但是在非静态成员函数中既可以访问静态成员，也可以访问非静态成员。
- 静态成员函数也要受到类的private，public访问控制限定符一样的约束。
- 在类外访问时，访问方式同静态成员变量一样。

```c++
#include <iostream>
using namespace std;
class A{
public:
	int data;
	A(){
		cout << "constructor (void)" << endl;
	}
	static void print(){
		cout << "static fun" << endl;
		data = 1;//error: invalid use of member ‘A::data’ in static member function
	}
};
int main(int argc, char *argv[]){
	A::print();//static fun
	A a1;//constructor (void)
	a1.print();//static fun
	return 0;
}
```

------

# 友元

类的封装具有信息隐藏能力，但也带来了访问效率问题。

C++通过友元给某些函数一项特权，可以避免利用成员函数而直接访问类中的私有成员从而提高效率，使用的关键字是friend。

## 友元函数

专指类外的定义的其他的，不属于类成员的函数。

```c++
#include <iostream>
using namespace std;
class A{
private:
	static int m_data;
public:
	//friend void print();
    //In function ‘void print()’:error: ‘int A::m_data’ is private within this context
};
int A::m_data = 1;
void print(){
	cout << A::m_data << endl; 
}
int main(int argc, char *argv[]){
	print();
}

```

## 友元类

一个类是另外一个类的友元时，该类的所有函数也是另外一个类的友元函数。

> [!IMPORTANT]
> 友元类是单向的不是双向的。

```c++
#include <iostream>
using namespace std;
class B{
private:
	int m_data;
public:
	B(){
		m_data = 2;
	}
	//friend class A;
    //In member function ‘void A::print(const B&)’,error: ‘int B::m_data’ is private within this context
};
class A{
private:
	int m_data;
public:
	A(){
		m_data = 1;
	}
	void print(const B &that){
		cout << that.m_data << endl;
	}
};
int main(int argc, char *argv[]){
	B b1;
	A a1;
	a1.print(b1);
}
```

## 友元成员函数

专指类中的成员函数。

错误示例：

```c++
#include <iostream>
using namespace std;
class A;//1.先声明class A,编译器就去检查创建A类的代码
class B{
private:
	int m_data;
public:
	B(){
		m_data = 2;
	}
  	friend void A::print(const B &that);//3.报错，说A类是不完整的
};
class A{
private:
	int m_data;
public:
	A(){
		m_data = 1;
	}
	void print(const B &that);
};
void A::print(const B &that){
	cout << that.m_data << endl;//2.不能直接访问B.data，因为只知道A的声明，不知道具体定义是啥，编译器怎么知道B有无data成员，故此处报错。
}
int main(int argc, char *argv[]){
//	B b1;
//	A a1;
//	a1.print(b1);
}
可以声明一个类而不定义它
   class Screen;//declaration of the Screen class
   这个声明,有时候被称为前向声明(forward declaration),在程序中引入了类类型的Screen.在声明之后,定义之前,类Screen是一个不完全类型(incompete type),即已知Screen是一个类型,但不知道包含哪些成员.
   不完全类型只能以有限方式使用,不能定义该类型的对象,不完全类型只能用于定义指向该类型的指针及引用,或者用于声明(而不是定义)使用该类型作为形参类型或返回类型的函数.
```

修正

```c++
#include <iostream>

using namespace std;
class B;
class A{
private:
	int m_data;
public:
	A(){
		m_data = 1;
	}
	void print(const B &that);//虽然B是incompete type,但这里只用了引用，并未试图定义对象或者访问成员。
};
class B{
private:
	int m_data;
public:
	B(){
		m_data = 2;
	}
  	friend void A::print(const B &that);//类A在此次只是作为作用域，并未尝试去访问其成员，因此只要知道有一个类
    //是A，不必知道其具体成员内容也可以。
};
void A::print(const B &that){
	cout << that.m_data << endl;
}
int main(int argc, char *argv[]){
//	B b1;
//	A a1;
//	a1.print(b1);
}
```

------

# 单例模式

- 单例模式,也称为单件模式，意图是保证一个类仅有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。

- 面向对象编程中，每个对象都应该抽象代表一个设备，并通过对象完成对设备的管理和维护。

- 有些情况下只允许一个类实例化一个对象很重要，如打印机管理，设备管理器，任务管理器，或者某一个由指定配置配置好的网络连接等。


## 一般实现方法

1. 私有化构造函数、拷贝构造函数。防止外界再创建对象时构造。
2. 使用静态成员变量维护单一的单例对象，即相当于在private里面声明一个该类单的对象，且是static的。
3. 定义public权限的静态成员函数用于获取单例对象（让外界能够获取操作实例对象）。

## 饿汉式实现（栈区）

饿汉式的对象在类产生的时候就创建了，一直到程序结束才释放。即对象的生存周期和程序一样长，因此该实例对象需要存储在内存的全局数据区，故使用[static](https://so.csdn.net/so/search?q=static&spm=1001.2101.3001.7020)修饰。

```c++
#include <iostream>
using namespace std;
class A{
private:
	int m_data;
	A(int arg = 10){
		m_data = arg;
	}
	A(const A& that){}//拷贝构造也能创建对象，故拷贝构造也要改
	static A m_instance;
public:
	static A& getInstance(){
		return m_instance;
	}
	void print(){
		cout << m_data << endl;
	}
};
A A::m_instance = 123;//调用类型转换构造函数，由于是饿汉模式，所以在main函数调用之前就构造好了。
int main(int argc, char *argv[]){
	A &a1 = A::getInstance();
	A &a2 = A::getInstance();
	A &a3 = A::getInstance();
	A a4 = 2;//error: ‘A::A(int)’ is private within this context
	a1.print();
	a2.print();
	a3.print();
	cout << &a1 << endl;
	cout << &a2 << endl;
	cout << &a3 << endl;
}
```

## 懒汉式实现（堆区）

是在第一次调用`getInstance()`的时候，才创建实例对象。直接把对象定义为static，然后放在`getInstance()`中。第一次进入该函数，就创建实例对象，然后一直到程序结束，释放该对象。
用时再new创建，当引用计数为0时再delete删除，但很麻烦，还要护引用计数，因此可以使用`share_ptr`智能指针。

```cpp
// 懒汉式单例的实现
#ifndef C_SINGLETON_H
#define C_SINGLETON_H
 
#include<iostream>
#include<memory>
using namespace std;
class CSingleton
{
private:
    CSingleton(){ cout << "单例对象创建！" << endl; };
    CSingleton(const CSingleton &);
    CSingleton& operator=(const CSingleton &);
    ~CSingleton(){ cout << "单例对象销毁！" << endl; };
 
    static CSingleton *myInstance;
 
 
public:
    static CSingleton * getInstance()
    {    
        if (nullptr == myInstance)
        {
            myInstance = new CSingleton();
        }
        return myInstance;
    }
 
private:
    // 定义一个内部类
    class CGarbo{
    public:
        CGarbo(){};
        ~CGarbo()
        {
            if (nullptr != myInstance)
            {
                delete myInstance;
                myInstance = nullptr;
            }
        }
    };
    // 定义一个内部类的静态对象
    // 当该对象销毁时，顺带就释放myInstance指向的堆区资源
    static CGarbo m_garbo;
};
 
#endif
```

## 线程安全问题

对于懒汉式这两种情况，当调用`getInstance()`函数时，如果对象还没产生（第一种状态），就需要产生对象，然后[返回对象](https://marketing.csdn.net/p/3127db09a98e0723b83b2914d9256174?pId=2782&utm_source=glcblog&spm=1001.2101.3001.7020)指针。如果对象已经存在了（第二种状态），就直接返回对象指针。当单线程时，没有问题。但是，**多线程情况下，如果一个函数中不同状态有不同操作，就要考虑线程互斥的问题了**。因此，我们需要修改一下`getInstance`中的实现。

------

# ——继承——

# 继承

## 定义

继承，基于一个已有类创建新类，使类与已有类具有同样的功能，即新类具有已有类相同的数据成员和成员函数。继承是代码重用的基本工具。已有类称为基类（父类/超类），新类称为派生类（子类）。继承可以看成申请新的空间并复制基类中被继承的成员，继承与否主要看子类是否为其分配了内存空间，并不是看是否能访问，有些成员虽然不能被继承，但仍可以被子类访问。

- 基类的<u>**构造函数和析构函数**</u>不能继承
  尽管派生类不直接继承基类的构造和析构函数，有自己的构造和析构函数，但是派生类的构造函数一定会调用基类的某一个构造函数，析构函数也是一样。
- 基类的<u>友元函数</u>不能继承
- <u>静态数据成员和静态成员函数</u>不能继承
  即不会在子类中为其生成内存空间来拷贝一份，因为静态数据成员和静态成员函数在类实例中本身就不会生成内存空间存储，但仍然可以访问。

```c++
#include <iostream>
using namespace std;
void Friend_fun(const Derived &a);
class Base{
public:
	int a;
	static int b;
	friend void Friend_fun(const Derived &a);
	Base(int arg){
		cout << "Base(int)" << endl;
		a = arg;
	}
	void print(){
		cout << "Base::a ==" << a << endl;
		cout << "Base::b ==" << b << endl;
	}
	static void fun(){
		cout << "static void fun" << endl;
	}
	~Base(){
		cout << "~Base" << endl;
	}

};
int Base::b = 100;
class Derived:public Base{
	public:
		Derived():Base(10){//初始化列表
			Base::Base(10);//error:cannot call constructor ‘Base::Base’ directly
			print();//继承了，可以直接调用
			cout << "Derived" << endl;
		}
		~Derived(){
			cout << "~Derived" << endl;
		}
};
void Friend_fun(const Derived &a){
	cout << a.a << endl;
    cout << a.b >> endl;
	cout << a.c << endl;//error:int Derived::c’ is private within this context
}
int main(int argc, char *argv[]){
	Derived a;
    cout << sizeof(a) << endl;//8
	//a.print();
	//Friend_fun();	
}
//执行结果：
Base(int)
Base::a ==10
Base::b ==100
Derived
~Derived
~Base
```

## 继承的方式

### 语法格式

```c++
class 派生类名:继承方式 基类名{
    成员声明和定义
};
```

### 继承方式

- **公有继承**
  继承方式为public的继承称为公有继承，在这种继承中，基类成员的访问权限在派生类中保持不变。

  基类不能访问父类的私有成员。

  ```c++
  #include <iostream>
  
  using namespace std;
  
  void Friend_fun();
  class Derived;
  class Base{
  private:
  	int a;
  protected:
  	int b;
  public:
  	int c;
  	Base(){
  		cout << "Base(void)" << endl;
  		a = 1;
  		b = 2;
  		c = 3;
  	}
  	void print(){
  		cout << a << " " << " " << b << " " << c << endl;
  	}
  	~Base(){
  		cout << "~Base(void)" << endl;
  	}
  };
  class Derived:public Base{
  private:
  	int d;
  public:
  	Derived(){
  		cout << "Derived(void)" << endl;
  	}
  	void print(){
  		cout << a << endl;//error: ‘int Base::a’ is private within this context
  		cout << b << endl;
  		cout << c << endl;
  	}
  	~Derived(){
  		cout << "~Derivedi(void)" << endl;
  	}
  };
  int main(void){
      Derived test;
      cout << test.a << endl; // error: ‘int Base::a’ is private within this context
      cout << test.b << endl; //error: ‘int Base::b’ is protected within this context
      cout << test.c << endl; //正确
      cout << test.d << endl; //error: ‘int Derived::d’ is private within this context
  }
  ```

- **保护继承**
  基类公有成员到了派生类里变成保护成员，其他权限不变。

- **私有继承**
  基类所有的成员到子类中全变成私有。

------

# 基类与派生类的关系

子类对象会继承基类的属性行为，任何时候子类对象都可以被当做基类类型对象，通过子类对象可以直接访问基类成员，如同基类对象在访问它们一样。

## 造型

**向上造型：**将子类类型的指针或者引用转换为基类类型的指针或者引用；这种操作性缩小的类型转换，在编译器看来是安全的，可以隐式转换

**向下造型：**将基类类型的指针或者引用转换为子类类型的指针或者引用；这种操作性放大的类型转换，在编译器看来是危险的，不能隐式转换，但可以显示转换即利用强转。

```c++
#include <iostream>
using namespace std;
class Human{
public:
	int age;
	string name;
	Human(const string &name,int age){
		this->age = age;
		this->name = name;
	}
	void eat(const string &food){
		cout << "我正在吃" << food << endl;
	}
	void sleep(int hour){
		cout <<"我每天睡" << hour << "小时" << endl; 
	}
};
class student:public Human{

public:
	int sno;
	student(int sno,const string &name,int age):Human(name,age){
		this->sno = sno;
	}
	void who(){
		cout << "我是" << name << "," << "今年" << age << "岁" << "我的学号是:" << sno << endl; 
	}
	void learn(const string &course){
		cout << "我正在学习" << course << endl;
	}
};
class teacher:public Human{
private:
	int sno;
	int salary;
public:
	teacher(int sno,int salary,const string &name,int age):Human(name,age){
		this->sno = sno;
		this->salary = salary;
	}
	void teach(const string &course){
		cout << "我正在教" << course << endl;
	}
	void who(){
		cout << "我是" << name << "," << "今年" << age << "岁" << "我的工号是:" << sno << endl; 
	}
};
int main(int argc, char *argv[]){
	student s1(1001,"Tom",23);
	s1.who();
	s1.eat("宫保鸡丁");
	s1.learn("C++");
	s1.sleep(8);
	cout << "==========" << endl;
	Human* p;
	p = &s1;//向上造型（合理），可以隐式转换
	p->eat("宫保鸡丁");
	s1.sleep(8);
	p->who();//error: ‘class Human’ has no member named ‘who’
	cout << "==========" << endl;
	student *ps = static_cast<student*>(p);//向下造型(合理)
	ps->eat("宫保鸡丁");
	ps->sleep(8);
	ps->who();
	cout << "==========" << endl;
	Human h("刘备",26);
	student *s = static_cast<student*>(&h);//向下造型(不合理由),因为human里没有sno，故新建一个human对象再造型，sno值不确定
	s->eat("宫保鸡丁");
	s->sleep(8);
	s->who();
	return 0;
}
```

## 成员函数重定义(名字隐藏)

### 重定义

简单说就是子类中定义了同父类**中同名**的函数，对父类的成员函数造成了隐藏，即子类对象调用该同名函数时调用的是子类的，而不是父类的，好像父类的被藏起来了一样。**父类和子类的同名函数无论如何都不构成重载关系，因为子类父类可以看成是两个作用域。**

### 解决方法

默认调用的是派生类的成员函数，如要调用基类的成员函数，则要加作用域限定符，指明作用域来访问父类。

## 派生类的构造与析构

### 构造

- 如果子类构造函数没有显示指明基类部分（基类子对象）的初始化方法，那么编译器将会自动调用基类的无参构造函数初始化基类子对象。
- 如果希望以有参的方式初始化基类部分，那么必须使用初始化列表来显示指明
- 子对象构造顺序

​	1.分配内存

​	2.构造基类子对象（按继承表顺序）

​	3.构造成员子对象（按声明顺序）

​	4.执行子类构造函数代码。

### 析构

与构造相反。

```c++
#include <iostream>

using namespace std;

class Member{
private:
	int member;
public:
	Member(){
		cout << "Member(void)" << endl;
	}
	~Member(){
		cout << "~Member(void)" << endl;
	}
};
class Base{
private:
	int base;
public:
	Base(int arg){
		base = arg;
		cout << "Base(int)" << endl;
	}
	~Base(){
		cout << "~Base(int)" << endl;
	}
};
class Derived:public Base{
private:
	int derived;
	Member mm;
public:
	Derived():Base(100){
		cout << "Derived(void)"  << endl;
	}
	~Derived(){
		cout << "~Derived(void)"  << endl;
	}
};
int main(int argc, char *argv[]){
	Derived d1;
	return 0;
}
//执行结果
Base(int)
Member(void)
Derived(void)
~Derived(void)
~Member(void)
~Base(int)
```

------

# 多重继承

## 定义

C++允许一个类从一个或多个基类派生，如果一个类只要一个基类，称为单一继承。

如果一个类具有两个或两个以上的基类，就称为多重继承。

```c++
class 派生类名：继承方式 基类名1，继承方式 基类名2,.....{};
```

## 多重继承成员名字冲突

问题：多个基类里面有同名成员。

解决方法:调用使用时加作用域限定符，说明是哪个基类的成员。

## 钻石继承

### 定义

钻石继承，一个派生类继承的多个基类又源自一个公共的祖先（公共基类）

![image-20240709134210970](..\figure\image-20240709134210970.png)



### 存在问题

使得人的一些基本成员到助教中去就重复了，就有两个年龄，两个名字了。且调用学生的方法，就只改了学生继承过来的名字和年龄，教师继承过来的不变。

```c++
#include <iostream>
using namespace std;
class People{
private:
	string m_name;
	int m_age;
public:
	People(const string &name,int age){
		m_name = name;
		m_age = age;
	}
	void print(){
		cout << m_name << " " << m_age << " ";
	}
	void set(int age){
		m_age = age;
	}
};
class Teacher: public People{
private:
	int m_salary;
public:
	Teacher(int salary,const string &name,int age):People(name,age){
		m_salary = salary;
	}
	void print(){
		People::print();
		cout << m_salary << " " << endl; 
	}
	void set(int age){
		People::set(age);
	}
};
class Student:public People{
private:
	string m_level;
public:
	Student(const string &level,const string &name,int age):People(name,age){
		m_level = level;
	}
	void print(){
		People::print();
		cout << m_level << " " << endl; 
	}
	void set(int age){
		People::set(age);
	}
};
class Doctor:public Teacher,public Student{
public:
	Doctor(const string &name,int age,const string &level,int salary):Teacher(salary,name,age),Student(level,name,age){
	}
};
int main(int argc, char *argv[]){
	Doctor d1("张三",23,"研究生",1000);
	d1.Student::print();//23
	d1.Student::set(22);
	d1.Student::print();//22
	d1.Teacher::print();//23
	return 0;
}
张三 23 研究生 
张三 22 研究生 
张三 23 1000 
```

### 解决方法

虚继承

- 在继承表中使用virtual关键字修饰

  ```c++
  class Base {
  public:
      int baseValue;
  };
  
  class DerivedA : virtual public Base {
  public:
      int aValue;
  };
  
  class DerivedB : virtual public Base {
  public:
      int bValue;
  };
  
  class Final : public DerivedA, public DerivedB {
  public:
      int finalValue;
  };
   单一基类实例：使用虚继承后，  Base   类在   Final   类中只有一个实例，避免了成员访问冲突。2. 构造函数调用：虚基类的构造函数由最派生类（这里是   Final   类）直接调用，而不是由中间派生类（  DerivedA   和   DerivedB  ）调用。
  ```
- 位于继承链末端的子类负责构造公共基类子对象，利用初始化列表来构造

------

# 继承与组合

- 继承与组合是C++实现代码重要的两种主要方法。

- 继承是is-a的关系，比如水果和梨

- 组合是has-a的关系，即一个类有一个成员是另一类类的对象

------

# ————多态————

------

# 多态介绍

## 1.定义

多态通俗的讲，就是用一个相同的名字定义许多不同的函数，这些函数可以针对不同数据类型实现相同或相似的功能，即所谓的“一个接口，多种实现”。<!--【多态关系是在父类和子类之间的，不具有继承关系的两种类不能谈论多态】-->

## 2.虚函数

虚函数是实现多态的基础。被`virtual`关键字修饰的成员函数称为虚函数。如果将基类中的某个成员函数声明为虚函数，那么子类中与该函数具有相同原型的成员函数**也就是虚函数**，并且对基类中版本形成覆盖，即函数重写。

如果子类提供了对基类虚函数有效的覆盖，那么通过指向子类对象的基类指针，或者通过引用子类对象的基类引用，调用该虚函数，实际被执行的将是子类中的覆盖版本，而不再是基类中的原始版本，这种语法现象被称为**多态**。

多态的意义在于，一般情况下，调用哪个类的成员函数由调用者指针或者引用本身类型决定的，而有了多态，调用哪个类的成员函数由调用者指针或者引用的实际目标对象的类型决定。

这样一来，源自同一种类型的同一种激励，竟然可以产生多种不同的响应，也就是对于同一个函数调用，能够表达出不同的形态，即为多态。

## 虚函数覆盖条件

只有基类的函数被覆盖了，后面基类指针所调用的函数才能是子类的函数，才能形成多态。

- 只有类的成员函数才能声明为虚函数，而全局函数，静态成员函数，构造函数都不能被声明为虚函数，析构函数可以为虚函数
- 只有在**基类中以virtual关键字声明**的虚函数，才能作为虚函数被子类覆盖，而与子类有没有加virtual关键字无关
- 虚函数在子类中的版本和基类中版本要具有相同的函数签名，即**函数名，参数表，常属性**一致。
- 如果基类虚函数返回基本类型数据，那么子类中的版本必须返回相同类型数据；
- 如果基类虚函数返回类类型指针(A\*)或引用(A&)，那稍微放宽点，允许子类中的版本返回**子类类型**的指针或引用(B\*)(B&)。

```c++
#include <iostream>
using namespace std;
class Base{
public:
    virtual Base(){
        cout << "Base(void)" << endl;		//error: constructors cannot be declared ‘virtual’

    }
	virtual static void func1(){			 //error: member ‘func1’ cannot be declared both ‘virtual’ and ‘static’		
		cout << "static fun1" << endl;
	}
	void fun(){                               //在void前面加virtual后执行结果为：
        									  //A::fun  B::fun  C::fun
		cout << "Base::fun" << endl;
	}
};
class A:public Base{
public:
	void fun(){
		cout << "A::fun" << endl;
	}
};
class B:public Base{
public:
	void fun(){
		cout << "B::fun" << endl;
	}
};
class C:public Base{
public:
	void fun(){
		cout << "C::fun" << endl;
	}
};

int main(int argc, char *argv[]){
	Base* p[128];
	p[0] = new A;
	p[1] = new B;
	p[2] = new C;
    A a1;
	Base b1 = a1;				//向上造型，可以隐式转换。
	b1.fun();
	p[0]->fun();
	p[1]->fun();
	p[2]->fun();
	return 0;
}
```

执行结果：

```shell
Base::fun
Base::fun
Base::fun
Base::fun
```

## 覆盖与隐藏的区别

### 覆盖（Overriding）

覆盖发生在子类和父类有相同名称、相同参数列表（包括参数类型、顺序和数量）的虚函数（virtual function）之间。当子类定义了这样一个与父类同名的虚函数时，我们说子类覆盖了父类的虚函数。在**运行时**，通过基类指针或引用调用该虚函数时，会根据对象的实际类型（即对象的动态类型）来调用相应的函数版本，这被称为多态。

**特点**：

- 发生在虚函数之间。
- **函数名、参数列表必须完全相同。**
- 调用哪个函数**取决于对象的**实际类型（**运行时绑定**）。
- 允许子类改变父类虚函数的行为。

### 隐藏（Hiding）

隐藏发生在子类和父类有相同名称的函数之间，但参数列表不同，或者父类函数不是虚函数而子类定义了同名的函数（无论参数列表是否相同）。在这种情况下，子类函数隐藏了父类中的同名函数，而不是覆盖它。当通过基类指针或引用调用该函数时，如果调用的是被隐藏的函数，则始终调用基类中的版本，除非使用子类对象直接调用。

**特点**：

- 不限于虚函数，可以发生在**任何同名函数**之间。
- 参数列表可以不同。
- 调用哪个函数**取决于指针或引用的类型**（**编译时绑定**）。
- 不是多态的一种形式，因为它不依赖于对象的实际类型。

## 产生多态的条件

- 除了要满足函数重写的语法要求，还必须通过指针或引用调用虚函数才能表现出来。<!--【注意不能利用变量执行“变量名.函数名”的语句来调用，否则不会表现出多态性】-->
- 调用虚函数的指针也可以是this指针，当使用子类对象调用基类中的成员函数时，该函数里面的this指针将是一个基类指针类型的，且指向的是子类对象的地址，再通过this去调用满足重写要求的虚函数同样可以表现多态的语法特性。

# 虚函数实现技术

每一个含有虚函数（无论是其自身函数继承来的）的类都至少有一个与之对应的虚函数表，其中存放着该类所有的虚函数的函数指针。占4字节。

![image-20240709154659060](..\figure\image-20240709154659060.png)

当编译器编译以下test函数时只知道pb是B*类型的指针，并不知道它指向的具体对象类型，pd可能指向的是B的对象，也可能是D的对象。只有当程序执行过程中给test函数传递了具体参数才能确定 pb 指向了哪个对象，从而确定访问哪个虚表，从而实现多态。

![image-20240709155142632](..\figure\image-20240709155142632.png)

# 纯虚函数

------

如果一个虚函数只声明不定义，称为纯虚函数或抽象方法。

## 语法格式

```c++
class 类名{
    public:
    	virtual 返回类型 函数名（形参表） = 0；
};
```

假设有图形类Figure,设计计算面积成员函数area(),Figure只是一个纯抽象意义上的概念，由于图形多种多样，不存在计算面积或体积的**具体方法**，所有只能将成员函数area()设计为纯虚函数。

## 抽象类

如果类中包含了纯虚函数，那么这个类就是抽象类，抽象类只能作为其他类的基类，不能用来建立对象，因为你成员方法都没定义，建立对象也用不了。如果类中所有成员函数都是纯虚函数则可以称为纯抽象类。

## 总结

- 成员函数重载发生在同一个作用域内，函数名相同但参数列表（参数的数量、类型或顺序）不同的多个函数。
- 覆盖（也称为重写）发生在有继承关系的两个类中，子类有一个和父类签名完全相同的成员函数（返回类型、函数名和参数列表都必须相同）。需要注意的是，基类的成员函数必须为虚函数（使用 `virtual` 关键字）。

- 隐藏发生在有继承关系的两个类中，子类有一个和父类名称相同的成员函数，但是参数列表不同，此时子类版本的函数隐藏了所有同名的父类函数，无论父类中的函数参数列表是否相同。

# 虚析构函数

## 1.问题引出

```c++
#include <iostream>
using namespace std;
class Base{
public:
	Base(){
		cout << "Base(void)" << endl;
	}
	static void func1(){
		cout << "static fun1" << endl;
	}
	virtual void fun(){
		cout << "Base::fun" << endl;
	}
	~Base(){
		cout << "free Base" << endl;
	}
};
class Derived:public Base{
public:
	Derived(){
		cout << "Derived(void)" << endl;
	}
	void fun(){
		cout << "A::fun" << endl;
	}
	~Derived(){
		cout << "free Derived" << endl;
	}
};
int main(int argc, char *argv[]){
	Base* p;
	p = new Derived;
	p->fun();
	delete p;
	return 0;
}
```

```shell
Base(void)
Derived(void)
A::fun
free Base
#问题在于明明调用了两个构造函数，却只调用了Base的析构函数而没调用子类的析构函数从而造成内存泄漏
```

## 2.问题解决

在Base类的析构函数前加virtual。这样基类的虚函数就会被绑定到虚函数表中，那么就会得到调用。如果基类析构函数没加virtual关键字，那么子类的虚表中不会出现基类析构函数，子类的其他内存位置（要手动调用的地方）存的函数更不可能有基类的析构函数。

------



# 运行时类型信息

类似于Python中的type()函数

## `typeid`操作符`typeinfo`类类型

- `typeid`操作符既可用于类型也可用于对象，返回`type_info`类的对象的常引用，用于表示类型信息。

- `typeinfo`类的成员函数name(),可以获取**字符串形式**的类型信息，即类对象或者变量的数据类型**名字。**

  ```c++
  #include <iostream>
  #include <typeinfo>
  using namespace std;
  class Base{};
  class A{};
  int main(int argc, char *argv[]){
      if(typeid(a) == typeid(b)){
          cout << typeid(int).name() << endl;
          cout << typeid(float).name() << endl;
          cout << typeid(string).name() << endl;
          cout << typeid(Base).name() << endl;
          cout << typeid(A).name() << endl;
      }
  	return 0;
  }
  
  i
  f
  NSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE
  4Base
  1A
  ```

- `typeinfo`类支持“==”和“！=”操作符，可以直接用于判断类型是否相同，如果类型之间存在**多态**的继承关系，`typeid`还可以利用多态的特性确定实际对象的类型。

  ```c++
  #include <iostream>
  #include <typeinfo>
  using namespace std;
  class Base{
  	public:
  		virtual void foo(){};
  };
  class A:public Base{
  	public:
  		void foo(){};
  };
  class B:public Base{
  	public:
  		void foo(){};
  };
  class C:public Base{
  	public:
  		void foo(){};
  };
  void fun(const Base& base){
  	//由于base具有多态性，但此函数不知道基类指针在程序运行时具体指向的是哪个子类的对象，故为了满足对不同子类对象执行不同逻辑的要求，需要判断base的类型，此时用到typeid
  	if(typeid(base) == typeid(A)){
  		cout << "base is A" << endl;
  	}
  	else if(typeid(base)==typeid(B))
  		cout << "base is B" << endl;
  	else if(typeid(base)==typeid(C))
  		cout << "base is C" << endl;
  	else
  		cout << "Unkonw type" << endl;
  }
  int main(int argc, char *argv[]){
  	A a;
  	B b;
  	C c;
  	fun(a);
  	fun(b);
  	fun(c);
  	return 0;
  }
  base is A
  base is B
  base is C
  ```

# ——运算符重载——

运算符重载关键在于设计运算符重载函数的**返回值**和**参数**。

# 双目运算符

## 什么是双目运算符

具有左右两个操作数的操作符L#R。

## 重载实现方式

- 成员函数形式：`L.operator#(R)`

- 友员函数形式:  `operator#(L,R)`


## 算术运算符重载

- +,-,*,/,%
- <u>表达式结果是右值。</u>
- 左右操作数既可以是左值也可以是右值。

## 赋值运算符重载

- =，+=，-=，*=
- <u>表达式结果是左值</u>，就是左操作数自身，为了支持x=y=100这样的链式操作。
- 左操作数必须是左值，右操作数可以是左值，也可以是右值。x=y，y=100。

# 单目运算符重载

~取反，-相反数，与或非，自增自减。

## 计算类单目运算符

- <u>表达式结果是右值 a = -a;</u>
- 操作数可以是左值也可以是右值 -a,-10

## 实现方式

- 成员函数形式：`O.operator#()`

- 友员函数形式:  `operator#(O)`


## 前缀自增减运算符

- <u>表达结果是左值，</u>而且结果返回自身，即自身内容要更新
- 操作数是左值

## 后缀自增减运算符

- <u>表达式结果是右值，</u>是操作数自增减前的副本
- 操作数必须是左值

## []运算符重载

- 表达式结果是左值，即要满足a[i]=x,x=a[i]这种操作，且结果是自身，不是自身的副本
- 操作数可以左值可以右值

```c++
#include <iostream>
#include <cstring>
using namespace std;

typedef char data_type;
class Work{
private:
	data_type *arry;
	int size;
public:
	Work(const char* str){
		this->size = strlen(str);
		arry = new data_type[size+1];
		strcpy(arry,str);
	}
	data_type &operator[](int index){
		if(index >= size){
			cout << "index out of range";
			return arry[size];
		}
		return arry[index];
	}
	~Work(){
		delete [] arry;
		arry = NULL;
	}
};
int main(int argc, char *argv[]){
	Work A("Hello");
	A[4] = 'A'; //[]的结果返回必须是返回引用，即a[4]该元素自身，如果不加引用，则函数系统调用返回的是a[4]的值是一个常量，给常量赋值，系统必报错。
	cout << "arry[4]:" << A[4] << endl;
	cout << "arry[5]:" << A[5] << endl;
	return 0;
}
```

# 特殊运算符重载

## 输入输出运算符重载

> [!CAUTION]
> 因为无法向标准库类添加成员函数，所以只能使用全局函数即友员形式

```c++
friend ostream& operator<<(ostream &os,const 类名& 对象名)
{
    os << "hello,world" << endl;
    return os;//cout << a << b << ....返回引用为了支持链式操作
}
friend istream& operator >> (istream &is，const 类名& 对象名)
{
    .....
    return is;
}
```

## `new delete`运算符重载

- 通过new创建类对象时，将首先调用该操作符函数分配内存（可重载），然后再调用该类的构造函数。

  ```c++
  void* operator new(size_t size){
  	return malloc(size);
  }
  ```

- 通过delete销毁类对象时，将首先调用该类的析构函数，然后再调用该操作符函数释放内存（可重载）

  ```c++
  void operator delete(void* p){
      free(p);
  }
  ```

# ——异常——

# 传统错误处理

## 通过函数返回值处理异常

- **优点**
  函数调用路径中栈对象得到正确析构，不存在内存泄漏。
- **缺点**
  错误流程处理复杂，代码臃肿。

## 通过远程跳转处理错误

`setjmp(env)`:拍快照，保存调用`setjmp`的当前函数的栈针，后续如果执行到出错，可以直接通过`longjmp`返回到此处，因为此次留了快照。直接调用`setjmp`的时候是直接返回0的，而通过`longjmp`间接调用返回的是设置的值。

```c++
longjmp(env,-1)
//跳转到设置env快照setjmp(env)处，并把setjmp(env)返回值设置为-1。
//相当于时光倒流会到setjmp，并直接返回-1，然后根据其返回值为-1得知出错并进行错误处理。
```

- **优点**
  代码逻辑简便，不需要进行辅助复杂的错误逻辑处理。
- **缺点**
  会造成内存泄漏，因为直接返回返回点，则栈中出错点到快照处中间这些调用都没被正确析构从而造成内存泄漏。

# C++异常处理

## 关键字

### try

```c++
//尝试执行{}中的代码，并检查是否会出错。
try{
    ...;
    ...;
    ...;
}
```

### throw

抛出异常，一抛出异常，函数直接结束，也不会执行返回值返回，包括递归调用时，每一层调用的函数均会直接结束(**走到函数的’}‘处**)，相当于后面的语句包括return直接被无视，且并不是只有出错的那次函数调用才直接结束函数，而是后续所有的被压入栈中的函数均直接执行到右花括号那里结束，且各种被压入栈中函数里的构造的对象也会被正确析构掉（因为虽然无视后面语句，但走到}这里算是执行完函数，函数弹出栈，局部变量被正常释放和析构），try函数也直接结束。

### catch

```c++
//处理异常。
catch {type arg}：
{
    ...;
    ...;
    ...;
}
```

## 处理流程

- **不抛出throw异常**
  ![image-20240715103604894](..\figure\image-20240715103604894.png)
- **抛出throw异常**
  ![image-20240715103625859](..\figure\image-20240715103625859.png)

> [!CAUTION]
> catch在进行数据异常类型匹配时，不会进行数据类型的默认转换，只有与异常类型**精确匹配**的catch块才会被执行。但在C++中，抛出的异常一般都是类类型的对象，为了增加代码可读性，可以加多个catch块，不同catch块捕获不同类型异常。

```c++
#include <iostream>
#include <cstdio>
using namespace std;
class A{
    A(){
        cout << "A(void)" << endl;
    }
    
    ~A(){
        cout << "A(~)" << endl;
    }
}；
double fun1(){
    A a1;
	FILE* fp = fopen("a.txt","r");
	if (fp == NULL)
		throw -1.0f;
	cout << "this is fun1" << endl;
	return 0.0;
}
double fun2(){
    A a2;
	fun1();
	cout << "this is fun2" << endl;
	return 0.0;
}
double fun3(){
    A a3;
	fun2();
	cout << "this is fun3" << endl;
	return 0.0;
}

int main(int argc, char *argv[]){
	try{
		fun3();
		cout << "this is try" << endl;
	}
	catch(float err){
		if(err == -1.0){
			cout << "open file failed" << endl;
			return -1;
		}
	}
	return 0;
}
```

```shell
A(void)
A(void)
A(void)
A(~)
A(~)
A(~)
open file failed


#注释掉throw语句后：
this is fun1
this is fun2
this is fun3
this is try
```

------

# 函数异常说明

> [!NOTE]
> C++17 已经抛弃

1. 当一个函数声明不带任何异常描述时，它可以抛出任何异常。

2. C++可以限制函数能够抛出的异常类型，限制方法在函数声明后面添加一个throw参数表，在其中指定函数可以抛出的异常类型。

   ```c++
   //函数fun被限定只允许抛出int和char类型的异常，当fun函数抛出其他类型异常时，程序将被异常终止,即程序直接崩溃。
   int fun(int,char) throw(int,char);
   ```

3. 如果函数不允许抛出任何异常，只需要指定throw限制表为不包括任何类型的空表。

   ```c++
   //c++ noexception 等价与throw();
   int fun(int,char) throw();
   ```

------

# 标准异常类

> [!TIP]
> 类的定义位置位于：`/usr/include/c++/版本号/exception`

解决会抛出成千上万种异常如何一一都catch的问题。从exception类派生异常处理类再利用多态：即一个catch函数可以捕获各种类型错误，不必为每一个类型错误都写一个catch、函数。

```c++
#include <iostream>
#include <cstdio>
using namespace std;
class FileError:public exception{
public:
	const char *what() const throw(){
		cout << "handle file error" << endl;
		return "FileError";
	}
};
class MemoryError:public exception{
public:
	const char *what() const throw(){
		cout << "handle memory error" << endl;
		return	"MemoryError";
	}
};
void func(void) throw(FileError,MemoryError){
	throw FileError();//匿名类对象
}
int main(int argc, char *argv[]){
	MemoryError A;
	try{
		func();
	}
	catch(FileError&ex){
			cout << "open file failed" << endl;
			return -1;
	}
	catch(MemoryError&ex){
			cout << "Memory err" << endl;
			return -1;
	}
    catch(exception &ex){
    	cout << ex.what() << endl;
        return -1;
    }
	return 0;
}
```

# ——文件与流——

# IO流库概览

C++建立了一个十分庞大的流类库来实现数据的输入输出操作。其中每个流类实现不同的功能，这些类通过继承组合在一起。

`ios`类是`istream`和`ostream`类的虚基类，用来提供对流进行格式化I/O操作和错误处理的成员函数。`streambuf`主要作为其他类的支持，定义了对缓冲区的通用操作，如设置缓冲区，读写缓冲区等操作。![image-20240924081743198](..\figure\image-20240924081743198.png)

![image-20240715202030977](..\figure\image-20240715202030977.png)

```c++
typedef basic_istream<char>  istream
typedef basic_ostream<char>  ostream
```

# 标准输入输出流对象

- **cout**
  ostream cout与标准输出设备关联
- **cin**
  istream cin与标准输入设备关联
- **cerr**
  ostream cerr与标准出错设备关联（非缓冲方式）
- **clog**
  ostream clog与标准出错设备关联（缓冲方式）

# `istream`类

## `<<`运算符

对输入运算符 `<<`进行了重载，实现了对c++那些基本的即系统内置的数据量的输入功能,但输入字符串时**<u>遇到空格结束</u>**

## 常用的成员函数

### 读取一个字符

```c++
//无参get函数，读取一个字符
int_type get();
//从输入流中读一个字符到ch里，包括空白符
basic_istream& get(char_type& ch);
```

### 读取一行

```c++
//读一行数据，读取count个字符，遇到到'\n'结束。实际只读cout-1个，最后一个自动加\0
basic_istream& getline(char_type* s,std::streamsize count);

//读一行数据，读取count个字符，直到行末或者遇到delim（不会存储）终止字符停止。不加delim默认是'\n'。可以读取带空格的字符串，实际只读cout-1个，最后一个自动加\0
basic_istream& getline(char_type* s,std::streamsize cout,char_type delim);
```

### 一次性读取count个字符

```c++
basic_istream& read(char_type* s,std::streamsize cout);
```

### 丢弃忽略字符

```c++
//从输入流中读取字符并丢弃
basic_istream& ignore(std::streamsize cout = 1,int_type delim = Traits::eof());
```

# `ostream`类

```c++
basic_ostream& write(const char_type* s,std::streamsize cout);
basic_ostream& put(char_type ch);
//可以玩链式操作
    cout << "hello";
	cout.put('w').put('o').put('r').put('l').put('d');
```

# 格式化控制

- 操纵符（本质就是一堆全局函数）

  ```c++
  #include <iostream>
  #include <sstream>
  using namespace std;
  int main()
  {
      cout << "The number 42 in octal:   " << oct << 42 << '\n'
           << "The number 42 in decimal: " << dec << 42 << '\n'
           << "The number 42 in hex:     " << hex << 42 << '\n';
      cout << setw(10) << << setfill('0') << 123 << endl;
  }
  //执行结果
  The number 42 in octal:   52
  The number 42 in decimal: 42
  The number 42 in hex:     2a
  0000000123//设置位宽为10，不够填0
  ```

- 成员函数

  ```c++
  cout.width(10);
  cout.fill('0');
  cout.setf(ios::hex);//格式化输出，16进制输出
  cout.setf(left);//左对齐
  cout << 123 << endl;
  ```

# string流(继承自`iostream`)

> [!TIP]
> 类似于C里的`sprint`和`sscanf`的效果。

```c++
ostringstream oss;
int i = 123;
float d = 56.78;
char s[] = "hello"
oss << i << ' ' << d << ' ' << s;//oss里存的就是123 56.78 hello，类似于sprintf
cout << oss.str() << endl;//输出的是123 56.78 hello

istringstream iss;
iss.str("100 1.24 world");
iss >> i >> d >> s;//类似于sscanf
```

# 文件流(继承自`iostream`)

## `ofstream`

```c++
int i = 123;
float d = 56.78;
char s[] = "hello"
ofstream ofs("a.txt");
ofs << i << ' '<< d << ' '<< s <<endl;
ofs.close();
```

## `ifstream`

> [!NOTE]
> 当读取内容与接收变量的类型一致时，一直读取直到遇到空白字符或者数据类型不匹配。

```c++
ifstream ofs("a.txt"); 
//a.txt 123 45.78 hello world,以空白字符为结束
int i2;
float d2;
string s2;//只输入hello
ofs >> i2 >> d2 >> s2;
ofs.close();
```

# ——泛型编程之模板——

# 模板的概念

模板（template）是C++实现代码重用机制的重要工具，是泛型技术（即与数据类型无关的通用程序设计技术）的基础。模板表示的是概念级的通用程序设计方法，它把算法和数据类型区分开来，能够设计出独立于具体数据类型的模板程序，模板程序能以数据类型为参数生成针对于该类型的实际程序代码。模板分为函数模板和类模板两类。

# 模板的意义

```c++
int Min(int a,int b){
    return a < b ? a : b;
}
float Min(float a,float b){
    return a < b ? a : b;
}
double Min(double a,double b){
    return a < b ? a : b;
}
char Min(char a,char b){
    return a < b ? a : b;
}
```

**痛点**：逻辑一样但仅仅是数据类型不一样，虽然有函数重载，但相同代码要写好多遍。

**解决：**C++的模板与制作冰糕的模具相似，是**生成函数或类**的模具。模板接受数据类型参数，并根据此类型创建相应的函数或类。

针对上面所有的Min()函数，只需要下面的函数模板就能够生成所有的Min函数.

```c++
template <typename T>
T Min(T a,T b){
    return a<b?a:b;
}
//编译器用调用模板函数时传入参数的具体的类型替换T，即可生成对应的函数，如用int替换T，就生成了int类型的Min函数
int main(){
    int m=9,n=3;
    double d1=1.8,d2=3.4;
    cout << Min(m,n) << endl;
    cout << Min(d1,d2) << endl;
}
```

> [!CAUTION]
> `template`和`typename`是用来定义模板的关键字。min模板不涉及任何具体的数据类型，而是用T代表任意数据类型，称为类型参数。
> min模板代表了求两个数值最小值的通用算法，它与具体数据类型无关，但能够生成计算各种数据类型的最小值的函数。
> 编译器的做法是用具体的类型替换模板中的类型参数T，生成具体类型的函数min（）。
> 从函数模板min()可以看出，C++模板提供了对**逻辑结构相同的数据对象通用行为**的定义方法，它把通用算法的实现和具体的数据类型区分开来。

------

# 模板的类别

## 函数模板

###  函数模板定义

```c++
template <typename T1,typename T2,...>
返回类型 函数名(参数列表){
    //多个形参可以是多种数据类型T1,T2,T3。。。
}
```

### 函数模板实例化

- 当编译器遇到关键字template和跟随其后的参数定义时，它只是简单地知道这个函数模板在后面地程序代码中可能会用到，相当于做了一个标记。除此之外，编译器并不会做额外工作。在这个阶段函数模板本身并不能使编译器产生任何代码，因为编译器此时并不知道函数模板要处理地具体数据类型，根本无法参数任何函数代码。

- 当编译器遇到程序中对函数模板的调用时，他才会根据调用语句中实参的具体类型，确定模板参数的数据类型，并用此类型替换函数模板的模板参数，生成能够处理该类型的函数代码，即模板函数。

### 模板参数

- **模板参数匹配问题**

  C++在实例化函数模板的过程中，只是简单地将模板参数的替换为实参的类型，并以此生成模板函数，不会进行参数类型的任何转换。

  ```c++
  template <typename T>
  T Min(T a,T b){
      return a<b?a:b;
  }
  int main(){
      int m=9,n=3;
      double d1=1.8,d2=3.4;
      cout << Min(m,d1) << endl;//error，no matching function Min(int,float);当编译器想生成两个形参类型不一样的函数时，发现只有形参类型一样的函数的定义，就直接报错了。
  }
  //解决方法：
  1.调用函数时对传入的参数进行强转。
  2.调用时用Min<double>(m,d1),直接把T指定为double。相当于写一个doblue Min(double a,double b)
  3.使用指定多个参数的模板：
      template <typename T1,typename T2>
  	T1 Min(T1 a,T2 b){
      //此函数涉及到的数据类型有1~2种，因为T1可以与T2一样，因此调用此参数时传入的实参的数据类型为1~2种的均不会报错。
      	return a < b ? a : b;
  	}
  //当编译器想生成两个形参类型不一样的函数时，发现有形参类型不一样的函数的定义，就不会报错了。
  //T1可以与T2一样，也可以不一样，因此此模板可以用于形参数据类型相同也可以不同的函数。
  ```

- **模板函数的形参表**
  函数模板中的参数或者返回值既可以是T类型形参，也可以是int这些确切的普通类型的参数。

### 函数模板的特化

#### 特化介绍

![image-20240715224919802](..\figure\image-20240715224919802.png)

```c++
template<>
返回类型 函数名<特化的数据类型>(参数表){

}
// 特化版本，针对const char*类型
template<>  
const char* Max<const char*>(const char* s1, const char* s2) {  
    return (strcmp(s1, s2) > 0) ? s1 : s2;  
}  
```

#### 特化步骤

1. 必须要先有一个基础的函数模板
2. 关键字template后面接一对空的尖括号<>
3. 函数名后跟一对尖括号，尖括号中指定需要特化的类型
4. 函数形参表: 必须要和模板函数的基础参数类型完全相同，如果不同编译器可能会报一些奇怪的错误。


## 非类型模板参数

### 非类型参数引入

模板让我们实现了同时可以创建不同数据类型的栈，但是不能实现不同数据个数的栈。这里就引入了非类型模板参数。

```c++
//N是非类型模板参数，在类中当做常量来使用
//只能是整型常量
template<class T,int N=20>
class Array//库中也有array，array读写全面检查，检查更细致，但一般还是用vector
{
public:
 
private:
	T _a[N];
};
```

### 非类型参数特点

- N是常量不能修改

- 模板不仅可以不定义类型，还可以定义常量

- 比宏更好，可以传一个常量过去，定义不同的对象，可以传不同的常量过去

  > [!CAUTION]
  >
  > - **浮点数、类对象以及字符串**是不允许作为非类型模板参数的。
  > - **非类型的模板参数必须在编译期就能确认结果**。

【参考链接】[【C++】模板进阶（非类型模板参数、类模板的特化和模板的分离编译）-CSDN博客](https://blog.csdn.net/m0_67821824/article/details/130067951)

## 类模板

### 类模板的定义

用类模板解决堆栈类成员函数的重写问题，类模板可以接受类型作为参数，设计出与具体类型无关的通用类。在设计类模板时，可以使其中的某些数据成员，成员函数的参数或返回值与具体类型无关。

```c++
template <typename T1,typename T2>
class 类名{
    ... ...
};
template <typename T1,int a>
class 类名{
    ... ...
};
```

### 类模板的实例化

类模板的实例化包括模板实例化和成员函数实例化。当用类模板定义对象时，将引起类模板的实例化。在实例化模板时，如果模板参数是类型参数，则必须为它指定具体的类型；如果模板参数是非类型参数，则**必须为它指定一个常量值。**

```c++
Stack<int,10> //会被编译器翻译成有具体类型的普通类一样
istack;//声明类对象
```

编译器实例化Stack的方法是：将Stack模板声明中的所有类型参数T替换为int，将所有的非类型参数MAXSIZE替换为10，这样就用Stack模板生成了一个int类型模板类。为了区别于普通类，暂且将该类记作Stack<int，10>,即在类模板名后面的一对<>中写上模板参数。但在实例化对象时，不会实例化成员函数，只有在成员函数被调用时才会生成成员函数真正的代码。

与普通类的对象一样，**类模板(stack(T,10))**的对象或者引用也可以作为函数的参数，只不过这类函数通常是模板函数，且其调用实参常常是该类模板的模板类对象。

```c++
template <typename T>
void display(stack<T,10> &s)
{
    ... ...;
}
```

### 类模板特化

如：设计一个通用数组类，它能够直接存取数组元素。并能够输出数组中的最小值。同样对于char*类型需要特化，如果不做特化，则直接比char*指针地址大小，不是比char*所指字符串内容。

#### 全特化

全特化即是将模板参数列表中所有的参数都确定化。

```c++
template<class T1, class T2>
class Data
{
public:
	Data() { cout << "Data<T1, T2>" << endl; }
private:
	T1 _d1;
	T2 _d2;
};
 
//类模板的特化 -- 全特化（写死了）
template<>
class Data<int, double>
{
public:
	Data() { cout << "Data<int, double>" << endl; }
};
```

#### 偏特化（半特化）

> [!CAUTION]
> 半特化 / 偏特化不是特化一半

**偏特化**：任何针对模版参数进一步进行条件限制设计的特化版本。
偏特化有以下两种表现方式：

- 部分特化 ：将模板参数类表中的一部分参数特化   
- 参数更进一步的限制 ：偏特化并不仅仅是指特化部分参数，而是针对模板参数更进一步的条件限制所设计出来的一个特化版本。

```c++
//1、将部分模板参数列表中的一部分参数特化
template<class T1, class T2>
class Data
{
public:
	Data() { cout << "Data<T1, T2>" << endl; }
};

template<>
class Data<int, double>
{
public:
	Data() { cout << "Data<int, double>" << endl; }
}
template<class T1>
class Data<T1, char>
{
public:
	Data() { cout << "Data<T1, char>" << endl; }
};
//2、偏特化并不仅仅是指特化部分参数，而是针对模板参数更进一步的条件限制所设计出来的一个特化版本
//只要T1 和 T2是指针就走这个 -- 针对指针特殊化处理
template<class T1, class T2>
class Data<T1*, T2*>
{
public:
	Data() { cout << "Data<T1*, T2*>" << endl; }
};
template<class T1, class T2>
class Data<T1&, T2&>
{
public:
	Data() { cout << "Data<T1&, T2&>" << endl; }
};
int main()
{
	Data<int, int> d1;    //Data<T1,T2>
	Data<int, double> d2; //Data<int, double>
 
	//只要第二个是char都会匹配：半特化/偏特化
	Data<int, char> d3;//Data<T1, char>
	Data<char, char> d4;//Data<T1, char>
 
	//只要是两个指针
	Data<int*, int*> d5;//Data<T1*, T2*>
	Data<int*, char*> d6;//Data<T1*, T2*>
	Data<int*, string*> d7;//Data<T1*, T2*>
	Data<int*, void*> d8;//Data<T1*, T2*>
    //void不是类型，但是void*是一个类型，void*是不能解引用不能++
	
    Data<int*, int> d9;//Data<T1,T2>
	Data<int&, char&> d10;//Data<T&,T&>
 
	return 0;
}
 
 
 
//也可以写成typename
//template <typename T1, typename T2>
//class Data <T1*, T2*>
//{
//public:
//	Data() { cout << "Data<T1*, T2*>" << endl; }
//
//private:
//	T1 _d1;
//	T2 _d2;
//};
//
//template <typename T1, typename T2>
//class Data <T1&, T2&>
//{
//public:
//	Data(const T1& d1 = T1(), const T2& d2 = T2())
//		: _d1(d1)
//		, _d2(d2)
//	{
//		cout << "Data<T1&, T2&>" << endl;
//	}
//
//private:
//	const T1& _d1;
//	const T2& _d2;
//};
//
//template <typename T1, typename T2>
//class Data <T1&, T2*>
//{
//public:
//	Data(const T1& d1 = T1())
//
//	{
//		cout << "Data<T1&, T2*>" << endl;
//	}
//};
//int main()
//{
//	Data<int, int> d1;
//	Data<int*, char*> d2;
//	Data<int*, int> d3;
//	Data<double, int> d4;
//
//	Data<int*, int*> d5;
//
//	Data<int&, char&> d6;
//	Data<int&, char*> d7;
//
//	return 0;
//}
//
```

**特化某个成员函数**

```c++
template <>
返回类型 类模板名<特化的数据类型>::特化成员函数名(参数表){
	... ...
}
template<>
char* Arr<char*>::Min(){
    char *tmp;
    tmp = arr[0];
    for(int i = 1;i < size;i++){
        if(strcmp(tmp,arr[i]) > 0)
            tmp = arr[i];
    }
    return tmp;
}
```

**特化整个类模板**

此外，为了某种数据类型特化整个类模板，整个类模板也要以template<>开头，形式如下：

```c++
template <>
class 类模板名<特化数据类型>{
};
```

------

# 模板分离编译

## 什么是分类编译

一个程序（项目）由若干个源文件共同实现，而每个源文件单独编译生成目标文件，最后将所有目标文件链接起来形成单一的可执行文件的过程称为分离编译模式。

## 模板分离编译

分离的话，模板实例化不出对应的函数，但是编译时可以通过的，因为声明中有模板的声明，最后符号表重定位的时候，找不到对应的函数模板调用的地址。![img](..\figure\38ffacd607550ba41739fbb4dc0109e6.png)

## 解决办法

- 将声明和定义放到一个文件 `"xxx.hpp" `里面或者`xxx.h`其实也是可以的。推荐使用这种。
- 模板定义的位置显式实例化。

------

# ——`STL`——

# `STL`介绍

## 概念

`STL`就是标准模板库，它提供了模板化的通用类和通用函数。`STL`的核心内容包括容器（数据结构），迭代器（访问元素的下标），算法（算法）三部分内容，容器和算法通过迭代器进行无缝连接，三者常常协调工作，为各种编程问题提供有效的解决方案，让程序员的精力放在开发的其他方面而不是花在自己构建数据结构和有关该数据结构的一些增删查改排序等基本函数方法。

## 三大组件

 三大组件的关系——容器和算法通过迭代器来进行无缝连接，**算法通过迭代器访问容器中的元素**

**实际上，所谓容器是存储数据的地方，而算法是操作，操作需要对数据进行，这时候需要迭代器来使这两个联系起来**

# 迭代器（iterator）

## 定义

- 通过迭代器可以指向容器中的元素，通过迭代器可以读写它指向的元素——因此它在某方面很像指针，它是一种广义指针，是一个可以完成类似指针操作的对象。
- 迭代器是一个接口，指向容器的数据，然后算法通过这个迭代器去实现对容器的操作，相当于一个容器和算法的粘合剂，不同的容器通常有着自己的迭代器，迭代器的类型是一个iterator的typedef类型，作用域为整个类。
- 迭代器是一个对象，常用于遍历容器，即在容器中实现“取得下一个元素”的操作。不管容器是否直接提供了访问其对象的方法，通过迭代器都能够访问该容器中的元素，一次访问一个元素。

## 分类

- **正向迭代器**

  ```c++
  //容器类名<T>::iterator  迭代器名
  list <int>::iterator iter;
  ```

- **常量正向迭代器**

  ```c++
  //容器类名<T>::const_iterator 迭代器名
  ```

- **反向迭代器**

  ```c++
  //容器类名<T>::reverse_iterator  迭代器名
  ```

- **常量反向迭代器**

  ```c++
  //容器类名<T>::const_reverse_iterator  迭代器名
  ```

## 迭代器主要操作

```c++
operator*                       //返回当前位置的元素值
operator++					  //将迭代器前进到下一个元素位置
operator--					  //将迭代器后退到前一个元素位置
operator== 或者!=				 //判断两个迭代器是否指向同一个位置
operator=					  //为迭代器赋值						
```

## begin和end迭代器

![image-20240716211956209](..\figure\image-20240716211956209.png)

# 容器（container）

## 容器概念

容器是用来存储其他对象的对象。容器是容器类的实例，而容器类使用类模板实现的，适用于各种数据类型。`STL`的容器被分为**顺序容器**，**关联容器**和**容器适配器**三类。

- 顺序容器常被称为序列容器，它是将相同类型对象的有限集按顺序组织在一起的容器，用来表示线性数据结构，C++提供的顺序类型容器有向量（vector），链表，双端队列；
  **元素位置取决于插入时机和位置**
- 关联容器是非线性容器，是非线性的树结构，二叉树结构，是用来根据键（key）进行快速存储，检索数据的容器。这类容器可以存储值的集合或键值对，C++中的关联容器主要包括集合，多重集合，映射，多重映射；
  **元素位置取决于特点的排序准则**
- 容器适配器主要指堆栈和队列，它们实际是受限制访问的顺序容器类型。

## 顺序容器

### vector

> [!NOTE]
> vector：实际就是一个动态数组，即可以进行插入删除，在此过程中，vector会动态调整所占用的内存空间。

#### vector简介

- vector是将元素置于一个动态数组中加以管理的容器
- vector可以随机存取（用[]操作符或at()方法）
- vector尾部增删元素很快，但在中部和头部就很慢。

#### vector默认构造

```c++
#include <vector> //类模板vector <T>在此头文件中定义
using namespace std; //类模板的作用域是std

//默认构造函数
vector<T> vecT;

vector<int> vecInt;
vector<float> vecFloat;
```

####     vector带参构造函数

- `vector(beg,end);`将[beg,end）区间中的元素拷贝给本身。（左闭右开）
- `vector(n,elem);`将n个元素拷贝给本身。
- `vector(onst vector& other);`拷贝构造函数

```c++
int arr[] = {1,2,3,4,5};
vector<int> v1(arr,arr+5);



//vector(size_type count,const T& value = T(),const Allocator& alloc = Allocator());
vector <string> words1(10,'hello');



//explicit vector( size_type count );
vector <int> arry(10);



//vector(const vector& other );
vector <string>  words2(words1)

    
    
//vector(std::initializer_list<T> init,const Allocator& alloc = Allocator());
vector<string> words3 {"the", "frogurt", "is", "also", "cursed"};
```

#### vector的赋值

```c++
//vector.assign(beg,end);//左闭右开
vector<int> vecIntA;
int iArray[] = {0,1,2,3,4};
vecIntA.assign(iArray,iArray);
```

## 关联式容器

`STL`关联式容器包括集合和映射两大类，集合包括set和multiset，映射包括map和multimap，它们通过关键字存储和查找元素。在每种关联容器中，关键字按顺序排列，容器遍历就可以顺序进行。

- `set`和`multiset`
  集合类`multiset`和`set`提供了控制数字（包括字符及串）集合的操作，集合中的数字称为关键字，不需要有另一个值与关键字相关联。`set`和`multiset`会根据特定的排序准则，自动将元素排序，两者提供的操作方法基本相同，只是multiset允许元素重复而set不允许重复。
  ![image-20240716182859635](..\figure\image-20240716182859635.png)

  ```c++
  #include <iostream>
  #include <set>
  using namespace std;
  int main(void){
  	int a1[] = {-1,-1,2,3,11,6,10,2,10,23,0};
  	set <int,greater<int> > set1(a1,a1+11);//greater表示从大到小的排序方式，默认是less从小到大
  	set1.insert(4);
  	set<int,greater<int> >::iterator it;
  	for(it=set1.begin();it != set1.end(); it++){
  		cout << *it << " ";
  	}
  	cout << endl;
  
  	string a2[] = {"赵云","张飞","关羽","马超","黄忠","张辽","刘备"};
  	multiset<string> set2(a2,a2+7);
  	multiset<string>::iterator it2;
  	set2.insert("赵云");
  	for(it2=set2.begin();it2 != set2.end(); it2++){
  		cout << *it2 << " ";
  	}
  	cout << endl;
  	return 0;
  }
  ```
  
  ```shell
  23 11 10 6 4 3 2 0 -1  #不可重复
  关羽 刘备 张辽 张飞 赵云 赵云 马超 黄忠 #可重复
  ```
  
- `map`和`multimap`
  `map`个`multimap`提供了操作<键，值>对的方法，他们存储一对对象，即键对象和值对象，键对象用于查找过程中的键，值是与键对应的附加数据。例如,若键为单词，对应的值是表示该单词在文档中出现此数的数字，这样map就成了统计单词在文本中出现次数的频数表；再如，若键为单词，值是单词出现的页号链表，用multimap实现这样的键值对象就是可以构造单词索引表。
  ![image-20240716193947144](..\figure\image-20240716193947144.png)
  **定义：**
  前面介绍的`set/multiset`集合操作的方法同样适用于`map/multimap`，包括集合的建立方法，成员函数，比较运算，排序规则和方法等，只需要将其中的set更改为map，将`multiset`更改为`multimap`即可。需要说明的只有insert函数和访问元素不同。
  **insert成员函数：**
  从形式上看，`map/multimap`集合的insert成员都具有相同的形式，但insert插入到map/multimap中的元素是<键，值>构成的一对数据，这对数据是一个不可分割的整体。
  **元素访问：**
  `map/multimap`类型的迭代器提供了两个数据成员：一个是first，用于访问键；一个是second用于访问值。此外map类型的映射可以用键作为数字下标，访问该键所对应的值，**但`multimap`类型的映射不允许用数字下标的方式访问其中的元素。**
  **注意：**
  1.利用数组下标访问map时，如果map中不存在访问的键，则会给map加上该键并赋值为0，其实数组下标用于访问是不准确的，应该是用于插入map的。
  2.利用迭代器访问时不会出现上述情况。

  ```c++
  #include <iostream>
  #include <map>
  using namespace std;
  
  int main(int argc, char *argv[]){
  	string name[] = {"Tom","Bob","Jack"};
  	double salary[] = {15000,14000,13000};
  	map <string,double> m1;
  	map <string,double>::iterator it;
      /******/
      /*插入*/
      /******/
  	for(int i = 0; i < 3;i++){
  		m1.insert(make_pair(name[i],salary[i]));
  		//要先构造键值对才能插入
  	}
      m1["Alice"] = 20000;
  	m1["Jon"] = 12000;
      /******/
  	/*访问*/
      /******/
  	for(it = m1.begin();it != m1.end();it++){
  		cout << it->first << ":" << it->second << endl;
  	}
  	return 0;
  }
  ```

  ```shell
  Alice:20000
  Bob:14000
  Jack:13000
  Jon:12000
  Tom:15000
  ```

# 算法（）

算法是用于模板技术实现的适用于于各种容器的通用程序。算法常常通过迭代器间接地操作容器元素，而且通常会返回**迭代器**作为算法运算的结果。

- **find和count算法**：
  find用于查找指定数据在某个区间中是否存在，该函数返回等于指定值的第一个元素位置，如果没有就返回最后元素位置；count用于统计某个值在指定区间出现的次数，其用法如下：

  ```c++
  find(beg,end,value);
  count(beg,end,value);
  ```

- **serch算法**：
  find算法从一个容器中查找指定的值，search算法则是从一个容器查找由另一个容器所指定的顺序值。

  ```c++
  search(beg1,end1,beg2,end2)//左闭右开
  ```

  serach将在[beg1,ebd1]区间查找有无与[beg2,end2)相同的子区间，如果找到返回[beg1,end1)内第一个相同元素的位置，如果没有找到返回end1；

- **merge算法**：

  ```c++
  merge(beg1,end1,beg2,end2,dest)
      //将[beg1,end1)区间与[beg2,end2)区间进行合并，放到dest中去，如果合并前有序，合并后仍然有序。不会去重！！
  ```

  容器链表的merge成员函数更简单：

  ```c++
  L1.merge(L2);
  ```

- **sort算法**：
  对指定区间进行排序，默认是从小到大

  ```c++
  sort(beg,end);//左闭右开
  ```

未完待续..........

[C++ STL详解超全总结(快速入门STL)-CSDN博客](https://blog.csdn.net/qq_50285142/article/details/114026148)
