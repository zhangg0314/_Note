# 	GCC编译工具

## 1.GCC概念

`GNU C Complie`编译器

## 2.GCC编译过程

 ```bash
 gcc -E	#(预处理)    .c ---> .i
 gcc -S	#(编译:检查语法错误) .i ---> .s(汇编文件)
 gcc -c	#(汇编)     .s-->.o(二进制文件)
 gcc		#(链接)         各种.o-->可执行文件.elf
 
 #所有的.c文件都有经过预处理，编译，汇编三个步骤。
 #这三个步骤独立，不依赖不依靠其他文件的功能，库函数，即不是说别的函数调用了stdio库，我就可以不调了。
 #最终独自生成.o文件，然后所有.o文件链接形成一个可执行文件。
 
 
 -a为可执行程序，b为动态库，c为动态库
 -b编译时要链接c
 -a编译时既要链接b也要链接c #不依赖不依靠其他文件的功能，库函数
 -b链接c只是为了编译通过不报错而正确生成b.so的文件，但b.so文件并未包含c的代码，因此编译a时仍然需要链接c
 ```

## 3.常用GCC命令

```shell
gcc -I	#（大写i） 指定头文件的路径：指定头文件

gcc -l	#（小写L） 库名 ：链接库
gcc tets.c -lpthread

gcc -L 	#指定库的路径

gcc -O/O2  #优化代码，同volatile里优化意思一样

gcc -g     #进行调试---->gdb ./a.out
```

## 		4.条件编译

好处：通过命令传宏来决定执行哪些代码，省的总注释来注释去的，即相当于一个开关，常用于底层开发代码中。

```c
//1. 根据宏是否被定义来进行条件判断并进行条件编译
#ifdef
#ifndef

#endif
    
    
//2.根据宏的值。。。。。。。
#if VALUE//根据宏的值为真还是假来
#endif

gcc xxx.c -D 宏1    //相当于给程序里添加宏定义的语句即#define 宏1 
gcc xxx.c -D VAULE = 1   //把value的值赋值为1 
```

------

# 		GDB调试

## 1.进入调试模式

```shell
gdb 可执行文件名
```

## 2.设置断点

```shell
break 
#设置断点，后面可以跟函数名或行号，表示在某一行打断点
```

## 3.运行程序

```shell
1.
start  #进入程序的入口处，等待执行程序
continue #statrt后往后顺序执行，直到遇到一个断点处

2.
r(run):#直接让代码运行至断点处

3.
n(next) #从断点处开始一条一条的执行
```

## 4.打印信息

```shell
print (&)变量名 #查看变量的值，加上&查看变量的地址

x /nxb &s #打印变量s在内存存储的具体的内容，格式为从结构体首地址开始分别输出n个字节的内容，格式显示为16进制。

bt		#打印调用栈

bt		#查看栈

l(list)	 #不记得代码了，敲一个l显示一段代码内容。

Edit



Step

Help

Quit
```

## 5.GDB调试程序

```shell
gcc -g xxx.c #如果程序出错（非语法错误，比如越界，段错误)，则会生成core和a.out文件

gdb a.out core #（core文件):在core文件里查看出错原因

gdb a.out -p 进程pid	#调试正在运行的进程
```

![image-20240621124813998](..\figure\image-20240621124813998.png)

![image-20240621125023445](..\figure\image-20240621125023445.png)

------

# MakeFile

## 1.概述

1. **含义**

   make 是一个命令，它通过读取一个名为 Makefile（或   makefile  ）的配置文件来自动执行一系列的构建任务。make，说简单点，就是制作，如果Makefile中定义的需要制作的目标在当前目录已有且是最新的，则make不会执行，目标就用当前目录的，没有就根据制作规则语句进行制作。

2. **作用**
   1.一旦写好makefile文件，只需一个make命令，整个工程完全自动编译，极大提高了软件开发的效率。

   2.提升编译效率：不是一步编译时，第二次make时，只编译修改了的文件。其是利用文件时间戳来确定文件是否被修改过了。

   3.make 的主要用途是自动化构建过程，特别是编译和链接程序。

## 		2.基本语法

### 1.语法格式

```makefile
目标（target）... : 依赖（prerequisites） ...
	命令（command）
```

### 		2.解释

1. **target目标**
   它是我们要生成的东西，省略文件的路径时，默认为当前路径，目标文件可以是我们所需的最终文件或者可执行文件，也可以不是我们最终要生成的文件——伪目标。一个伪目标,仅仅是为了执行某条shell语句实现某个功能，并不生成文件。

2. **prerequisites**

   要生成那个target所需要的文件，默认在当前目录下找，如果没有则找有无生成该依赖的makefile语句，此时依赖就是另外一条语句的目标。

3. **command**

   任意shell命令，不一定是gcc命令，**@**作用是不显示命令再显示结果而是直接显示执行命令的结果。


### 		3.解析规则

1. 只敲一个make，默认只找第一条目标，故执行有多条语句的makefile时，应把生成最终目标的语句放在最前面，因为make默认只识别makefile的第一条语句。
   其找依赖文件，默认会**在当前目录**下找，如果有该名称的文件，则直接用该文件，如果没有，则makefile中找是否有该依赖文件作为目标文件存在于另外一条语句中，有该语句，则先执行完该语句。就这样带动一连串的make语句被执行。

2. make  目标名：则寻找生成该目标的语句进行执行。

3. .PHONY（虚假的意思）:目标名
   解决**make默认执行的第一条语句**或者**指定执行的语句**中的目标名（可以是伪目标）与当前目录下文件名重名的冲突，此外新生成的文件会覆盖当前目录下重名的那个文件，以.PHONY做目标，会找并执行第一条伪目标语句。

## 		3.makefile变量

### 		1.创建变量的目的

用来代替一个**文本字符串**，该字符串可以是：

1.系列文件的名字

2.传递给编译器的参数

3.需要运行的程序

4.需要查找源代码的目录

5.需要输出信息的目录

6.etc

最终就是便于维护和修改makefile文件，改一处，实现多次改。

### 		2.自定义变量

1. 声明时就要赋值，赋值多个字符串时，用空格隔开。
2. 取值方式：$(x)或${x}==取x的值，$$表示打印真实的$符号。
3. SRC = $(shell pwd)/obj ：shell命令执行结果作为值给变量赋值，但$(shell pwd）会被立马执行，其结果为make执行的当前工作目录，当SRC传递其他目录下的文件时，传递的并不是$(shell pwd),而是make工作目录。

### 		3.变量赋值

- =一般赋值,多个条语句对同一变量赋值，最终结结果为最后一条语句的值
- ?=如果前面已经给该变量赋值了，则此次赋值失效，否则执行此次赋值 

- :=如果前面有值了则覆盖掉原来的值，与？=相反

- +=追加赋值

### 		4.自动变量

针对文件名，自动指变量的值会根据修改自动调整

#### 1.依赖文件

- $+所有依赖文件，可重复·    

- $^ 所有依赖文件，不重复      

- $<第一个依赖文件，按生成时间排序的第一个

- $?:所有时间戳比目标文件晚的依赖文件，即上一次修改时间比目标文件生成时间晚的文件，用于打印第二次编译时哪些依赖文件被修改了。

#### 2.目标文件

- $*：不包含后缀 ，用于打印，对于本身没后缀的无效，对于可执行文件a.txt，他还是没后缀，.txt也算文件名不算后缀名，故打印无后缀的只能用$@  
- $@目标文件完整名字，有后缀名的也包含后缀名，用于打印和编译        


 		作用：提高编程速度，每次只要写一句gcc命令再不断复制粘贴带有自动变量的相同的语句即可。makefile隐含变量,针对shell命令，可以赋值，不赋值则用默认值.

#### 3.命令（有默认值）

- CC：默认值--cc 赋值交叉编译 CC = arm-linux-gcc

- CPP：默认值--$(CC) -E预编译

- RM：默认值rm -f


#### 3.命令的选项（无默认值）

- CFLAGS= -c -g -Wall 

- CPPFLAGS

- CXXFLAGS

- LDFLAGS


**通配符**：<u>%.c ：%.o用通配符的前提是在通配符使用语句前已经出现过了%.c的范围是哪些.c文件，不然%可以匹配任意，那么有无穷多个目标了，此外通配符并不匹配路径！！，所以带有路径的文件通配，要自己加上路径</u>

## 	4.makefile的条件判断

1. ifeq（a,b）：a,b是否相等，if与（）间要隔开！！！

2. ifneq：是否不相等

3. ifdef  ARCH：只有ARCH**定义过且赋过值**才算定义过，无论是在文件中定义还是在传参时定义，规则都一样

4. ifndef   endif


## 	5.makefile常用函数

#### 1.格式

$(<函数名> <参数1,参数2>)或者${<函数名> <参数1,参数2>}

#### 2.举例

一个文件名应该 == 绝对路径/文件名，缺省绝对路径只有文件名默认都是当前目录下的文件，当文件名（无论有路径）赋值给变量时，其特性就不是文件了，就是一个字符串，赋值的时候缺省路径那么该字符串就没有路径，变量就是变量。

```shell
$(wildcard PATTERN)
	#功能：列出当前目录下所有符合模式PATTERN格式的文件名,比如*.c列出当前目录下所有.c文件
	#返回值：空格分割的，存在当前目录下的所有符合模式PATTERN格式的文件名,PATTERN是文件名，不是字串！！！	
	#PATTERN：可以使用shell下的可识别的所有通配符
作用：
	SRC = add.c sub.c test.c xxx.c.....www.c#此时SRC仅仅只是一串字符，不会说有默认当前目录下的这些文件这种说法
	取代：SRC = $(wildcard *.c),大大简洁了代码！！
$(pastsubst <pattern>,<repalcement>,<text>)
	#它用于将一个字符串中符合特定模式的子串替换为另一个字符串，不符合的字串就不换
	#text:要进行替换的对象，若有多个则用空格隔开，text是字串
	#pattern：替换对象满足的文件名字格式，pattern也是字串。
	#replacement：替换成什么格式的文件名，replacement也是字串。
	#返回值是替换后的文件名，包含没有被替换的，比如，text为1.c，2.cpp，pattern为*.c，则返回值为1.o,2.cpp
```

## 	6.makefile自定义函数 

​	**定义**：

​			define 函数名 

​				函数体		//用$(0….9)来获取第n个参数，第0个参数是函数名字

​			endef

​	**调用：**$(call 函数名 参数）

## 	7.make命令的使用

```shell
make #默认访问文件名为makefile的文件

make -f file#make文件名为file的文件

make -i #忽略所有执行出现的错误导致的停止，即使出错了，也会接着往下执行，不会在出错的地方直接停止了。这很重要，特别是当一个工程要编译几个小时时，编译了好久因为出错停了又得重来。

make -n #只打印要执行的命令有哪些，并不执行这些命令

make -s #只执行，不打印命令

make -w #当工程庞大分了好多文件目录时，打印当前的目录来表示当前编译进入到哪个目录了，告诉你从哪跳到哪了

make -C #指定哪个目录下有makefile(默认加了-w的功能)，让make去执行它    
```

##  	8.分目录管理源码

```makefile
#*.c-->src目录
#*.o-->obj目录
#当前目录的make执行makefile时，也去执行其他目录下的makefile则当前目录下的makefile要用到   
make -C 目录名1 目录名2 目录名3.... 这条shell语句，又因为执行shell语句要用到目标：依赖这样的格式,则应为：
1.SRCDIR = ./src/
	$(SRCDIR):
		make -C $@
		#执行结果：
		'src/'已是最新
#一切皆文件，目录也是文件,则会出现重名的问题，解决办法，以SRCDIR为目标的语句中添加依赖，依赖不能是目录，不然也会出现同样问题。
 $(SRCDIR): ECHO
	make -C  $@
 ECHO:
 	echo Hello
 	
 	
2.利用.PHONY解决,一个makefile文件中只能使用一次
 .PHONY:$(SRCDIR)
  $(SRCDIR):
		make -C  $@
		
3.
export 变量1，变量2，变量…..#将当前makefile的变量传递给其他makefile文件使用
如果把带有路径的文件名赋值给变量，当该变量在一个文件夹中定义赋值，而在另外一个文件夹中使用时应该用绝对路径。
```

## 	9.makefile总结

- **默认条件**
  假设目标名是test，如果当前目录中有test.c（一定要是.c文件才可），即存在以目标名为前缀，.c为后缀的C源文件，哪怕有test.c,test.txt并存，只要有test.c,则都算满足默认条件。

- **默认语句**
  $(CC)  $(FLAGS)  xxx.c -o xxx，CC FLAGS可以赋值，也可以使用默认值，其中FLAGS没有默认值。

- **执行步骤**

  假设当前目录下有add.c   a.txt  b.txt  makefile  sub.c  test.c  test.txt这些文件


1.**只有一个目标，无依赖无命令**

```makefile
###1.目标满足默认条件
	test:
		#有以test为前缀,.c为后缀得test.c，且命令缺省，满足默认条件
		#执行结果：
		cc     test.c   -o test


###2.目标不满足默认条件
	a:
		#不存在以a为前缀,.c为后缀得a.c，不满足默认条件，且命令缺省。
		#执行结果：
		make: 对“a”无需做任何事。
```

**2.有目标，有依赖，但没命令**		

```makefile
	###1.目标满足默认条件，且缺省命令，且依赖当前目录存在，执行默认语句
		test:a.txt
			#执行结果：
			cc     test.c a.txt   -o test
			
			
	###2.目标满足默认条件，且缺省命令，但依赖不存在当前目录，则需要make依赖，创造成功但命令缺省，则执行默认语句，不过默认语句要加上依赖文件
		#2.1如果依赖作为目标满足默认条件，则先执行默认语句创造依赖，再执行本次make语句
		test:add
			#执行结果：
			cc     add.c   -o add
			cc     test.c add   -o test
		#2.2如果依赖作为目标不满足默认条件，且没有制作依赖的语句，则全报错
		test:a
			#执行结果：
			make: *** 没有规则可制作目标“a”，由“test” 需求。 停止。
		#2.3如果依赖作为目标不满足默认条件，且有制作依赖的语句，先执行创造依赖的语句，制作依赖的语句可以当作新的语句来继续进行判断是否制作成功，若成功，再执行本次make默认语句
		test:a
		a:add
			#执行结果：
			cc     add.c   -o add
			cc     test.c a   -o test
	
	
	
	###3.目标不满足默认条件，且缺省命令，先创建依赖，依赖创建规则同上，又因为缺省命令，所以此次make语句相当于不会执行，不是报错(此时叫伪目标)。
		a:add
			#执行结果：
			cc     add.c   -o add
		a:b
			#执行结果：
			make: *** 没有规则可制作目标“b”，由“a” 需求。 停止。
		a:b
		b:add
			#执行结果：
			cc     add.c   -o add
```

3**.有目标，有命令，但没依赖。**

不存在满不满足默认条件的问题，因为满足默认条件了，只是为了执行默认语句命令，都有了命令，肯定不是默认命令了啊，故目标满不满足默认条件不影响

```makefile
###无论目标满不满足默认条件，都会按照命令执行
	a:
		@echo hello
		#执行结果：
		hello
		
	test:
		@echo hello
		#执行结果：
		hello
		
		
###如果目标与当前目录下文件重名：解决办法.PHONY
	test.c:
		@ehoc hello
		#执行结果:
		make: “test.c”已是最新。
	
	.PHONY:test.c
	test.c:
		@ehoc hello
		#执行结果:
		hello
```

4.**有目标，有命令，有依赖**

```makefile
#先制作依赖，再根据命令不是默认命令制作目标!!,不存在满不满足默认条件的问题，因为满足默认条件了，只是为了执行默认语句命令，都有了命令，肯定不是默认命令了啊，故目标满不满足默认条件不影响
```

makefile每条语句生成的目标都只是作为中间结果，和最终的一个目标，这些中间结果和最终目标文件会不会在当前目录下创建是要看以它们为目标的语句所用的shell命令是不是会去在当前目录下创建文件。不会在当前目录下创建目标文件的语句：叫做伪目标语句。