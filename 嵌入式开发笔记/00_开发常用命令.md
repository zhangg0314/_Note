# SSH连接服务器

[Windows下通过ssh连接Linux_如何进行ssh连接-CSDN博客](https://blog.csdn.net/G_66_hero/article/details/97971023)

[Windows下生成ssh密钥，并用ssh免密访问Linux服务器_cmd生成ssh密钥-CSDN博客](https://blog.csdn.net/qq_43193386/article/details/120194085)

# Linux

## 1.Linux常用命令

### 1.文件相关命令

- **查找文件或目录**

  ```bash
  find [搜索路径] [选项] [正则表达式]
  	[选项]
  		-name	#根据文件名查找		eg:find ./ -name = *.txt
  		-type	#根据文件类型查找       eg:find -./ type = l
  		-size	#根据文件大小查找-+n：大于 n   -n：小于 n     n：等于 n
  		-maxdepth n #搜索目录递归的深度为n，省略默认全盘搜索
  
  #组合条件:查找当前目录及其子目录下所有属于用户 username 或大小大于 1MB 的文件
  find . -type f \( -user username -o -size +1M \)
  ```

- **编辑文件**

  ```bash
  vi example.txt		#在shell模式下,键入vi及需要编辑的文件名,即可进入vi. 
  
  vi +5 example.txt	#如果需要在进入vi编辑界面后，将光标置于文件的第n行，则在vi命令后面加上“+n” 参数即可
  ```

- **查看文件内容**

  ```bash
  cat /etc/sysconfig/network
  	[option]
  		-n #查看行号信息
  ```

- **目录操作**

  ```bash
  pwd		#显示当前工作区所在路径
  
  ls [-a | -l]		#显示当前文件夹下的文件及文件夹
  ```

  

```bash




cd [Directory]             #切换当前工作路径,缺省Directory默认回到home目录

touch <FILENAME>           #创建文件

mkdir <DIRECTORYNAME>      	   #创建文件夹        
	[option]    -p(--parent)   #级联创建文件夹

rmdir <DIRECTORYNAME>     	   #删除空目录        
	[option]    -p             #递归删除文件夹，先删子目录，之后若父目录也空则也删除，故p后面的路径要包含父目录名和子目录名  

cp <SOURCE> <DEST>             #复制文件或文件夹
	[option]    -r(--recusive) #递归拷贝子目录
            	-f(--FORCE)    #强制拷贝，忽略提示信息

mv <SOURCE> <DEST>   		  #重命名或者移动文件或文件夹

rm <FILENAME>    			  #删除文件               
	[option]      -r          #递归删除删除文件夹以及文件夹里的东西		
              	  -f          #不提示直接强制删除		
                  -i          #删除前提示是否删除   

cat <FILENAME>    			 #打开文件
```

### 2.系统相关命令

```bash
clear             #清除屏幕所有打印的信息

umask             #获取当前权限掩码，文件实际权限为创建文件时赋予的权限-权限掩码

#定时关机，重启
sudo shutdown -h now/时间 [关机提示信息] #立即/定时关机
sudo shutdown -r now/时间 [重启提示信息] #立即/定时重启
sudo reboot                            #立即重启

uname -n #显示主机名
uname -r #显示内容核版本
uname    #显示内核名，如Linux或者Unix
unmae -a #显示更加详细的信息

cat /etc/os-release  #查看操控操作系统发行版本
```

### 3.用户权限相关命令

```bash
su [-l]  <用户名>                      #切换到目标用户，加-l(环境PATH也会变)，看$前面是~还是其他用户，如果是~表示切换了当前                                        用户且当前环境也是该用户的，否则只是切换了用户并未切换环境，环境没变，有些有权限的操作                                        不能使用。

su -c <命令>  <用户名>                 #切换到目标用户执行一下该命令再切换回当前用户

sudo adduser <用户名>                  #添加用户

exit                                  #退出目标用户到自己的用户下

sudo vi /etc/password                 #查看用户密码

vi      /etc/group                    #查看组

chmod <八进制> <FILENAME>              #修改文件权限

chmod [u | g | o | a(all)]  [+ | - | =]  [r | w | x] <FILENAME>

passwd                               #修改当前用户密码

sudo passwd <用户名>                  #修改指定用户名密码
```

### 4.网络相关命令

```bash
nc(netcat) [option] <ip> <port>        #建立tcp或者udp连接
	[option]      -u                  #使用UDP协议,默认使用TCP协议
```

### 5.进程相关

```bash
ps        #process status，用于查询进程状态,查到的进程可能处于运行态，也可能处于僵尸态等其他状态。

pidof     #是Linux系统中用来查找正在运行进程的进程号(pid)的工具， pidof命令用于查找指定名称的进程的进程号，查到的进程一定处于运行态。

killall   #杀死同一进程组内的所有进程，其允许指定要终止的进程的名称，而非PID
```

### 		6.输入输出命令

​	在Linux系统中，`/dev/null`是一个特殊的文件，用于将数据彻底丢弃。它是一个特殊的文件设备，可以通过标准输入和标准输出访问。读取/dev/null将会立即返回EOF文件结束符，而向它写入任何数据将会直接被忽略掉，从而丢弃数据。

- echo

  ```bash
  [option]    -e(enable)  #使能转义
               -E(disable)
  
  echo "hello world"  	  #默认带换行符
  echo -n "hello world"	  #不带换行符
  echo "hello world\n"	  #默认带换行符，\n一样被打印出来
  echo -e "hello world\n"   #默认带换行符，\n被翻译成换行。
  
  
  a = 5
  echo $a   #取a变量的值,弱引用，想当于"$a"
  echo '$a' #直接打印$a，强引用
  ```

- 输入输出重定向
  输入/输出重定向是指改变shell命令或程序默认的标准输入/输出目标，重新定向到新的目标。默认的输入输出位置是stdin，stdout，stderr这三个系统自带可以直接用的FILE*流的变量。
  比如ls:无法访问'ha':没有那个文件或目录，这句错误提示就是标准出错。

  ```bash
  #输出重定向
  ls > log    #打开/新建log，清空之前的再写,不加n默认是标准输出重定向到log
  ls >> log   #打开/新建log，追加
  ls file 2 >> log      #标准出错重定向，但标准输出又不会重定向
  ls file > log 2>&1    #标准输出重定向到log，标准出错重定向到标准输出
  ls file &> log      #与ls file >log 2>&1等价
  	
  #输入重定向
  cat           #从标准输入输入
  cat file      #把file内容利用标准输入读取并输出到标准输出上
  cat < file    #与cat file等价
  cat << number #<<后面的number其实是数字作为分隔符，当输入遇到指定数值number时停止输入，打印所有之前的输入的数据。
  ```

- 通配符

  ```bash
  *.c        #*匹配任意长度的字符串，即*可以代表任意长度的任意字串
  ?.c        #?匹配一个长度的字符串，即?可以代表任意一个字符
  [1,3,4].c  #匹配?.c其中的1，3，4，即1.c，3.c，4.c
  [1-5].c    #匹配?.c其中的1-5，即1，2，3，4，5
  [^1-5].c   #匹配?.c其中的除了1-5.c之外的。
  ```

- 管道
  管道前的命令一定要有输出结果才能传给管道后的命令

  ```bash
  cat file | wc -l 
  wc [option]
  [option]  -l  #统计有多少行内容
            -w  #多少个单词
            -c  #多少个字符
  ```

- 历史查询，补齐功能

  ```bash
  history  #查询历史命令
  !c       #执行上一个以c开头的命令
  !g       #执行上一个以g开头的命令，常为gcc
  table键  #自动补齐
  ```

- 命令置换(转义)

  ```bash
  a = `ls` #不让ls的结果输出到终端，而是把结果存到变量a中
  echo $a
  ls pwd   #系统以为ls列出名为pwd的文件
  ls `pwd` #先执行pwd，再ls就是ls当前目录的内容了
  ```

### 7.环境变量相关命令

- source 命令
  用于在**当前**shell环境中执行脚本或加载配置文件。

  ```bash
  source 文件名
  source ~/.bashrc #加载环境变量
  source .env      #加载.env文件
  
  ./script.sh			#直接执行脚本（在新的shell中执行）
  source script.sh 	#source执行（在当前shell中执行）
  
  
  #创建一个包含环境变量的文件env.sh
  export PROJECT_ROOT="/path/to/project"
  export API_KEY="your-api-key"
  #加载环境变量
  source env.sh
  #验证环境变量是否生效
  echo $PROJECT_ROOT
  echo $API_KEY
  ```

## 2.Linux文本编辑器

### 		gedit编辑器

### 		vim编辑器命令

```vim
1.
    h j k l：分别为左移一个字符，下移一行，上移一行，右移一个字符

2.行内移动：
	1) w向后一个单词
    2) b向前一个单词
	3) 0行首    
    4) ^行首非空白字符 
	5) $行尾
  
3.行间移动：

	1) gg:文件首部

	2) G:文件尾部

	3) 数字n  gg或者G:移动到第n行
    
    4) gg=G：对齐缩进全文

	5) =:对齐缩进当前光标所在行，也可以缩进选中的多行

4.页间移动：

	1)ctrl+b向上翻页   
    
    2)ctrl+f（forword）向后翻页

	3) H M L 头 中 尾

5.删除剪切复制：

 	1)一个字符：

		x 剪切一个字符

	2)n行：

		[n] dd 剪切行  

		[n] yy 复制行
        
        [n] x  剪切字符

	3)粘贴:
		p:用于vim编辑器内部之间的粘贴
        ctr+shift+v:用于外部的ctr+c复制过来的粘贴到vim编辑器内部
	4)行内：
		y或者d 0  复制或者剪切光标处到行首的那一部分
        y或者d $  复制或者剪切光标处到行尾的那一部分

 	5)块：
		:n,m d或者y  //底行模式
     6)删除一个单词：
          d w
6.替换：
   		r替换一个字符 
        R进入替换模式，可以猛猛替换
7.查找：
		/str：查找str，n高亮显示下一个，N显示上一个
		:n，m s/str/det_str/g c（确认替换）全部替换
        :% s/str/des_str/g 全文替换
8.分屏命令：
		:sp [文件名] 横向
		:vsp [文件名]竖向
		Ctrl+h j k l移动到哪个窗口
9.行号显示:
		:setnu 设置行号  
        :setnonu取消行号
10.定位行：
         vi 文件名 +n：打开已有文件，并且光标初始在第n行的位置
         :n  光标定位到第n行//好处在于，在几千行的代码中只需要一个命令就能直接定位，而不需要鼠标慢慢的滑
11.文件保存：
          q：退出
          w:保存
          q！：不保存修改的内容直接退出
          w file：另存为文件file
          r file：读取file文件内容到光标处
12.可视模式：
          v：进入可视模式，可以用上下左右选中
          V：直接选中光标所在行的一整行
13.撤销恢复：
          u：撤销上一个命令
          ctrl+r：恢复被撤销的命令
```

## 	3.软件包管理

### 		软件包类型

- 二进制包：系统可以直接安装拿来用的包格式。

- 源码包：需要经过编译生成二进制包才可以安装。


```shell
file  test.c
file  xxx.deb
#软件包包名/文件：查看软件包/文件类型
```

### 		在线软件包管理

```shell
#更新软件源
1.修改/etc/apt/source.list
2.sudo apt-get update
3.图形界面修改


sudo apt-get install 包名  #下载包名并安装
sudo apt-get --purge remove 包名  #删除包名以及依赖关系
sudo apt-cache depends 包名  #查看包的依赖关系
```

### 		离线软件包管理

```shell
sudo dpkg -i(install) 包名 #安装（包名格式要全）
sudo dpkg -r(remove) 包名 #移除（只要包名也可以
dpkg -s(status) 包名 #显示安装状态
sudo dpkg -P(purge) 包名 #移除包以及配置文件
dpkg -L(list) 包名 #列出软件包的清单
```

## 4.常用配置目录/文件

```shell
当登录系统或新开启一个ssh连接启动bash进程时，一定会加载这4个配置文件：
# vim /etc/profile   #系统全局环境和登录系统的一些配置
# vim /etc/bashrc    #shell全局自义配置文件，用于自定义所有shell
# vim /user/.bashrc  #用于单独自定义某个用户的bash
[root@zhangg ~]# vim /root/.bash_profile  #用户单独自定义某个用户的系统环境
```

## 5.参考链接

https://www.kancloud.cn/digest/linux-world/145282

# Git

## 1.Git介绍

1. Git是一个开源的分布式版本控制系统（Distributed Version Control System，简称DVCS），用于高效地管理项目版本。它能够有效、高速地处理从小到大的项目版本管理，追踪项目从开始到结束的整个过程。

2. 版本控制（Version Control）是软件配置管理的一项内容，主要对程序、文档等项目制品的版本变更进行管理。它允许开发者记录、追踪和管理代码或其他文件的历史变化，以便在需要时能够恢复到以前的版本或查看历史记录。版本控制是团队协作开发的桥梁，有助于多人协作同步进行大型项目开发。

## 2.集中式vs分布式

- **集中式版本控制系统**：
  版本库集中存放在中央服务器。最大的毛病就是必须联网才能工作。
- **分布式版本控制系统**：
  没有“中央服务器”，每个人的电脑上都是一个完整的版本库。你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了，这是因为每个人都需要在本地创建版本库，并且把修改提交到版本库了才可以推送即push前都要先commit，所以相当于强制性要求了每个人在推送前都要在本地备份一样。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。

## 3.Git的作用和目的

1. **版本控制**：Git允许开发者跟踪代码的版本历史，可以回溯到任何时刻的代码状态。这对于调试、修复错误以及恢复代码都非常有用。
2. **分支管理**：Git支持创建多个分支，使得团队成员可以并行地开发不同的功能和修复不同的bug。<u>每个分支都可以独立地进行开发和测试</u>，最后再将分支合并到主分支上。这种分支策略提高了开发效率和灵活性。
3. **合作开发**：Git提供了远程仓库的功能，使得团队成员可以共享和合并代码。通过Git，开发者可以轻松地将代码推送到共享仓库，并进行同步，从而促进了团队协作和代码共享。
4. **撤销和回退**：Git允许开发者撤销之前的提交，回退到之前的版本。这对于修复错误或不需要的更改非常有用，保证了代码的稳定性和可维护性。
5. **快速部署**：Git可以轻松部署代码到生产环境。通过创建发布分支或打标签，开发者可以准确地控制代码的部署版本，提高了部署的效率和准确性。
6. **高度可靠性和安全性**：Git的分布式架构意味着每个开发者都有一份完整的代码库，即使服务器出现故障，开发者仍然可以继续工作。此外，Git使用哈希算法来标识每个版本，确保每个版本的唯一性和完整性，提高了代码的安全性和可靠性。

## 4.Git安装

### Linux

```shell
sudo apt-get install git
```

### Windows

直接下载Git Bash软件

## 5.Git本地仓库各种状态解析

### 工作区（Working Directory）

就是我们敲命令，改代码的当前目录，我们平时更新版本什么的，都是在这里完成的，可以理解成是在这里工作的。

### 版本库（Repository）

工作区有一个隐藏目录 `.git`，这个不算工作区，而是 Git 的版本库。可以任务有.git隐藏目录的目录算一个仓库，大仓库可以嵌套小仓库。

Git 的版本库里存了很多东西，其中最重要的就是称为 `stage`（或者叫 index）的暂存区，还有 Git 为我们自动创建[***<u>不是真正的创建，要先进行一次commit操作（进行一次提交操作），才会真正建立master分支。这是因为分支的指针要指向提交的,只有进行了提交，才有指针指向该分支，才算是真正的建立了分支，成为一个有效的对象。</u>***]的第一个分支 `master`，以及指向 `master`的一个指针叫 `HEAD`。

红色代表新增文件或者被修改文件，绿色代表位于暂存区的文件。

## 6.Git基本命令

- git配置

  ```shell
  # 命令行输入user.name/user.email，让本地所有的Git仓库，无论是大仓库，小仓库，还是被嵌套的仓库，都使用这个配置
  # 每一个Git提交都会使用这些信息，它们会写入到你的每一次提交中
  git config --global user.name "张高"
  git config --global user.email "z3254406361@163.com"
  
  # 查看信息
  git config --list
  
  #修改信息
  git config --global --replace-all user.name "zhangg"
  git config --global --replace-all user.email "z3254406361@163.com"
  ```

- 创建版本库

  ```shell
  git init #初始化仓库，在当前也就是敲git init命令的目录下多一个.git目录，提交的版本是指整个当前目录的版本
  ```

- 创建文件并查看文件状态

  ```shell
  mkdir learngit
  touch readme.txt readme1.txt readme2.txt
  cp *.txt learngit
  
  #查看本地库状态，此时文件是untracked files，位于分支 master
  git status
  	尚无提交
  	未跟踪的文件:
    	（使用 "git add <文件>..." 以包含要提交的内容）
          learngit/
  	提交为空，但是存在尚未跟踪的文件（使用 "git add" 建立跟踪）
  ```
  
- 把文件添加到暂存区

  ```shell
  git add *.txt
  git status
  #位于分支 master
  尚无提交
  要提交的变更：
    （使用 "git rm --cached <文件>..." 以取消暂存）
          新文件：   learngit/readme.txt
          新文件：   learngit/readme1.txt
          新文件：   learngit/readme2.txt
  ```
  
- 提交所有位于暂存区的本地库,并为该版本库起一个见名知意的别名

  ```shell
  git commit -m "MyRespotity"
  [master（根提交） cd88d7e] MyRespotity
   3 files changed, 0 insertions(+), 0 deletions(-)
   create mode 100644 learngit/readme.txt
   create mode 100644 learngit/readme1.txt
   create mode 100644 learngit/readme2.txt
  ```

- 修改并提交

  ```shell
  echo 11 >> readme1.txt 
  git status
  位于分支 master
  尚未暂存以备提交的变更：
    （使用 "git add <文件>..." 更新要提交的内容）
    （使用 "git restore <文件>..." 丢弃工作区的改动）
          修改：     readme1.txt
  
  修改尚未加入提交（使用 "git add" 和/或 "git commit -a"加入提交）
  ```

- 查看修改

  ```shell
  git diff readme.txt 
  
  
  diff --git a/learngit/readme1.txt b/learngit/readme1.txt  #进行比较的是,a版本的readme1(即变动前)和b版本的readme1(即变动后).
  index e69de29..b4de394 100644#表示两个版本的git哈希值(index区域的e69de29对象,与工作目录区域的b4de394对象进行比较),最后的六位数字是对象的模式(普通文件,644权限).
  --- a/learngit/readme1.txt#表示进行比较的两个文件."-"表示变动前的版本,"+++"表示变动后的版本
  +++ b/learngit/readme1.txt
  @@ -0,0 +1 @@
  +11
  ```

- 把工作区中的修改撤销

  ```shell
  ls 
  1.txt  readme1.txt  readme2.txt  readme.txt
  rm 1.txt && ls
  readme1.txt  readme2.txt  readme.txt
  
  #修改撤销
  git checkout -- 1.txt && ls
  1.txt  readme1.txt  readme2.txt  readme.txt
  ```
  
- 版本回退，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为commit。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个commit恢复，然后继续工作，而不是把几个月的工作成果全部丢失。

  ```shell
  #查看提交日志
  git log
  #查看历史命令，寻找版本号
  git reflog
  
  git reset --hard HEAD^   
  #回退到上一次commit，说简单一点，HEAD就是当前活跃分支的游标。
  
  git reset --hard 1094a   #根据版本号回退到版本
  
  
  #查看指定commit的id的文件的本次提交到哪些分支上了，即哪些分支包含了此处提交
  git branch -a --contains cfc6773b07b6392144e124ee594aeaa6939e6bd7
  ```

## 7.Git分支命令

```shell
#查看当前分支
git branch

#新增分支
git branch 分支名

#切换分支
git checkout 目的分支名

#删除分支
git branch -D 分支名

#合并目标分支与当前所在分支
git merge 目标分支名

# 查看所有本地分支
git branch

# 查看所有远程分支
git branch -r

# 查看所有分支（本地和远程）
git branch -a

#解决合并分支冲突
1.修改冲突的文件
2.把修改好的冲突文件手动添加到暂存区
3.继续添加到版本库
```

分支示意图：![GitBranch](C:\Users\z3254406361\Desktop\GitBranch.png)

## 8.Git远程管理

- 建立本地文件夹和远程仓库的关联

  ```shell
  git remote add zhanggao git@git:192.168.65.113/term/ModularizationTerminal.git
  #zhanggao 克隆下来的仓库在本地的别名，不知道默认为origin
  ```

- 使用git clone一键配置

  ```txt
  在一个未初始化的目录中执行git clone命令时，Git会自动创建一个新的.git目录，并将克隆的仓库的内容复制到该目录中。此外,Git还会自动为克隆的仓库设置一个名为origin的远程仓库，指向你克隆的源地址。
  具体来说，git clone会执行以下操作：
  1. 创建一个新的目录(如果没有指定目录名，Git会使用仓库的名称。
  2. 在该目录中创建一个.git 目录，包含所有的版本控制信息。
  3. 将远程仓库的所有文件和历史记录复制到本地。
  4. 设置origin作为默认的远程仓库名称，指向克隆的源地址。
  因此，我们不需要在克隆之前手动执行git init，git clone会自动处理这些步骤。
  ```
  ```shell
  #指定分支克隆，默认为main或者master。
  git clone -b devlop https://github.com/user/repo.git
  ```

- 查看远程仓库

  ```shell
  git remote -v
  
  origin  http://192.168.65.113/term/ModularizationTerminal.git (fetch)
  origin  http://192.168.65.113/term/ModularizationTerminal.git (push)
  zhangg  ssh://git@192.168.65.113:term/ModularizationTerminal.git (fetch)
  zhangg  ssh://git@192.168.65.113:term/ModularizationTerminal.git (push)
  ```

- 从远程获取最新版本到本地

  ```shell
  git fetch origin master
  #从远程的在本地别名为origin仓库的master分支下载代码到本地的origin master
  git pull <远程仓库名> <分支名> == git fetch + git merge
  
  git push <远程仓库别名> <本地分支名>[:远程仓库分支名] #如果远程仓库分支省略，则默认为与本地分支同名。
  ```

- ssh密钥登陆

  ```shell
  #克隆远端库到本地，找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。
  1.生成密钥：
  	ssh-keygen -t rsa -C "xxx@163.com"
  2.查看生成的公钥:
  	cat /home/自己的用户名/.ssh/id_rsa.pub
  3.把公钥加载到远程仓库
  4.将SSH密钥添加到SSH代理#【解决每次连接ssh时提示Enter passphrase for key '/home/zhangg/.ssh/id_rsa': 的问题】：
  	eval "$(ssh-agent -s)"
  	ssh-add ~/.ssh/id_密钥文件名
  5.下载:
  	git clone 链接名
  	
  #推送到远端库
  git push 链接名
  ```

## 9.为各种命令自定义别名

```shell
sudo vi ~/.gitconfig#全局配置文件，执行git --config命令的值都保存在此文件中

增加
[alias]
	ls = log
	st = status
	... ... 
	自定义名 = 命令名
```

## 10.Git常见问题及解决方法

1. 对一个新建的目录初次进行推送时，应该先克隆远程仓库到本地目录中，以避免当前目录与远程仓库的ref状态不同步而引出一系列麻烦。

2. 测试SSH连通性时，可以用下面命令进行日志信息打印

   ```bash
   ssh -v git@192.168.65.113
   ```

## 10.1.Enter passphrase for key '/home/zhangg/.ssh/id_rsa'

git@192.168.65.113's password: 添加了密钥还是要密码。

### 解决1：

1. 检查ssh-agent是否运行

   ```bash
   echo "$SSH_AGENT_PID"
   ```

2. 如果没有输出，说明ssh-agent没有运行。启动ssh-agent并加载密钥

   ```bash
   eval "$(ssh-agent -s)"  # 启动 ssh-agent
   ssh-add ~/.ssh/id_rsa   # 添加密钥
   ```

3. 如果还未解决，则启用ssh-v，根据打印日志具体排查。

# shell脚本编程

## 1.shell脚本概述

shell脚本就是一些Linux命令的集合，执行shell脚本，就会自动执行这些全部的命令。

```shell
!#/bin/bash 
echo "hello world" #命令、选项与参数之间必须用空格隔开。
```

## 2.shell脚本变量

### 变量介绍

- 变量来源于数学，是计算机语言中能储存计算结果或能表示值的抽象概念。
- 变量可以通过变量名访问。在指令式语言中，变量通常是可变的

### 变量的作用

- 用来存放系统和用户需要使用的特定参数（值)
- 变量名：使用固定的名称，由系统预设或用户定义
- 变量值：能够根据用户设置、系统环境的变化而变化

### 变量的命名要求

### 变量的分类

- 自定义变量

- 特殊变量：环境变量，只读变量，位置变量，预定义变量

- 注意：变量赋值不能带空格，不然被当成命令会报错。

- 在shell编程中通常使用全大写变量
- 变量的调用：在变量前加$
- Linux Shell/bash从右向左赋值
- 使用unset命令删除变量的赋值 

### 用户自定义变量

#### 取值

- 双引号: 允许通过$符号引用其他变量值，弱引用，其中的变量引用会被替换为变量值
- 单引号: 禁止引用其他变量值，$视为普通字符，强引用，其中的变量引用不会被替换为变量值，而保持源字符串
- 反撇号: 命令替换，提取命令执行后的输出结果，``和$(…)作用相同

#### 数组

- echo $a：默认显示数组a的第一个元素
- echo ${a[0]} ：显示数组中第一个元素，以此类推
- echo ${a[-1]}： 显示数组中最后一个元素
- echo ${a[*]} 和echo ${a[@]} ：显示数组中所有元素
- echo ${#a[@]} ：显示数组中元素的个数
- echo ${a[@]:起始元素id:元素个数]} ：显示数组中以起始元素为首的指定个数的元素（注意：这里起始元素id不能为负值
- unset a[n] 删除数组中的第n个元素
- unset a 删除a这个数组

### 只读变量

- 变量值不允许修改（重新赋值)的情况
- 无法使用 unset删除
- 最快方法重启
- readonly关键字

### 位置变量和预定义变量

- $0   与键入的命令行一样，包含脚本文件名
- $1,$2,……$9 ${10} 分别包含第一个到第十个命令行参数
- $#   包含命令行参数的个数
- $@  包含所有命令行参数：“$1,$2,……$9”
- $*  包含所有命令行参数，是一个整体：“$1,$2,……$9”
- $?  包含前一个命令的退出状态
- $$  包含正在执行进程的ID号

### 环境变量

- $USER 表示用户名称
- $HOME 表示用户的宿主目录
- $LANG 表示语言和字符集
- $PWD 表示当前所在工作目录
- $PATH 表示可执行用户程序的默认路径
- export可以将变量指定为全局变量局变量；

## shell分支语句

注意！！！：在算术运算，比大小，判断条件里的[ ]，命令与参数之间需要加空格。

### 分支语句

- then后面跟符合条件之后执行的程序，可以放在[]之后，用“;”分割。也可以换行写入，就不需要“;”了。

```shell
read -p "input a filename:" file
if test -e $file
then
	echo "$file exist"
elif [ -d $file];then
	echo "xxx"
else
	echo "$file is not exist"
fi

if [ -e $file ] #注意空格


即if[];then == if[]
				  then
```

### 多路分支语句

```shell
#！/bin/bash
read -p "input yes/no:" val

case $val in
	yes | Y)
		echo "input yes"
		;;
	no | n)
		echo "input no"
esac 
```

### 逻辑运算

```shell
if [$0 -a $1]....
-a #与
-o #或
```

###  算术运算

- 多层括号可以用`$($()+$())`实现
- 如果是 && || ,则要用if [ 表达式1 ] && [ 表达式2 ] 


### 循环分支

```shell
#1.
for a in {1,2,3,4,5}
do
	循环体  #执行一次有一个换行符
	if xxx then;
		break 
    else if xxx then;
		continue #立即结束本次循环，后面的没执行也不执行了
	fi
done

#2.
 for ((i=0;i<5;i=i+1))--两对括号间没有空格 
 
#3. 
 while ((i<5)) 

#4.
 while [ i -lt 5 ] 
```

### 其他语法

```shell
echo $? #获取函数返回值#

ret=`fun` #命令置换

#``和$()可以看作C语言中的define，但其赋值的内容仅限打印的内容，没有打印就没有值

#变量默认为全局变量，若fun里有一个变量，虽然默认为全局变量，但用命令置值时RET=`fun`时，fun外部还是不能用到该变量

$* :一个整体 ？？

$@:挨个打印？？
```

# Makefile

## 		makefile概述

1. **含义：**

   make是一个命令，是一个解释makefile中指令的命令,make，制作，当前目录已有，则用当前目录的，没有就根据制作规则语句进行制作。

2. **直接敲make**
   默认访问的是当前目录下名为makefile的文件；

3. **make -f 指定文件的文件名：**
   指定文件为makefile文件

4. **好处：**
   1.一旦写好makefile文件，只需一个make命令，整个工程完全自动编译，极大提高了软件开发的效率。

   2.提升编译效率：不是一步编译时，第二次make时，只编译修改了的文件。（利用文件时间戳来确定文件是否被修改过了）。

## 		makefile基本语法

### 		15.2.1.makefile 基本语法

target... : prerequisites ...

​	command

### 		15.2.2.解释

1. **target目标**
   它是我们要生成的东西，省略文件的路径时，默认为当前路径，目标文件可以是我们所需的最终文件或者可执行文件，也可以不是我们最终要生成的文件——伪目标。一个伪目标,仅仅是为了执行某条shell语句实现某个功能，并不生成文件。

2. **prerequisites**

   要生成那个target所需要的文件，默认在当前目录下找，如果没有则找有无生成该依赖的makefile语句，此时依赖就是另外一条语句的目标。

3. **command**

   任意shell命令，不一定是gcc命令，**@**作用是不显示命令再显示结果而是直接显示执行命令的结果。


### 		15.2.3.make解析规则

1. 只敲一个make，默认只找第一条目标，故只用make执行makefile有多条语句时，应把生成最终目标的语句放在最前面，因为make默认只识别makefile的第一条语句，找依赖文件，默认**在当前目录**下找，如果有该名称的文件，则直接用该文件，如果没有，则makefile中找是否有该依赖文件作为目标文件存在于另外一条语句中，有该语句，则先执行完该语句。

2. make  目标名：则寻找生成该目标的语句进行执行。

3. .PHONY（虚假的意思）:目标名
   解决**make默认执行的第一条语句**或者**指定执行的语句**中的目标名（可以是伪目标）与当前目录下文件名重名的冲突，此外新生成的文件会覆盖当前目录下重名的那个文件，以.PHONY做目标，会找并执行第一条伪目标语句。

## 		15.3.makefile变量

### 		1.创建变量的目的

用来代替一个**文本字符串**，该字符串可以是：

1.系列文件的名字

2.传递给编译器的参数

3.需要运行的程序

4.需要查找源代码的目录

5.需要输出信息的目录

6.etc

最终就是便于维护和修改makefile文件，改一处，实现多次改。

### 		2.自定义变量

1. 声明时就要赋值，赋值多个字符串时，用空格隔开。
2. 取值方式：$(x)或${x}==取x的值，$$表示打印真实的$符号。
3. SRC = $(shell pwd)/obj ：shell命令执行结果作为值给变量赋值，但$(shell pwd）会被立马执行，其结果为make执行的当前工作目录，当SRC传递其他目录下的文件时，传递的并不是$(shell pwd),而是make工作目录。

### 		3.变量赋值

- =一般赋值,多个条语句对同一变量赋值，最终结结果为最后一条语句的值
- ?=如果前面已经给该变量赋值了，则此次赋值失效，否则执行此次赋值 

- :=如果前面有值了则覆盖掉原来的值，与？=相反

- +=追加赋值

### 		4.自动变量

针对文件名，自动指变量的值会根据修改自动调整

#### 1.依赖文件

- $+所有依赖文件，可重复·    

- $^ 所有依赖文件，不重复      

- $<第一个依赖文件，按生成时间排序的第一个

- $?:所有时间戳比目标文件晚的依赖文件，即上一次修改时间比目标文件生成时间晚的文件，用于打印第二次编译时哪些依赖文件被修改了。

#### 2.目标文件

- $*：不包含后缀 ，用于打印，对于本身没后缀的无效，对于可执行文件a.txt，他还是没后缀，.txt也算文件名不算后缀名，故打印无后缀的只能用$@  
- $@目标文件完整名字，有后缀名的也包含后缀名，用于打印和编译        


 		作用：提高编程速度，每次只要写一句gcc命令再不断复制粘贴带有自动变量的相同的语句即可。makefile隐含变量,针对shell命令，可以赋值，不赋值则用默认值.

#### 3.命令（有默认值）

- CC：默认值--cc 赋值交叉编译 CC = arm-linux-gcc

- CPP：默认值--$(CC) -E预编译

- RM：默认值rm -f


#### 3.命令的选项（无默认值）

- CFLAGS= -c -g -Wall 

- CPPFLAGS

- CXXFLAGS

- LDFLAGS


**通配符**：<u>%.c ：%.o用通配符的前提是在通配符使用语句前已经出现过了%.c的范围是哪些.c文件，不然%可以匹配任意，那么有无穷多个目标了，此外通配符并不匹配路径！！，所以带有路径的文件通配，要自己加上路径</u>

## 	15.4.makefile的条件判断

1. ifeq（a,b）：a,b是否相等，if与（）间要隔开！！！

2. ifneq：是否不相等

3. ifdef  ARCH：只有ARCH**定义过且赋过值**才算定义过，无论是在文件中定义还是在传参时定义，规则都一样

4. ifndef   endif


## 	15.5.makefile常用函数

#### 1.格式

$(<函数名> <参数1,参数2>)或者${<函数名> <参数1,参数2>}

#### 2.举例

一个文件名应该 == 绝对路径/文件名，缺省绝对路径只有文件名默认都是当前目录下的文件，当文件名（无论有路径）赋值给变量时，其特性就不是文件了，就是一个字符串，赋值的时候缺省路径那么该字符串就没有路径，变量就是变量。

```shell
$(wildcard PATTERN)
	#功能：列出当前目录下所有符合模式PATTERN格式的文件名,比如*.c列出当前目录下所有.c文件
	#返回值：空格分割的，存在当前目录下的所有符合模式PATTERN格式的文件名,PATTERN是文件名，不是字串！！！	
	#PATTERN：可以使用shell下的可识别的所有通配符
作用：
	SRC = add.c sub.c test.c xxx.c.....www.c#此时SRC仅仅只是一串字符，不会说有默认当前目录下的这些文件这种说法
	取代：SRC = $(wildcard *.c),大大简洁了代码！！
$(pastsubst <pattern>,<repalcement>,<text>)
	#它用于将一个字符串中符合特定模式的子串替换为另一个字符串，不符合的字串就不换
	#text:要进行替换的对象，若有多个则用空格隔开，text是字串
	#pattern：替换对象满足的文件名字格式，pattern也是字串。
	#replacement：替换成什么格式的文件名，replacement也是字串。
	#返回值是替换后的文件名，包含没有被替换的，比如，text为1.c，2.cpp，pattern为*.c，则返回值为1.o,2.cpp
```

## 	15.6.makefile自定义函数 

​	**定义**：

​			define 函数名 

​				函数体		//用$(0….9)来获取第n个参数，第0个参数是函数名字

​			endef

​	**调用：**$(call 函数名 参数）

## 	make命令的使用

```shell
make #默认访问文件名为makefile的文件

make -f file#make文件名为file的文件

make -i #忽略所有执行出现的错误导致的停止，即使出错了，也会接着往下执行，不会在出错的地方直接停止了。这很重要，特别是当一个工程要编译几个小时时，编译了好久因为出错停了又得重来。

make -n #只打印要执行的命令有哪些，并不执行这些命令

make -s #只执行，不打印命令

make -w #当工程庞大分了好多文件目录时，打印当前的目录来表示当前编译进入到哪个目录了，告诉你从哪跳到哪了

make -C #指定哪个目录下有makefile(默认加了-w的功能)，让make去执行它    
```

##  	分目录管理源码

```makefile
#*.c-->src目录
#*.o-->obj目录
#当前目录的make执行makefile时，也去执行其他目录下的makefile则当前目录下的makefile要用到   
make -C 目录名1 目录名2 目录名3.... 这条shell语句，又因为执行shell语句要用到目标：依赖这样的格式,则应为：
1.SRCDIR = ./src/
	$(SRCDIR):
		make -C $@
		#执行结果：
		'src/'已是最新
#一切皆文件，目录也是文件,则会出现重名的问题，解决办法，以SRCDIR为目标的语句中添加依赖，依赖不能是目录，不然也会出现同样问题。
 $(SRCDIR): ECHO
	make -C  $@
 ECHO:
 	echo Hello
 	
 	
2.利用.PHONY解决,一个makefile文件中只能使用一次
 .PHONY:$(SRCDIR)
  $(SRCDIR):
		make -C  $@
		
3.
export 变量1，变量2，变量…..#将当前makefile的变量传递给其他makefile文件使用
如果把带有路径的文件名赋值给变量，当该变量在一个文件夹中定义赋值，而在另外一个文件夹中使用时应该用绝对路径。
```

## 	makefile总结

- **默认条件**
  假设目标名是test，如果当前目录中有test.c（一定要是.c文件才可），即存在以目标名为前缀，.c为后缀的C源文件，哪怕有test.c,test.txt并存，只要有test.c,则都算满足默认条件。

- **默认语句**
  $(CC)  $(FLAGS)  xxx.c -o xxx，CC FLAGS可以赋值，也可以使用默认值，其中FLAGS没有默认值。

- **执行步骤**

  假设当前目录下有add.c   a.txt  b.txt  makefile  sub.c  test.c  test.txt这些文件


1.**只有一个目标，无依赖无命令**

```makefile
###1.目标满足默认条件
	test:
		#有以test为前缀,.c为后缀得test.c，且命令缺省，满足默认条件
		#执行结果：
		cc     test.c   -o test


###2.目标不满足默认条件
	a:
		#不存在以a为前缀,.c为后缀得a.c，不满足默认条件，且命令缺省。
		#执行结果：
		make: 对“a”无需做任何事。
```

**2.有目标，有依赖，但没命令**		

```makefile
	###1.目标满足默认条件，且缺省命令，且依赖当前目录存在，执行默认语句
		test:a.txt
			#执行结果：
			cc     test.c a.txt   -o test
			
			
	###2.目标满足默认条件，且缺省命令，但依赖不存在当前目录，则需要make依赖，创造成功但命令缺省，则执行默认语句，不过默认语句要加上依赖文件
		#2.1如果依赖作为目标满足默认条件，则先执行默认语句创造依赖，再执行本次make语句
		test:add
			#执行结果：
			cc     add.c   -o add
			cc     test.c add   -o test
		#2.2如果依赖作为目标不满足默认条件，且没有制作依赖的语句，则全报错
		test:a
			#执行结果：
			make: *** 没有规则可制作目标“a”，由“test” 需求。 停止。
		#2.3如果依赖作为目标不满足默认条件，且有制作依赖的语句，先执行创造依赖的语句，制作依赖的语句可以当作新的语句来继续进行判断是否制作成功，若成功，再执行本次make默认语句
		test:a
		a:add
			#执行结果：
			cc     add.c   -o add
			cc     test.c a   -o test
	
	
	
	###3.目标不满足默认条件，且缺省命令，先创建依赖，依赖创建规则同上，又因为缺省命令，所以此次make语句相当于不会执行，不是报错(此时叫伪目标)。
		a:add
			#执行结果：
			cc     add.c   -o add
		a:b
			#执行结果：
			make: *** 没有规则可制作目标“b”，由“a” 需求。 停止。
		a:b
		b:add
			#执行结果：
			cc     add.c   -o add
```

3**.有目标，有命令，但没依赖。**

不存在满不满足默认条件的问题，因为满足默认条件了，只是为了执行默认语句命令，都有了命令，肯定不是默认命令了啊，故目标满不满足默认条件不影响

```makefile
###无论目标满不满足默认条件，都会按照命令执行
	a:
		@echo hello
		#执行结果：
		hello
		
	test:
		@echo hello
		#执行结果：
		hello
		
		
###如果目标与当前目录下文件重名：解决办法.PHONY
	test.c:
		@ehoc hello
		#执行结果:
		make: “test.c”已是最新。
	
	.PHONY:test.c
	test.c:
		@ehoc hello
		#执行结果:
		hello
```

4.**有目标，有命令，有依赖**

```makefile
#先制作依赖，再根据命令不是默认命令制作目标!!,不存在满不满足默认条件的问题，因为满足默认条件了，只是为了执行默认语句命令，都有了命令，肯定不是默认命令了啊，故目标满不满足默认条件不影响
```

makefile每条语句生成的目标都只是作为中间结果，和最终的一个目标，这些中间结果和最终目标文件会不会在当前目录下创建是要看以它们为目标的语句所用的shell命令是不是会去在当前目录下创建文件。不会在当前目录下创建目标文件的语句：叫做伪目标语句。

# CMake

​	本章主要是个人对https://www.bookstack.cn/read/CMake-Cookbook/README.md一些知识的总结，以及难以理解的地方进行一个通俗易懂的个人讲解，其中会剔除一些本人项目当中未使用的内容，而主要是注重遇到过的和比较重要的部分。此章节的目录将会参考该网址目录进行排列。

## 1.CMake介绍

​	CMakeLists.txt文件类似于Shell脚本，里面写的都是我们想要执行的CMake命令。CMake 主要是一个配置系统(构建系统生成器), 而不是一个构建系统。以下是具体解释:CMake 的主要工作是生成各种构建系统可以使用的配置文件，例如生成 Makefile (Unix)、Visual Studio 项目文件 (.sln) 等，处理依赖关系、编译选项、链接选项等配置。真正的构建系统是:Make、Ninja、Visual Studio MSBuild、Xcode等。
​	CMake 会自动将这些高层次的配置转换为具体平台上的构建系统配置文件，如在Unix上转为Makefile。

## 1.从可执行文件到库

## 2.CLI（命令行界面）

​	要配置项目并生成构建器，我们必须通过命令行界面(CLI)运行CMake。

- 配置项目并生成构建器

  ```bash
  cmake /path/to/CMakeLists.txt
  ```

- cmake常用选项

  ```bash
  cmake [options] <path-to-source>
  cmake [options] <path-to-existing-build>
  cmake [options] -S <path-to-source> -B <path-to-build>
      	
   [options]  	
      	-S <DirName>     #表示DirName目录中搜索根CMakeLists.txt文件,由于顶层CMakeLists.txt与源码目录是同一个目录下。
      	-B <DirName>	 #告诉CMake在一个名为DirName的目录中生成所有的文件。
      	-G <GName> 		#切换生成器，如切换成makefile生成器，Ninja生成器等。
      	--build .		#构建示例项目
  ```

## 3.CMake生成构建系统

### cmake_install.cmake文件

`cmake_install.cmake` 是CMake生成的一个安装脚本文件。主要用于处理项目的安装规则。定义如何安装项目的文件（可执行文件、库文件、头文件等）、指定安装位置、设置安装权限、处理运行时依赖。

生成时机：1.当运行 cmake .. 时自动生成。2.当执行 make install 或 cmake --install . 时被调用。

### CMakeCache.txt 文件

CMakeCache.txt 是 CMake 的缓存文件，存储了 CMake 构建过程中的各种变量和设置，存储 CMake 运行时的配置选项

缓存变量值以加速后续构建、记录项目的基本设置。

## 4.CMake注释

### 行注释#

```cmake
#这是一个行注释
```

### 多行（块）注释#[[]]

```cmake
#[[多行注释，....，.....]]
```

## 5.CMake基础命令

1. 指定最低版本

   ```cmake
   cmake_minimum_required(VERSION 3.0)
   #指定CMake的一个最低版本要求，可选，非必须，但不加会有警告
   ```

2. project
   定义工程名称，并可指定工程的版本、工程描述、web主页地址、所支持的语言（即用哪种语言去构建，默认是所有语言），如果不需要这些可以省略，只需要指出工程名即可。

   ```cmake
   project(<project name>
   		[VERSION <major>[.<minor>[.<path>]]]
   		[DESCRIPTION <project_description_string>]
   		[HOMEPAGE_URL <url-string>]
   		[LANGUAGE <language-name>]
   		)
   ```

3. 生成可执行程序
   比如由main.c,add.c,sub.c生成app可执行文件

   ```cmake
   add_executable(app main.c add.c sub.c)
   或者
   add_executable(app main.c;add.c;sub.c)
   ```

5. 构建系统生成路径
   当执行完CMake命令后，会在CMake命令执行的目录【不是CMakeLists.txt所在目录】生成一些中间文件比如`CMakeCache.txt`，`Makefile`,`cmake_install.cmake`等文件。
   
   ```bash
   cmake -Bbuild
   ```

## 6.CMake中set的使用

1. 为自定义变量赋值

   ```cmake
   #语法：
   set(VAR [VALUE] [CACHE TYPE DESCRIPTION[FORCE]])
   #举例：
   set(MyVar main.c add.c sub.c)
   add_executable(app ${MyVar})
   #注意：
   利用set赋值的变量值一切皆为字符串类型。
   ```

2. 位系统自带的宏赋值

   ```cmake
   1.
   #指定C++的标准。如设置为C++11，C++12
   set(CMAKE_CXX_STANDARD 11)
   set(CMAKE_CXX_STANDARD 12)
   
   #另外一种指定使用的C++标准，直接在命令行执行CMake命令时后面接参数
   cmake ./ -DCMAKE_CXX_STANDARD=11
   
   
   2.
   指定可执行文件的输出路径
   set(home /home/linux/demo)
   set(EXECUTABLE_OUTPUT_PATH ${home}/dir )
   ```

3. CMake接受其他值作为`add_library`的第二个参数的有效值，我们来看下本书会用到的值

   MODULE：又为DSO组。与  SHARED  库不同，它们不链接到项目中的任何目标，不过可以进行动态加载。该参数可以用于构建运行时插件。

   ```cpp
   // 动态加载插件
       void* handle = dlopen("./plugins/libmath_plugin.so", RTLD_LAZY);
       if (!handle) {
           printf("无法加载插件: %s\n", dlerror());
           return 1;
       }
   ```

   cmake --help-variable-list	这个命令会列出 CMake 中所有预定义的变量

# Docker

## 1.Docker介绍

### 1.起源

​	在传统的软件开发中，开发环境、测试环境和生产环境之间的差异是常见的问题。这种差异可能导致“在我的机器上可以运行，但在别人的机器上不行”的情况。Docker通过容器化技术，将应用程序及其依赖打包到一个独立的环境中，确保在任何支持Docker的系统上都能以一致的方式运行。

- 传统：通过大量的帮助文档，安装程序
- Docker：打包镜像发布测试，一键运行

​	个人理解是：比如在本地的Linux上开发了一个基于ARM的app，而该app用到了各种动态库，而这些动态库显然在编译时需要利用交叉编译，然后再把编译好的动态库，app可执行文件等各种配置依赖再放到运行着Linux的开发板上去。也就是当有很多开发板需要运行这个app时，每次都需要为这个开发板移植相同的配置环境，这很麻烦。而通过Docker技术，把app和依赖环境一起打包成一个容器，再放到各个开发板上去就可以直接运行了，就是所谓的“一次配置，处处运行”。![image-20250312164209682](figure\image-20250312164209682.png)

### 2.Docker与虚拟机技术的区别联系

​	虚拟机就是在window中装一个Vmware，通过这个软件我们可以虚拟出来一台或者多台电脑！（很笨重）虚拟机属于虚拟化技术，Docker容器技术，也是一种虚拟化技术。

- 传统的虚拟机，可以虚拟出一条硬件，运行一个完整的操作系统，在这个操作系统上安装和运行所需的软件
- 容器内的应用可以直接运行在宿主 主机的内核中，容器没有自己的内核，也不用虚拟硬件 （轻便）
- 每个容器是相互隔离的，每个容器内都有属于自己的文件系统，之间互不影响。
- Docker是内核级别的虚拟化，可以在一个物理机上运行很多的容器，让服务器的性能可以压榨到极致！

## 2.基本组成

​	Docker 使用客户端-服务器 (C/S) 架构模式。Docker 客户端会与 Docker 守护进程进行通信。Docker 守护进程会处理复杂繁重的任务，例如建立、运行、发布你的 Docker 容器。Docker 客户端和守护进程可以运行在同一个系统上，当然你也可以使用 Docker 客户端去连接一个远程的 Docker 守护进程。Docker 客户端和守护进程之间通过 socket 或者 RESTful API 进行通信。

### 1.Docker 守护进程

​	Docker 守护进程运行在一台主机上。用户并不直接和守护进程进行交互，而是通过 Docker 客户端间接和其通信。

### 2.Docker 客户端

​	Docker 客户端，实际上是 docker 的二进制程序，是主要的用户与 Docker 交互方式。它接收用户指令并且与背后的 Docker 守护进程通信，如此来回往复。

### 3.Docker 内部

- **镜像（Image）**——静态

  docker镜像就好比一个模板，我们可以通过这个模板来创建容器服务，通过这个镜像可以创建多个容器（最终服务运行或者项目运行就是在容器中的）。每一个镜像由一系列的层 (layers) 组成。Docker 使用 UnionFS 来将这些层联合到单独的镜像中。当你改变了一个 Docker 镜像，比如升级到某个程序到新的版本，一个新的层会被创建。因此，不用替换整个原先的镜像或者重新建立(在使用虚拟机的时候你可能会这么做)，只是一个新的层被添加或升级了。现在你不用重新发布整个镜像，只需要升级，层使得分发 Docker 镜像变得简单和快速。

- **容器（container）**——动态

  docker利用容器技术，独立运行一个或者一组应用通过镜像来创建启动，停止，删除，基本命令。，Docker 容器是 Docker 的运行部分。

- **仓库（repository）**

  仓库就是存放镜像（image）的地方，可以理解为代码控制中的代码仓库。仓库又可以分为公有仓库和私有仓库。

## 3.Docker安装

1. 卸载旧版本（如果存在）

   ```bash
   sudo apt-get remove docker docker-engine docker.io containerd runc
   ```

2. 更新apt包索引

   ```Bash
   sudo apt-get update
   ```

3. 安装必要的依赖包

   ```Bash
   sudo apt-get install apt-transport-https ca-certificates curl gnupg-agent software-properties-common
   ```

4. 添加Docker的官方GPG密钥

   ```bash
   curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
   
   curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
   #使用国内阿里云镜像源（国内用户推荐）
   ```

5. 设置稳定版仓库

   ```bash
   sudo add-apt-repository "deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable"#推荐使用国内镜像源，不然很有可能会连接超时
   ```

6. 再次更新apt包索引(因为前面增加了新连接，需要更新)

   ```bash
   sudo apt-get update
   ```

7. 安装最新版本的Docker Engine-Community和containerd

   ```bash
   sudo apt-get install docker-ce docker-ce-cli containerd.io
   ```

8. 验证Docker是否安装成功

   ```bash
   sudo docker run hello-world
   #这里hello-world是image的名字，执行此指令时，docker首先会在本地找是否有hello-world的镜像，如果有，则直接利用其创建容器，如果没有则去Docker Hub上找，找到下载到本地并创建容器，没找到则报错。
   ```



docker run -itd --name zgdev -v /home/zhangg/driver:/home/ubuntu -v /opt/ext-toolchain:/ext-toolchain smartchip-sdk-build:v0.9 bash
 2002  docker exec -it zgdev bash



cd lichee-smios-sdk/
    4  export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/ext-toolchain/bin
    5  ./set_board.sh jzq
    6  ./build.sh 
    7  ./build.sh pack
