# SQLite3

## 1.SQLite3介绍

- SQLite3是一种轻量级的关系型数据库管理系统（RDBMS），它以跨平台、零配置、服务器-less的方式存储数据。
- SQLite3不像其他常见的数据库管理系统，如MySQL或PostgreSQL那样需要一个独立的服务器进程，在应用程序内部直接操作文件来进行数据存储和读取。
- SQLite3非常适合于嵌入式设备和单机应用程序等场景，因为它不需要占用太多资源，也允许在不同的平台上运行。 
- SQLite3支持大多数SQL语法，并且还提供了一些高级功能，如触发器、存储过程等。

## 2.SQLite3优势

- 跨平台性：SQLite3可以在多种操作系统和编程语言下使用，包括Windows、Linux、macOS、iOS、Android等。
- 零配置：SQLite3的特点之一是不要求任何服务器或网络配置。只需将数据库文件嵌入应用程序即可轻松地访问数据
- 体积小：SQLite3的核心库非常小，通常只有几百KB，因此非常适合在资源受限或空间受限的系统中使用
- 支持SQL：SQLite3支持大多数标准SQL查询语言，使用户能够使用大多数传统数据库管理任务
- ACID兼容：SQLite3支持ACID（原子性、一致性、隔离性和持久性）事务处理，确保数据始终处于一致状态
- 高可靠性：SQLite3对于频繁读取和少量更新的场景，表现出色。由于其自动记录更改，以防止损坏和数据丢失
- 强大的API：SQLite3提供了一个简单易用的C语言API来操作数据库，同时也提供了大量的接口和工具
- 可扩展性：SQLite3允许用户创建自己的函数和存储过程，从而增加了其灵活性和可扩展性

## 3.SQLite3下载安装

- 下载SQLite3二进制文件：可以从SQLite网站的下载页面（[SQLite Download Page](https://www.sqlite.org/download.html)）下载适用于相应系统的SQLite3二进制文件

- 安装SQLite3二进制文件：

  - 对于Windows，只需运行安装程序并按照提示进行即可

   - 对于Linux，您需要使用包管理器来安装SQLite3软件包

     ```shell
     sudo apt-get update
     sudo apt-get install sqlite3
     ```
  
- 验证SQLite3是否已正确安装：

  - 在命令行终端上输入sqlite3命令并回车
  - 如果成功安装，则会进入SQLite3的命令行客户端

- 可选地，安装SQLite3 GUI工具：如果您需要一个GUI工具来管理SQLite3数据库，则可以使用一些第三方工具

  - SQLiteStudio
  - DBeaver
  - 这些工具可免费下载和使用

注意：安装sqlite3和安装sqlite3依赖库不是一个概念，安装sqlite3依赖库，需要执行`sudo apt-get install libsqlite3-dev`

## 4.SQLite3命令

| 命令                                | 说明                                           |
| ----------------------------------- | ---------------------------------------------- |
| .archive ...                        | 管理SQL归档文件                                |
| .auth ON&#124;OFF                   | 显示授权回调函数                               |
| .backup ?DB? FILE                   | 将数据库DB（默认为“main”）备份到FILE           |
| .bail on&#124;off                   | 在错误发生后停止。默认为OFF                    |
| .binary on&#124;off                 | 打开或关闭二进制输出。默认为OFF                |
| .cd DIRECTORY                       | 将工作目录更改为DIRECTORY                      |
| .changes on&#124;off                | 显示SQL更改的行数                              |
| .check GLOB                         | 如果自从.testcase以来的输出不匹配，则失败      |
| .clone NEWDB                        | 从现有数据库克隆数据到NEWDB中                  |
| .databases                          | 列出附加数据库的名称和文件                     |
| .dbconfig ?op? ?val?                | 列出或更改sqlite3_db_config()选项              |
| .dbinfo ?DB?                        | 显示有关数据库的状态信息                       |
| .dump ?TABLE? ...                   | 将所有数据库内容呈现为SQL                      |
| .echo on&#124;off                   | 打开或关闭命令回显                             |
| .eqp on&#124;off&#124;full&#124;... | 启用或禁用自动EXPLAIN QUERY PLAN               |
| .excel                              | 在电子表格中显示下一个命令的输出               |
| .exit ?CODE?                        | 以返回代码CODE退出此程序                       |
| .expert                             | 实验性功能。为查询建议索引                     |
| .explain ?on&#124;off&#124;auto?    | 更改EXPLAIN格式模式。默认值：auto              |
| .filectrl CMD ...                   | 运行各种sqlite3_file_control()操作             |
| .fullschema ?--indent?              | 显示模式和sqlite_stat表的内容                  |
| .headers on&#124;off                | 打开或关闭标题的显示                           |
| .help ?-all? ?PATTERN?              | 显示有关PATTERN的帮助文本                      |
| .import FILE TABLE                  | 将数据从FILE导入TABLE                          |
| .imposter INDEX TABLE               | 在索引INDEX上创建仿冒表TABLE                   |
| .indexes ?TABLE?                    | 显示索引的名称                                 |
| .limit ?LIMIT? ?VAL?                | 显示或更改SQLITE_LIMIT的值                     |
| .lint OPTIONS                       | 报告潜在的模式问题。                           |
| .load FILE ?ENTRY?                  | 加载扩展库                                     |
| .log FILE&#124;off                  | 打开或关闭日志记录。文件可以是stderr/stdout    |
| .mode colum                         | 列对齐模式                                     |
| .nullvalue STRING                   | 在NULL值的位置使用字符串STRING                 |
| .once (-e&#124;-x&#124;FILE)        | 仅将下一个SQL命令的输出发送到FILE              |
| .open ?OPTIONS? ?FILE?              | 关闭现有数据库并重新打开FILE                   |
| .output ?FILE?                      | 将输出发送到FILE，如果省略FILE，则发送到stdout |
| .parameter CMD ...                  | 管理SQL参数绑定                                |
| .print STRING...                    | 打印文本字符串STRING                           |
| .progress N                         | 在每个N操作码后调用进度处理程序                |
| .prompt MAIN CONTINUE               | 替换标准提示符                                 |
| .quit                               | 退出SQLite3的客户端                            |
| .read FILE                          | 从FILE读取输入                                 |
| .recover                            | 尝试从损坏的数据库中恢复尽可能多的数据。       |
| .restore ?DB? FILE                  | 从FILE还原数据库DB（默认为“main”）的内容       |
| .save FILE                          | 将内存中的数据库写入FILE                       |
| .scanstats on&#124;off              | 打开或关闭sqlite3_stmt_scanstatus()指标        |
| .schema ?PATTERN?                   | 显示与PATTERN匹配的CREATE语句                  |
| .selftest ?OPTIONS?                 | 运行在SELFTEST表中定义的测试                   |
| .separator COL ?ROW?                | 更改列和行分隔符                               |
| .session ?NAME? CMD ...             | 创建或控制会话                                 |
| .sha3sum ...                        | 计算数据库内容的SHA3哈希值                     |
| .shell CMD ARGS...                  | 在系统Shell中运行CMD ARGS...                   |
| .show                               | 显示各种设置的当前值                           |
| .stats ?on&#124;off?                | 显示统计信息或打开/关闭统计信息                |
| .system CMD ARGS...                 | 在系统Shell中运行CMD ARGS...                   |
| .tables ?TABLE?                     | 列出LIKE模式为TABLE的表名                      |
| .testcase NAME                      | 开始将输出重定向到“testcase-out.txt”           |
| .testctrl CMD ...                   | 运行各种sqlite3_test_control()操作             |
| .timeout MS                         | 尝试以MS毫秒为间隔打开已锁定表                 |
| .timer on&#124;off                  | 打开或关闭SQL计时器                            |
| .trace ?OPTIONS?                    | 在每个SQL语句执行时输出                        |
| .vfsinfo ?AUX?                      | 有关顶级VFS的信息                              |
| .vfslist                            | 列出所有可用的VFS                              |
| .vfsname ?AUX?                      | 打印VFS堆栈的名称                              |
| .width NUM1 NUM2 ...                | 设置“ column”模式的列宽度                      |
|                                     |                                                |

## 5.SQL语句

以下是SQLite3中常用的SQL语句：

1. 创建表格

   ```sqlite
   CREATE TABLE table_name (
     column_1 data_type constraints,
     column_2 data_type constraints,
     ...,
     column_n data_type constraints
   );
   ```

2. 删除表格

   ```sqlite
   DROP TABLE table_name;
   ```

3. 查询数据

   ```sqlite
   SELECT column_1, column_2, ..., column_n 
   FROM table_name;
   ```

3. 插入数据

   ```sqlite
   INSERT INTO table_name (column_1, column_2, ..., column_n)
   VALUES (value_1, value_2, ..., value_n);
   ```

4. 更新数据

   ```sqlite
   UPDATE table_name
   SET column_1 = value_1, column_2 = value_2, ..., column_n = value_n
   WHERE condition;
   ```

5. 删除数据

   ```sqlite
   DELETE FROM table_name WHERE condition;
   ```

## 6.SQLite3示例

以下是使用SQLite3创建一个名为“students”的学生信息表并插入三个学生信息的示例：

1.  打开`shell`命令行终端。 
2. 连接到SQLite3数据库文件。 

   ```bash
   $ sqlite3 mydatabase.db
   ```

3. 创建一个名为“students”的学生信息表。该表将包含以下列：ID，姓名，年龄，性别和成绩。

   ```sqlite
   sqlite> CREATE TABLE students (
      ...> ID INTERGER PRIMARY KEY NOT NULL,
      ...> name TEXT NOT NULL,
      ...> age INTEGER NOT NULL,
      ...> gender TEXT NOT NULL,
      ...> score REAL NOT NULL);
   ```

备注：`sqlite>`和`   ...>`是sqlite3的命令行提示符


```
sqlite> .table
students
```

如果没有创建成功，或者表被删除，将会什么也不显示，例如此时执行DROP语句，将看不到表了

```
sqlite> DROP TABLE students;
sqlite> .table
sqlite>
```

重复上面的`CREATE TABLE`（为了放便大家复制，粘贴后面把`sqlite3>`, `   ...>`都省略了）

```
CREATE TABLE students (
ID INTERGER PRIMARY KEY NOT NULL,
name TEXT NOT NULL,
age INTEGER NOT NULL,
gender TEXT NOT NULL,
score REAL NOT NULL);
```

4. 插入三个学生信息。例如：

```
INSERT INTO students (ID, name, age, gender, score)
   ...> values(1,'张三', 18, '男', 90.0);
INSERT INTO students (ID, name, age, gender, score)
values(2,'子涵', 18, '女', 88.5);
INSERT INTO students (ID, name, age, gender, score)
values(3, '张伟', 19, '男', 82.5);
```

这将向学生信息表中添加三条记录。每条记录都包含姓名、年龄、性别和分数等列的值。由于我们使用了自增长的主键列ID，因此每个记录都将在插入时自动被赋予一个唯一的ID值。

5. 确认学生信息已成功插入。可以使用`SELECT`语句来检索学生信息表中的所有行。例如：

```
select * FROM students;
1|张三|18|男|90.0
2|子涵|18|女|88.5
3|张伟|19|男|82.5
```

如果嫌弃这种界面，可以执行.headers on和.mode column，再执行SELECT语句，就好看了，如下图：

```sql
sqlite> .headers on
sqlite> .mode column
sqlite> select * FROM students;
ID          name        age         gender      score     
----------  ----------  ----------  ----------  ----------
1           张三          18          男           90.0      
2           子涵          18          女           88.5      
3           张伟          19          男           82.5  
```

6. 退出SQLite shell或关闭终端会话。

```
sqlite> .exit
```

## 7.sqlite3编程

### 1.打开数据库

```c
/*打开一个SQLite数据库文件*/
int sqlite3_open(
    const char *filename,   /*数据库文件的文件名，如果为 ":memory:" 则表示创建内存中数据库*/
    sqlite3 **ppDb          /*返回指向数据库连接句柄的指针*/
);
```

这个函数使用指定的数据库文件名（或 `:memory:`）打开一个新的数据库连接，并且把连接句柄返回给调用者如果连接成功，将会返回 `SQLITE_OK` 编码（0），否则将会返回其他错误代码。需要注意的是，SQLite 数据库文件不存在时将会自动创建。如果 `filename` 参数为 `NULL` ，该函数返回 `SQLITE_MISUSE` （错用 SQLite 调用）错误。`ppDb` 参数是一个二级指针，它将存储一个指向打开的数据库连接的指针，该指针需要在后续的 SQLite 操作中使用。例如，以下是在 C 语言中打开一个 SQLite 数据库的示例代码：

```c
#include <stdio.h>
#include <sqlite3.h>
int main() {
    sqlite3 *db;
	/*打开数据库*/
	int rc = sqlite3_open("test.db", &db);
	if (rc == SQLITE_OK) {
		printf("已成功打开数据库\n");
		sqlite3_close(db); // 关闭数据库连接
	} else {
		fprintf(stderr, "无法打开数据库: %s\n", sqlite3_errmsg(db));
		sqlite3_close(db);
		return 1;
	}
	return 0;
}
```

### 2.关闭数据库

```c
/*关闭指定数据库连接*/
int sqlite3_close(sqlite3*);
```

该函数接收一个被打开的数据库连接指针，如果成功关闭返回 `SQLITE_OK` 编码（0），否则返回其他错误代码。在使用完SQLite数据库连接之后，应该释放它以避免资源泄漏和内存占用。调用 `sqlite3_close()` 函数将关闭数据库连接，并释放所有相关的资源，包括已编译的语句等。如果在关闭连接之前还有未完成的事务，则会自动回滚这些事务。例如，以下是在 C 语言中关闭 SQLite 数据库连接的示例代码：

```c
#include <sqlite3.h>
int main() {
    sqlite3 *db;
    int rc = sqlite3_open("test.db", &db);
    // 执行一些数据库操作
    // ...
    rc = sqlite3_close(db);
    if (rc == SQLITE_OK) {
      printf("Closed database successfully\n");
  } else {
      fprintf(stderr, "Can't close database: %s\n", sqlite3_errmsg(db));
  }
    return 0;
}
```

### 3.执行SQL语句

`sqlite3_exec()` 函数用于在 SQLite 数据库连接上执行一条或多条 SQL 语句，并调用一个回调函数处理执行结果。该函数的原型如下：

```c
int sqlite3_exec(
    sqlite3* db,                               /* 执行 SQL 命令的数据库连接 */
    const char *sql,                           /* 待执行的 SQL 命令 */
    int (*callback)(void*,int,char**,char**),  /* 在执行命令时的回调函数 */
    void *,                                    /* 作为第一个参数传递给回调函数的指针 */
    char **errmsg                              /* 用于存储错误消息的指针 */
);
```

该函数接收一个打开的数据库连接 `sqlite3*`，待执行的 SQL 命令 `sql`，以及一个回调函数 `callback`，可以选择性地传递一个指向用户数据的指针作为回调函数的第一个参数，该句话的意思是，回调函数的参数列表（签名）决定了该函数在被调用时应接收哪些参数，并指定了它们的数据类型和顺序。回调函数必须符合以下格式：

```c
int (*callback)(void*, int, char**, char**);
```

- 第一个参数 `void*`，是使用者传递给 `sqlite3_exec()` 调用的 `void*` 参数。
- 第二个参数 `int`，是查询结果所返回的列数。
- 第三个参数 `char**`，是包含每个结果集元素值的字符串数组。一个字符数组代表一行，数组每个元素代表一个字符串，该字符串内容为该行每一列的值。
- 第四个参数 `char**`，是包含每个结果集元素的列名称的字符串数组。这通常会在 SELECT 语句中返回。

回调函数的返回值应为整数，并且通常全部返回0表示执行成功。如果需要提前终止查询或在回调函数过程中发现错误，可以返回非零值
`errmsg` 是用于保存 `sqlite3_exec()` 返回的错误消息的指针。
当函数成功执行 SQL 命令时，将会返回 `SQLITE_OK` 编码（0），否则将会返回其他错误代码。如果在执行命令时发生错误，则 `errmsg` 将被设置为一个非空值，其中包含有关错误的详细信息。如果 `errmsg` 未被设置，则表示该函数执行成功。

### 4.创建表

以下是一个使用 `sqlite3_exec()` 函数执行 SQL 命令的示例代码：

```c
#include <sqlite3.h>
#include <stdio.h>
int main(int argc, char* argv[]) {
	sqlite3 *db;
	char *zErrMsg = 0;
	int rc;
	/*打开数据库*/
	rc = sqlite3_open("test.db", &db);
	if (rc) {
		fprintf(stderr, "Can't open database: %s\n", sqlite3_errmsg(db));
		sqlite3_close(db);
		return 1;
	} else {
		fprintf(stdout, "Opened database successfully\n");
	}
	/*创建表的SQL语句*/
	char *sql = "CREATE TABLE IF NOT EXISTS COMPANY(" //表已经存在则打开表，表不存在则创建。
		"ID INT PRIMARY KEY     NOT NULL,"
		"NAME           TEXT    NOT NULL,"
		"AGE            INT     NOT NULL);";

	/*执行SQL语句*/
	rc = sqlite3_exec(db, sql, 0, 0, &zErrMsg);
	if (rc != SQLITE_OK) {
		fprintf(stderr, "SQL error: %s\n", zErrMsg);
		sqlite3_free(zErrMsg);
	} else {
		printf("Table created successfully\n");
	}
	/*关闭数据库文件*/
	sqlite3_close(db);
	return 0;
}
```

上述代码中，首先调用sqlite3_open()函数打开一个名为"test.db"的数据库连接，然后使用**CREATE TABLE语句**创建一张名为"COMPANY"的表格。该表格包含三列，分别是"id"、"name"和"age"**,**
		其中，id列被定义为主键（PRIMARY KEY），且不能为NULL。
		接下来，通过调用sqlite3_exec()函数执行SQL语句，
		将该语句传递给SQLite引擎进行解析和执行。
		如果执行成功，则输出"Table created successfully"，
		否则输出具体的错误消息。

### 7.3.2.使用sqlite3_exec()函数向表中插入数据

创建好表格以后我们就可以向其添加数据了：

```c
#include <sqlite3.h>
#include <stdio.h>

int main(int argc, char* argv[]) {
    sqlite3 *db;
    char *zErrMsg = 0;
    int rc;

	/*打开数据库*/
    rc = sqlite3_open("test.db", &db);
    if (rc) {
        fprintf(stderr, "Can't open database: %s\n", sqlite3_errmsg(db));
        sqlite3_close(db);
        return 1;
    } else {
        fprintf(stdout, "Opened database successfully\n");
    }

	/*创建表的SQL语句*/
    char *sql = "INSERT INTO COMPANY (ID,NAME,AGE) VALUES (1, '张三', 32);"
        "INSERT INTO COMPANY (ID,NAME,AGE) VALUES (2, '李四', 33);"
    	"INSERT INTO COMPANY (ID,NAME,AGE) VALUES (3, '王五', 30);"
    	"INSERT INTO COMPANY (ID,NAME,AGE) VALUES (4, '王博', 32);"
        "INSERT INTO COMPANY (ID,NAME,AGE) VALUES (5, '李为', 33);"
    	"INSERT INTO COMPANY (ID,NAME,AGE) VALUES (6, '赵倩', 30);";
    
    //类似于sprintf
    char sno[STRLEN],sname[STRLEN],sex[STRLEN],age[STRLEN],sdept[STRLEN];
    sql = sqlite3_mprintf("INSERT INTO student" 
						"(Sno,Sname,Sex,Age,Sdept) VALUES ('%s','%s','%s','%s','%s');",sno,sname,sex,age,sdept);


	/*执行SQL语句*/
    rc = sqlite3_exec(db, sql, 0, 0, &zErrMsg);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "SQL error: %s\n", zErrMsg);
        sqlite3_free(zErrMsg);
    } else {
        fprintf(stdout, "Records created successfully\n");
    }

	/*关闭数据库文件*/
    sqlite3_close(db);
    return 0;
}
```

在上述代码中，需要先调用sqlite3_open()函数打开数据库连接。然后，使用INSERT INTO语句将一条记录插入到"COMPANY"表格中。该记录包含三个字段，分别是"id"、"name"和"age"，对应的值分别为1、'张三'和32。最后，通过sqlite3_exec()函数执行SQL语句，并根据返回值判断操作是否成功。

### 7.3.3.使用sqlite3_exec()函数查询数据

```c
#include <sqlite3.h>
#include <stdio.h>

// 回调函数
int callback(void *data, int argc, char **argv, char **azColName) {
    int i;
    printf("callback:\n");
    for(i = 0; i < argc; i++) {
       printf("%s = %s\n", azColName[i], argv[i] ? argv[i] : "NULL");
   }
    printf("\n");

    return 0;
}

int main () {
    sqlite3 *db;
    char *zErrMsg = 0; // 存储错误消息的指针
    int rc;

    rc = sqlite3_open("test.db", &db);
    if (rc != SQLITE_OK) {
       fprintf(stderr, "Can't open database: %s\n", sqlite3_errmsg(db));
       sqlite3_close(db);
       return 1;
   }

    const char* sql = "SELECT * from COMPANY";
    rc = sqlite3_exec(db, sql, callback, NULL, &zErrMsg);//callback表单有几行就会被调用几次

    if (rc != SQLITE_OK) {
       fprintf(stderr, "SQL error: %s\n", zErrMsg);
       sqlite3_free(zErrMsg);
   } else {
       printf("Operation done successfully\n");
   }

    sqlite3_close(db);
    return rc;
}
```

在此示例中，我们定义了一个回调函数 `callback()`，该函数用于处理 `sqlite3_exec()` 执行结果。接下来，我们打开一个名为 "test.db" 的 SQLite 数据库连接，并执行 SELECT 命令。最后，我们通过检查 `rc` 和 `zErrMsg` 的返回值，判断查询是否成功并处理执行结果。

## 7.4.void *data的作用是什么？

void *data是sqlite3_exec()函数的第四个参数，它是一个用户定义的指针类型，提供了一个通用的方法来传递额外的数据给回调函数。sqlite3_exec()函数的高级用法
示例代码：

```c
#include <sqlite3.h>
#include <stdio.h>

// 回调函数
int callback(void *data, int argc, char **argv, char **azColName) {
	int i;
	if(argv[0][0] == '1')
		printf("%s\n", (char *)data);
	for(i = 0; i < argc; i++) {
		printf("%s\t", argv[i] ? argv[i] : "NULL");
	}
	printf("\n");

	return 0;
}

int main () {
	sqlite3 *db;
	char *zErrMsg = 0; // 存储错误消息的指针
	int rc;

	rc = sqlite3_open("test.db", &db);
	if (rc != SQLITE_OK) {
		fprintf(stderr, "Can't open database: %s\n", sqlite3_errmsg(db));
		sqlite3_close(db);
		return 1;
	}

	char *str = "ID\t名字\t年龄";
	char *sql = "SELECT * from COMPANY";
	rc = sqlite3_exec(db, sql, callback, str, &zErrMsg);

	if (rc != SQLITE_OK) {
		fprintf(stderr, "SQL error: %s\n", zErrMsg);
		sqlite3_free(zErrMsg);
	} else {
		printf("Operation done successfully\n");
	}

	sqlite3_close(db);
	return rc;
}
```

#