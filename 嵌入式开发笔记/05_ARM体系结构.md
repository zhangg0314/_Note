# >>>>>>计算机硬件基础>>>>>>

# 1.嵌入式系统分层

- **操作系统的作用**
  向下管理硬件，向上提供接口(API)
  
- **应用开发**
  即使用系统提供的接口（API）,做上层应用程序的开发
  
- **底层开发**：
  即做操作系统本身的开发,即实现系统提供给上层的接口
  
- **Linux层次结构**
  进程管理，内存管理，文件系统，**设备管理**，网络协议
  本课程的方向是做Linux的设备控制开发。
  
- **Linux子系统**
    1.进程管理（内核内部实现）：管理进程的创建、调度、销毁等

    2.内存管理（内核内部实现）：管理内存的申请、释放、映射等

    3.文件系统（内核内部实现）：管理和访问磁盘中的文件

    4**.设备管理（我们自己实现）：硬件设备及驱动的管理**

    5.网络协议（内核内部实现）：通过网络协议栈(TCP、IP...)进行通信

# 2 .ARM体系结构与接口技术

SOC:片上系统,即一块板子 = CPU + 外围硬件![image-20240728153912808](C:\Users\z3254406361\AppData\Roaming\Typora\typora-user-images\image-20240728153912808.png)

## 2.1 ARM体系结构

介绍CPU的工作原理等

存储模型，工作模式，寄存器，异常机制，流水线，（汇编）指令集

## 2.2 接口技术

介绍CPU如何控制外围硬件

对硬件的控制：GPIO,PWM,UART,ADC,RTC,IIC

# 3.计算机基础知识

## 3.0.冯诺依曼和哈佛结构的区别与联系

1. 存储器结构
   - **冯诺依曼结构**：将程序指令存储器和数据存储器合并在一起，指令和数据存储在同一个存储器中，使用相同的地址空间。这种结构下，CPU在执行指令时需要从存储器中取出指令和数据，且指令和数据共享同一总线进行传输。
   - **哈佛结构**：使用两个独立的存储器模块，分别存储指令和数据，每个存储器有独立的地址空间。这种结构下，指令和数据使用不同的总线进行传输，从而提高了数据传输的效率和并行性。
2. 数据传输方式
   - **冯诺依曼结构**：指令和数据共享同一总线，数据传输时可能存在冲突，影响执行效率。
   - **哈佛结构**：指令和数据使用不同的总线进行传输，可以并行读取指令和数据，提高了执行效率。
3. 执行效率
   - **冯诺依曼结构**：由于指令和数据共享同一存储空间，且通过同一总线传输，可能导致在执行过程中存在取指和取数的冲突，从而影响执行效率。
   - **哈佛结构**：由于指令和数据分别存储在独立的存储器中，并通过不同的总线传输，可以并行处理指令和数据，从而提高了执行效率。
4. 灵活性
   - **冯诺依曼结构**：由于指令和数据共享存储空间，可以更灵活地修改和更新程序。
   - **哈佛结构**：由于指令和数据分别存储在独立的存储器中，修改程序时需要分别修改指令和数据存储器，相对不太灵活。

### 联系

1. **共同目标**：两者都是计算机体系结构的组织方式，旨在提高计算机的执行效率和性能。
2. **历史背景**：冯诺依曼结构和哈佛结构都可以追溯到计算机发展的早期阶段，并对后续的计算机体系结构设计产生了深远的影响。
3. **实际应用**：在现代计算机系统中，冯诺依曼结构和哈佛结构都有其应用场景。例如，冯诺依曼结构广泛应用于桌面端计算机（如X86架构），而哈佛结构则在移动领域（如ARM架构）占据重要地位。

综上所述，冯诺依曼结构和哈佛结构在存储器结构、数据传输方式、执行效率和灵活性等方面存在显著差异。然而，它们都是计算机体系结构中重要的组织方式，各自在特定的应用场景下具有独特的优势和价值。

## 3.1.总线

总线是计算机中各个部件之间传送信息的公共通信干线, 在物理上就是一束导线按照其传递信息的类型可以分为数据总线、地址总线、控制总线.

数据总线，地址总线，控制总线，DMA总线（直接访问存储器，不需要经过cpu）
![image-20240728150149533](C:\Users\z3254406361\AppData\Roaming\Typora\typora-user-images\image-20240728150149533.png)

## 3.2.多级存储结构与地址空间

### 3.2.1. 三级存储结构

1. Cache,主存储器（按字节，断电丢失），辅助存储器（按块）

2. cpu能直接读写cache和主存储器,不能直接访问辅助存储器

### 3.2.2.地址空间

虽然主存储器空间够大，但并不意味着cpu也能读这么大的内存，主要还是看地址总线有几根，才能决定cpu的访存空间有多大，这部分能读的空间叫做cpu的地址空间或者寻址空间。

一个处理器能够访问（读写）的存储空间是有限的,我们称这个空间为它的地址空间（寻址空间）,一般来说N位地址总线的处理器的地址空间是2的N次方

## 3.3.cpu工作原理概述

![image-20240728150425593](C:\Users\z3254406361\AppData\Roaming\Typora\typora-user-images\image-20240728150425593.png)

- 每执行一条指令后PC的值会自动增加指向下一条指令

- 一条指令的执行分为三个阶段

  1.**取址**：

   CPU将PC寄存器中的地址发送给内存，内存将其地址中对应的指令返回到CPU中的指令寄存器（IR）

    2.**译码**：

   译码器对IR中的指令进行识别，将指令（机器码）解析成具体的运算

    3.**执行**：

   控制器控制运算器中对应的运算单元进行运算，运算结果写入寄存器

# ——ARM（Cortex-A）体系结构——

# 1.ARM体系结构理论基础

ARM，x86指的是处理器，CortexA8 ,A9指的是是指令集架构，简称架构，架构不一样，指令集也不一样

## 1.1.ARM处理器概述

- RISC处理器（ARM处理器，reduced精简指令集）
  	只保留常用的简单指令，硬件结构简单，复杂操作一般通过简单指令的组合实现，一般指令长度固定，且多为单周期指令。
  	RISC处理器在功耗，体积，价格等方面有很大优势，所以在嵌入式移动终端领域应用极为广泛。
- CISC处理器（X86处理器，complex复杂指令集）
      不仅包含了常用指令，还包含了很多不常用的特殊指令，硬件结构复杂，指令条数较多，一般指令长度和周期都不固定
      CISC处理器在性能上有很多优势，多用于PC及服务器等领域。

## 1.2.ARM指令集概述

- **指令**
  	能够被cpu直接认识且能够执行的以机器码的方式存在的命令称为指令。一条指令对应一条汇编。
  
- **指令集**
      处理器能识别的指令的集合称为指令集。
      不同架构的处理器指令集不同。
      指令集是处理器为开发者提供的接口。ADD,SUB，MUL等
  
- **ARM指令集（ARM支持）**
      所有指令都占用32bit存储空间。代码灵活度高，简化了解码复杂度.执行ARM指令集时PC每次自增4
  
- **Thumb指令集（ARM支持）**
      所有指令都占16bit存储空间。代码密度高，节省存储空间。每次执行完指令PC自增2
  
- **编译原理**
      机器码（不可移植）----汇编语言（不可移植）----高级语言（可移植）
  
-  **不可移植**

  ​	机器码0101在ARM表示加，但在X86里面加是1100，同理在X86里面有乘MUL，但在ARM里面没有乘法MUL。

  ​    **gcc**:把高级语言编译成X86指令。

  ​    **arm-gcc**:把高级语言编译成ARM指令。

# 2.ARM存储模型

## 2.1.ARM数据存储

- ARM采用32位架构,有以下三种数据类型
  Byte			8bits
  Halfowrd	16bits
  Word			32bits
- 数据存储
  **word**型数据在内存的**起始地址**必须是**4的整数倍**。
  **Halfword**型数据在内存的**起始地址**必须是**2的整数倍**。
- ARM一般使用小端对齐

## 2.2.ARM指令存储

- 处理器处于ARM状态时

  ​	所有指令在内存的起始地址必须是4的整数倍。

  ​	PC的值由 [31:2]位决定，[1:0]未定义，由于4的倍数的最低2位一定是0.

  ​	<!--注意:当为PC的值自定义时，如果给的值不是4的倍数，翻译成机器码后会被强制转为4的倍数-->

- 处理器处于Thumb状态时
      所有指令在内存的起始地址必须是2的整数倍。
      PC的值由 [31:1]位决定，[0]未定义，由于2的倍数的最低1位一定是0.

# 3.ARM工作模式

## 3.1.八种基本的工作模式

- **User**[10000]用户模式
  **非特权模式**，一般在执行上层的应用程序时ARM处于该模式，操作系统的内核态和用户态与此处处理器的用户模式不是一个概念，一个针对操作系统，一个针对CPU，⽤户模式是⽤户程序的⼯作模式，它运⾏在操作系统的⽤户态，它没有权限去操作其它硬件资源，只能 执⾏处理⾃⼰的数据，也不能切换到其它模式下，要想 访问硬件资源或切换到其它模式只能通过软中断或产⽣异常。
- **FIQ[10001]**快速中断模式
  快速中断模式是相对⼀般中断模式⽽⾔的，它是⽤来处理对时间要求比较紧急的中断请求，主要⽤于⾼速数据传输及通道处理中。快速中断有许多（R8~R14）⾃⼰的专⽤寄存器，发⽣中断时，使⽤⾃⼰的寄存器就避免了保存和恢复某些寄存器。如果异常中断处理程序中使⽤它⾃⼰的物理寄存器之外的其他寄存器，异常中断处理程序必须保存和恢复这些寄存器。
- **IRQ**一般中断模式
  ⼀般中断模式也叫普通中断模式，是低优先级中断，⽤于处理⼀般的中断请求，通常在硬件产⽣中断信号之后⾃动进入该模式，该模式为特权模式，可以⾃由访问系统硬件资源。
- **SVC**复位**或者**软中断
  管理模式是CPU上电后默认模式，因此，在该模式下主要⽤来做系统的初始化。
  软中断处理也在该模式下。当⽤户模式下的⽤户程序请求使⽤硬件资源时，通过软件中断进入该模式。
- **Abort**终止模式
  中⽌模式⽤于⽀持虚拟内存或存储器保护，当⽤户程序访问非法地址，没有权限读取的内存地址时，会进入该模式，linux下编程时经常出现的segment fault通常都是在该模式下抛出返回的
- **UNDEF**未定义模式
  未定义模式⽤于⽀持硬件协处理器的软件仿真，CPU在指令的译码阶段不能识别该指令操作时，会进入未定义模式。
- **SYS**系统模式
  系统模式是特权模式，不受⽤户模式的限制。⽤户模式和系统模式共⽤⼀套寄存器，操作系统在该模式下可以⽅便的访问⽤户模式的寄存器，⽽且操作系统的⼀些特权任务可以使⽤这个模式访问⼀些受控的资源。
  ⽤户模式与系统模式两者使⽤相同的寄存器，都没有SPSR（Saved Program Statement Register，已保存程序状态寄存器），但系统模式比⽤户模式有更⾼的权限，可以访问所有系统资源。
- **monitor**：为了安全而扩展出的用于执行安全监控代码的模式

## 3.2.工作模式总结

- 不同模式拥有不同权限，用户模式权限最低，保护系统安全
  所谓特权模式，即具有如下权利： 
  a. MRS（把状态寄存器的内容放到通⽤寄存器）； 
  b. MSR（把通⽤寄存器的内容放到状态寄存器中）。 
  由于状态寄存器中的内容不能够改变，因此，要先把内容复制到通⽤寄存器中，然后修改通⽤寄存器中的内容，再把通⽤寄存器中的内容复制给状态寄存器中，即可完成“修改状态寄存器”的任务。
- 不同模式执行不同代码，如刚启动时进入SVC执行一些初始化代码
- 不同模式实现不同功能

- 不同模式使用不同寄存器

## 3.3.分类模式分类

- 按照权限分：user未非特权模式，其余全为特权模式
- 按照状态分：FIQ , IRQ, SVC, Abort，Undef属于异常模式.

# 4.ARM寄存器

## 4.1.概念

寄存器是处理器内部的存储器，没有地址，只能是整型，不能是浮点型，只能是局部数据，不允许全局。

特点：在某个特定模式下只能使用当前模式下的寄存器，一个模式下特有的寄存器其他模式下不能使用。

作用：一般用于暂时存放参与运算的数据和运算结果

分类：包括**通用寄存器**，**专用寄存器**（PC，IR），**控制寄存器**![image-20240728154655367](C:\Users\z3254406361\AppData\Roaming\Typora\typora-user-images\image-20240728154655367.png)

带三角形的表示该模式下特有的寄存器，是新的一个，如r13_fiq,r13_svc和r13是三个不一样的寄存器**。数一下一共有40个寄存器**。

## 4.2.寄存器分类

- **通用寄存器**
  r0~r14(15) + r8_fiq~r14_fiq(7)+r13_svc~r14_svc(2) +... + .... = 32

  **R14**:(LR,Link Register）

  1.执行跳转指令(BL/BLX)时，LR会**自动**保存跳转指令下一条指令的地址，程序需要返回到发生跳转的那个地方时将LR值复制到PC即可实现。（主动情况）

  2.产生异常时，相当于异常中断处理，处理完后自动返回原先的位置继续往下执行程序。（被动情况）

  **R13**：(SP,Stack Pointer)
  栈指针，用于存储当前模式下栈的**栈顶**地址。
  栈的本质就是一段内存空间，存的是一些临时数据比如局部变量，函数参数，函数返回值等。

- **专用寄存器**
  **R15**:(PC，program counter):程序计数器，存储当前取址指令的地址，可以自动增加4修改，也可以手动人为修改。

  **CPSR**：固定用作控制寄存器——**当前程序状态寄存器**。

  ![image-20240728154832224](C:\Users\z3254406361\AppData\Roaming\Typora\typora-user-images\image-20240728154832224.png)
  **Bit[0:4]模式位**:表示不同工作模式，如[10000]user,[10001]FIQ,[10010]IRQ等  ————八种工作模式

  **Bit[5]状态位**：[0]ARM状态和[1]Thumb状态————两种工作状态

  **Bit[6]**:FIQ，[0]开启，[1]禁止
  **Bit[7]**:IRQ， [0]开启，[1]禁止	

  注意：svc模式初始化时，FIQ,IRQ一定是关闭状态。

  **Bit[31:28] NZCV**：
  ​	31位：结果为负数时，此位**自动**置1，否则为0

  ​	30位：结果产生0，此为**自动**置1，否则位0

  ​	29位:加法进位**自动**置1，否则置0；减法借位自动置0,否则为1

  ​	28位:产生符号位进位和借位，针对于**有符号**数。即符号位后面的数值位相加太大的进位或相减不过减时的借位把符号位给变了。

# 5.ARM异常处理

## 5.1.异常概念

处理器在正常执行程序的过程中可能会遇到一些不正常的事件发生,这时处理器就要将当前的程序暂停下来转而去处理这个异常的事件,异常事件处理完成之后再返回到被异常打断的点继续执行程序,异常不是错误。


## 5.2 .ARM异常处理机制

不同处理器对异常的处理流程大体相似，但是不同的处理器在具体实现的机制上有所不同；
1)比如处理器遇到哪些事件认为是异常事件，
2)遇到异常事件之后处理器有哪些动作，
3)处理器如何跳转到异常处理程序，
4)如何处理异常等，
这些**细节**的实现称为处理器的异常处理机制。

## 5.3.异常源(哪些为异常事件)

导致异常产生的事件称为异常源，ARM异常源：

- FIQ：快速中断请求
- IRQ：外部中断请求
- Reset：复位
- SWI:软中断
- data abort：数据终止，地址不对，或所给地址没权限访问
- prefetch abort：指令预取终止，如地址不对，或所给地址没有指令
- undefined instruction：遇到不能处理的指令

## 5.4.异常模式（遇到异常后的动作）

ARM遇到异常后会切换到对应的异常模式。

- FIQ模式->FIQ异常源
- IRQ模式->IRQ异常源
- SVC模式->reset 和swi异常源
- Abort模式->data abort和prefetch abort异常源
- Undef模式->undefined instruction异常源

## 5.5.ARM产生异常后的动作（自动完成）

1. 拷贝CPSR中的内容到对应异常模式下的SPSR\_<异常模式名>
2. 修改CPSR的值
   2.1.修改中断禁止位禁止同级或者低级的中断再来中断，但可以被高级中断再次打断。
   2.2.修改模式位进入对应的异常模式
   2.3.修改状态位进入ARM状态。
3. 保存返回地址到对应异常模式下的LR\_<模式名>
4. 设置PC为相应的异常向量(异常向量表对应的地址)，改了PC就可以跳转了。![image-20240720160748278](C:\Users\z3254406361\AppData\Roaming\Typora\typora-user-images\image-20240720160748278.png)

## 5.6.ARM异常返回的地址（自己编写）

下列操作是写在异常处理程序中的。

1. 将SPSR\_<模式名>的值复制给CPSR使处理器恢复之前的状态。
2. 将LR\_<模式名>的值复制给PC。使程序跳转回被打断的地址继续执行。

## 5.7.异常优先级

多个异常同时产生时的服务顺序，优先级从上往下依次递减

```txt
Reset
Data Abort
FIQ
IRQ
Prefetch Abort
Software Interrupt
Undefined instruction
```

## 5.8.IRQ异常举例![image-20240720162228977](C:\Users\z3254406361\AppData\Roaming\Typora\typora-user-images\image-20240720162228977.png)

## 5.9.FIQ和IRQ

**FIQ的响应速度比IRQ快**

1. FIQ在异常向量表位于最末
   可直接把异常处理写在异常向量表之后，省去跳转
2. FIQ模式有5个私有寄存器(R8-R12)
   **执行中断处理程序前无需压栈保存寄存器，可直接处理中断**
3. FIQ的优先级高于IRQ
   3.1 两个中断同时发生时先响应FIQ
   3.2 FIQ可以打断RIQ，但IRQ不能打断FIQ

# 6.ARM流流水线

## 6.1.指令流水线

取址-译码-执行三个步骤形成流水线，虽然流水线级数越来越多，但**都是在三级流水线上进行了细分而已**。

## 6.2.PC的作用

不管几级流水线，PC指向的永远是当前正在取指的指令，而正在执行的指令的地址为PC-8。

## 6.3.注意点

指令流水线机制的引入确实能够大大的提升指令执行的速度，但在实际执行程序的过程中很多情况下流水线时是无法形成的。比如芯片刚上电的前两个周期、执行跳转指令后的两个周期等。所以指令流水线的引入以及优化只能使平均指令周期不断的接近1而不可能真正的达到1，且流水线级数越多芯片设计的复杂程度就越高，芯片的功耗就越高。

# ARM指令集

## 1.汇编基础

- **指令**：能够编译生成一条32bit机器码，并且能够被cpu识别和执行
- **伪指令**：本身不是指令，编译器能够将其替换成若干条指令，如3x3翻译常3+3+3
- **伪操作**：不会生成指令，只是在编译阶段告诉编译器怎么编译，类似于C的#ifdef,#endif

## 2.汇编与C语言

- **汇编**
  每条汇编都会唯一对应一条机器码，且CPU能直接识别和执行，即汇编中所有的指令都是CPU能够识别和执行的。
  汇编中寄存器的使用、栈的分配与使用、程序的调用、参数的传递等都需要自己维护

- **C语言**
  每条C语句都要被编译器编译成若干条汇编指令才能被CPU识别和执行，即C语句中的指令CPU不一定能直接识别，需要编译器进行“翻译”。
  C中寄存器的使用、栈的分配与使用、程序的调用、参数的传递等都是编译器来分配和维护。

## 3.基本指令

### 3.1.数据处理指令

- 数据搬移指令

  ```asm
  MOV R1,#1
  MOV R2,R1
  MVN R0，#0xFF//先把0xFF按位取反，再搬到R0，R0=~0xFF
  
  
  @立即数，本质就是包含在指令当中的数，是指令的一部分。不像变量那样独占一个空间，故读取时在读指令的时候就读了，不必单独访存，因此速度更快。但缺点就是：不能是任意的32位的数字，有局限性。
  MOV R0,#0X12345678//机器码才32位，一个占32位的数都超了肯定报错
  MOV R0,#0X12//把能够放到寄存器的数叫做立即数
  MOV R0,#0XFFFFFFFF(虽然数值远远大，但编译不报错，因为它会被翻译成MVN，只有效果一样即可) == MVN R0,0X00000000
  ```

- 数据运算指令

  ```asm
  @数据运算指令格式
  @《操作码》《目标寄存器》《第一操作寄存器，只能是寄存器》《第二操作数，可以是寄存器也可以是立即数》
   1.ADD 加
      	ADD R1,R2,R3 @R1 = R2 + R3
      	ADD R1,R2,#5 @可以
      	ADD R1,#5,#6 @error
      	ADD R1,#5,R2 @error
   2.SUB 减
      	SUB R1,R2,R3
      	@R1 = R2 - R3
   3.RSB 逆向减法，解决SUB不能实现R1 = 立即数 - R2的问题
      	RSB R1,R2,#3 
      	@R1 = 3 - R2
   4.MUL 乘法指令
      	MUL R1,R2,R3
      	@R1 = R2 * R3
      	MUL R1,R2,#3//error，乘法指令不能用立即数
  ```

- 位运算

  ```asm
  1.AND 按位与
      AND R1,R2,R3 @R1 = R2 & R3
  2.ORR 按位或
  3.EOR 按位异或
  4.LSL 左移指令
     	LSL R1,R2,R3 @R1 = (R2 << R3)
  5.LSR 右移指令
  6.BIC 位清0
      BIC R1,R2,#0xF @R2本身不变，R1的值变为R2的某些位被清0后的结果，某些位是指#0xFF哪些位为1，就清哪些位
  7.MOV R1,R2,LSL,#1 @R1 = (R2 << 1)
  ```

- 数据运算指令对条件位(N,Z,C,V)的影响

  ```asm
  @默认情况下数据运算不会对条件位参数影响，当在指令后加后缀S后可以影响
  _________________________________________
  MOV R1,#3
  SUBS R2,R1,#5
  _________________________________________
  @64bit分两次算，一次只能算32bit
  @ADDS影响条件位，ADC计算时带进位，ADCS不仅计算时带进位，而且计算后的结果也影响条件位。
  @ADC R6,R2,R4
  @R6 = R2 + R4 + 'C' 
  ____________________________________________
  SBC R6,R2,R4
  @ R6 = R2 - '!c' - R4
  ____________________________________________ 
  ```

### 3.2.跳转指令

实现程序的跳转，本质就是修改了PC寄存器。

1. 方式一：直接修改PC的值

   ```asm
   MOV PC,#0x18
   @但需要我们自己去计算绝对地址，很麻烦。
   ```

2. 方式二：不带返回的跳转指令

   ```asm
   MAIN:
   	......
   	B FUNC
   	......
   FUNC:
   	......
   	......
   @本质就是将PC寄存器的值修改成跳转标号下第一条指令的地址
   ```

3. 方式三：带返回的跳转指令

   ```asm
   BL FUNC
   @本质是将PC寄存器的值修改成跳转标号下第一条指令的地址，同时将跳转指令下一条指令的地址存储到当前模式下的LR
   ```

4. 方式四：带条件的跳转，但不带返回

   ```asm
   CMP R1,R2
   BEQ FUNC 
   @CPU先看Z是否置1，如果是，则跳转FUNC
   @EQ为条件码
   @不带返回
   ```

**ARM条件码**

后缀，ARM大多数指令均可以加后缀。![image-20240722163853728](C:\Users\z3254406361\AppData\Roaming\Typora\typora-user-images\image-20240722163853728.png)

```asm
CMP R1,R2
@比较R1,R2的数，本质是SUBS R1,R2，并根据比较结果设置N,Z,C,V
BEQ FUNC
MOVEQ R3,#3
```

### 7.3.3.Load/Store指令

访问（读写）内存

```asm
@读内存
LDR R3,[R2] @将内存中R2指向的内存空间中的数据读取到R3

@写内存
STR R1,[R2] @将寄存器的R1的数存在R2指向的内存空间，也验证了大小端问题


STRB R1,[R2]@只存一个字节,优先写低位
STRH R1,[R2]@HALFWORD
STR R1,[R2] @默认是一个字
```

## 7.4.ARM指令寻址方式

寻址方式就是CPU去寻找一个数的操作方式。

- **立即寻址**：也叫立即数寻址，数来自于机器码
- **寄存器寻址**：数来自寄存器
- **寄存器移位寻址**：数来自一个寄存器中的数做了移位操作后的结果
- **寄存器间接寻址**：数来自内存
- **基址加变址寻址**：[R2,R3]数来自内存中地址==[R2] + [R3]的地方
- **基址加变址寻址的索引方式**：前索引，后索引，自动索引

```asm
MOV R1,[R2,#8]  @ R1 = *(R2+8),R2 = R2,前索引
MOV R1,[R2],#8  @ R1 = *(R2),R2 = R2 + 8,后索引
MOV R1,[R2,#8]! @ R1 = *(R2+8),R2 = R2 + 8,自动索引
```

## 7.5.多寄存器内存访问指令

```asm
STM R11,{R1-R4}@将R1-R4中的值存到以[R11]为首地址的内存区域
LDM R11,{R6-R9}@将内存中以[R11]为首地址的数据读取到R6-R9寄存器
STM R11,{R1,R2,R4}@以逗号分隔不连续的情况
STM R11,{R2,R4,R1}@不管寄存器列表中的顺序如何，存储时永远是低地址存储小编号的寄存器

@自动索引照样适用于多寄存器内存访问指令
STM R11!,{R1-R4} @R11自动增，增的量为存的数据的总大小，如存16个字节数据，地址加增加16


@多寄存器内存访问指令寻址方式
STMIA R11!,{R1-R4}@即默认情况，等价于不加后缀，IA，increase after
STMIB R11!,{R1-R4}@先在指定地址基础上加4个字节，然后再开始存，IB，increase before
STMDA R11!,{R1-R4}@D,decrease
STMDB R11!,{R1-R4}
```

## 7.6.栈

SP寄存器-->栈的位置

### 7.6.1.概念

栈的本质就是一段内存，程序运行时用于保存一些临时数据。如局部变量，函数参数，返回值等。

### 7.6.2.栈的分类

针对于压栈时的特点

- 增栈--存数据时，SP往高地址方向移动。

- 减栈--存数据时，SP往低地址方向移动。

- 满栈：栈指针指向最后一次压入到栈中的数据，压栈时需要先移动栈指针到相邻位置再压栈

- 空栈：栈指针指向最后一次压入到栈中的数据的相邻位置，压栈时可以直接压栈，之后需要将栈指针移动到相邻位置。
- EA（空增栈）,ED,FA,FD（满减栈），**ARM一般使用满减栈，用STMDB进行压栈，STMIA出栈**

```asm
STMFD @等价于 STMDB，更简单
LDMFD @等价于 STMIA，更简单
```

### 7.6.3.应用

```asm
@初始化栈
	MOV SP,#0x40000000
MAIN:
	MOV R1,#3
	MOV R2,#5
	BL FUNC 
	ADD R3,R1,R2
	B STOP
FUNC:
	@压栈保护线程
	STMFD SP!,{R1,R2}
	MOV R1,#10
	MOV R2,#20
	SUB R3,R2,R1
	@出栈恢复现场
	LDMFD SP!,{R1,R2}
	MOV PC,LR
STOP:
	B STOP
@叶子函数，位于函数调用递归树的最末端，对于叶子函数，不需要进行LR的压栈保护，对于非叶子函数要压栈保存通用寄存器和LR寄存器的值

@出栈时，内存中该位置的值并未被清除，仅仅只是栈指针移动，又因为C语言局部变量也是压入栈中，故局部变量不初始化会有不确定的值。
```

## 7.ARM专用指令

与C语言无关，即C语言不会被编译成的汇编指令。

- **状态寄存器传送指令**

   用于访问（读写）CPSR寄存器

   ```asm
   @读CPSR
   MRS R1,CPSR @R1 = CPSR
   
   @写CPSR
   MSR CPSR,#0x10 
   
   @在USER模式下不能修改CPSR,非特权模式
   ```

- **软中断指令**

   给cpu发生软中断信号

   ```asm
   SWI #1
   @软中断指令：触发软中断
   	@异常向量表
   	B MAIN
   	B .
   	B SWI_HANDLER     @0x08
   	B .
   	B .
   	B .
   	B .
   	B .
   @应用程序
   MAIN:
   	MSR CPSR,#0x10
   	MOV R1,#1
   	MOV R2,#2
   	SWI #1     @置PC为异常向量表的SWI即0x08地址
   	ADD R3, R2,R1
   	B STOP
   @异常处理程序
   SWI_HANDLER:
   	@压栈保护现场
   	STMFD SP! {R1,R2,LR}
   	...
   	...
   	@出栈恢复现场
   	...
   	LDMFD SP! {R1,R2,PC}^ @^的作用就是把SPSR赋值给CPSR
   
   STOP:
   	B STOP
   ```

- **协处理器指令**

   操控协处理器的指令
   
   ```asm
   @1.协处理器数据运算指令
   	CDP
   @2.协处理器存储器访问指令
   	STC @将协处理器中的数据存到存储器
   	LDC @将存储器中的数据读取到协处理器
   @3.协处理器寄存器传送指令
   	MRC @协处理器的寄存器到ARM的寄存器
   	MCR @ARM的寄存器协到处理器的寄存器
   ```

## 8.伪指令

```asm
NOP @空指令，等价于MOV R0,R0，虽然不执行，但也消耗一个指令周期
	
LDR R1,[R2] @此格式表示的是指令
LDR R1,=0x12345678 
@此格式表示的是伪指令，等价于@R1 = 0x12345678，
@可以将任意一个32位数据放到寄存器中，解决MOV指令不能将任意32位数搬到寄存器中去的问题

LDR R1,=STOP @将STOP代码段的第一条语句的地址写入R1寄存器，给的是指令地址
STOP:
	B STOP
	
LDR R1,STOP @将STOP代码段的第一条指令的机器码写入R1寄存器，给的是指令内容本身
```

## 7.9.伪操作

```asm
@伪操作一般以'.'开头

@1.
.global symbol @将一个符号如MAIN,STOP这样的声明为全局
@2.
.local symbol  @声明成局部
@3.
.equ DATA,0xFF @声明一个宏
		MOV R1,#DATA
@4.		
.macro FUNC  @对汇编指令的封装
	......
	MOV R1,#1
	MOV R2,#2
	......
	......
.endm
		FUNC
@5.		
.if 1         @条件编译
	...
	...
	...
.endif
@6.
.rept n        @编译n遍
	MOV R1,#1
	MOV R2,#2	
.endr
@7.
.weak FUN     @弱化一个符号，即遇到使用未定义的符号不要去报错
B FUNC        @会被编译成NOP

@8.
MOV R1,#1
.word 0xFFFFFFFF     @在当前地址申请一个字的空间并将其初始化0xFFFFFFFF
MOV R2,#2

@9.
MOV R1,#1
.byte 0xFF
.align n           @让下一条语句地址对齐到地址为2^n的位置
MOV R2,#2

@9.
.space n,#0x12        @申请任意字节n，并将其初始化
```

# C与汇编混合编程

1. 数据处理指令，跳转指令，内存访问指令——通用指令，可以用汇编写，也可以用C语言写，**主要用C写，更简单**。
2. `CPSR`指令,`SWI`指令,协处理器指令——ARM特有指令，**只能用汇编编写**，C作为一个标准通用肯定不能编译出某个`cpu`特有的指令
3. CPU启动代码一定是汇编，如初始化SP指针，初始化异常向量表，启动某个权限等。

## 1.汇编调用（跳转）c语言

.S文件

```asm
	MOV R1,#1
	MOV R2,#2
	BL func_c
	MOV R3,#3
```

.c文件

```c
voif func_c(void){
	int a;
	a++;
	a--;
}	
```

## 2.c语言调用（跳转）汇编语言

.c文件

```c
voif func_c(void){
	int a;
	a++;
	FUNC_ASM();
	a--;
}	
```

.s文件

```asm
.global FUNC_ASM
FUNC_ASM:
		MOV R1,#1
		MOV R2,#2
		MOV R3,#3
```

## 3.c内联汇编

.c文件

```c
voif func_c(void){
	int a = 5, b = 3, sum;
	#define PAUSE __asm__ __volatile__(
        "rep; nop" \  //要执行的cpu指令
		:          \ // 输出部分，为空
	    :          \ // 输入部分，为空
		: "memory");//影响的寄存器或内存
}
   //- 当CPU执行PAUSE指令时，会短暂停止当前线程的执行,让出处理器资源给其他线程比直接循环更节能且效率更高
```

# 9. ATPCS

ARM Thumb Program Call Standard，协议的主要内容：

- **栈**
  所有编译器编译时都使用满减栈
- **寄存器的使用**
     R15  程序计数器，只能用于存储程序的指针，不能用作其他用途
     R14  连接寄存器，只能用于存储返回地址,不能用作其他用途
     R13  栈指针，只能用于存储栈指针，不能用作其他用途
     R0-R3 当函数参数少于4个时，使用R0-R3传参，多出4个部分用栈传递，函数返回值使用R0传递
     其余寄存器主要用于存储局部变量。		

# >>>>>>ARM接口技术>>>>>>

# 1. FS4412地址映射表

## 1.1.CPU如何控制硬件?

- 利用ARM的cpu的指令之一LOAD/STORE指令来进行控制。
- SOC——片上系统，除了ARM这个**CPU**外，还会集成存放程序的**ROM**和存储变量的**RAM**，还有硬件**控制器**（也是一个电路，里面也会有很多寄存器）如网卡，USB控制器，串口控制器。SOC中将各个**硬件控制器的寄存器映射到了CPU寻址空间中的一段范围**，故控制器里的寄存器是有地址的。
- CPU通过LOAD/STORE指令来往控制器的寄存器里面读写数据来控制硬件。RAM,ROM,SFR(特殊功能寄存器)对应到很多硬件控制器上。

## 1.2.地址映射表

在一个处理器中，一般会将Flash，RAM,外设寄存器等存储设备分别映射到寻址空间中的不同地址段，我们将这个映射关系称为这个处理器的地址映射表。

# 2. GPIO实验（汇编实现）

## 2.1.GPIO简介

GPIO（General-purpose input/output）即通用型输入输出，通用型是因为一个引脚不仅仅是用于简单的进行输入输出高低电平来控制led灯等，也可以用于通信rx，tx，也可以用于输入输出中断触发信号等一些其他功能。GPIO可以控制连接在其之上的引脚实现信号的输入和输出。芯片的引脚与外部设备相连，从而实现与外部硬件设备的**通讯**、控制及信号采集等功能。

SOC上的各个控制器如果都引出单独的引脚，那么一块芯片上的引脚就会很多很多，这是芯片设计时不希望看到的，因此一般一个引脚都能通过GPIO引脚控制器里的寄存器来控制选择连接哪一个具体的控制器，从而实现不同的功能。就好比Arduino一块小小板子，一点引脚却能实现许多功能一样。进行Arduino的一些实验时都是要先配置引脚的功能，我们用的板子也一样，使用某个引脚时也需要配置其功能，不一样的是可能某些引脚已经被焊好到某个设备上了，不像自己玩的板子那样可以用杜邦线来接线。



## 2.2.实验步骤

1. 通过电路原理图分析LED的控制逻辑 - 高电平点亮、低电平熄灭

2. 通过电路原理图查找LED与Exynos4412的连接关系 - GPX2_7

3. 通过数据手册分析GPIO中哪些寄存器可以控制LED - GPX2CON、GPX2DAT

4. 通过程序去操控对应的寄存器完成对LED的控制

## 2.3 .汇编语言实现

```asm
.text
_start:
MAIN:
	BL LED_CONFIG
LOOP:
	BL LED3_ON
	BL DELAY
	BL LED3_OFF
	BL DELAY
	B LOOP
LED_CONFIG:
	LDR R2,=0x11000c20
	LDR R1,=0x1
	STR R1,[R2]
	MOV PC,LR
LED3_ON:
	LDR R2,=0x11000c24
	LDR R1,=0x1
	STR R1,[R2]
	MOV PC,LR
LED3_OFF:
	LDR R2,=0x11000c24
	LDR R1,=0x0
	STR R1,[R2]
	MOV PC,LR
DELAY:
	LDR R1,=100000000
L:
	SUB R1,R1,#1
	CMP R1,#0
	BNE L
	MOV PC,LR
STOP:
	B STOP
```

# 3.C工程与寄存器封装

## 3.1.[文件夹分析](D:\Code_dir\VM_OS\share\review\ARM\interface)

```shell
.
├── common
│   ├── include
│   │   ├── ctype.h
│   │   ├── exynos_4412.h
│   │   ├── stdarg.h
│   │   └── uart.h
│   └── src
│       ├── main.o
│       ├── printf.c
│       ├── uart.c
│       ├── _udivsi3.S
│       └── _umodsi3.S
├── .cproject
├── .DS_Store
├── interface.c
├── Makefile
├── map.lds
├── .project
└── start
    └── start.S
```

common：封装一些功能实现的.c和头文件.h

interface.c：要写的main.c文件

Makefile:把所有.c和所有.s文件生成.o文件，并链接生成.elf可执行文件，再通过objcopy转换成.bin能运行在裸机上的二进制文件。

map.lds：链接.o文件时的链接程序的地址应该放在内存中的哪个位置运行，并且程序的数据段，代码段，bss段等应该如何排布。

start：开发板启动代码，主要做一些初始化，以及异常向量表的定义，修改异常向量表的地址等。

## 3.2.启动代码分析

1. 利用B .来占用异常向量表所使用的空间。并且利用协处理器修改异常向量表的地址。
2. 设置CPU为SVC模式，且为ARM状态，关闭FIQ,IRQ中断使能。
3. 使TLB，MCR,icache，MMU虚拟地址映射等机制关闭。
4. 使能运算浮点数据的协处理器。
5. 为各个模式下的栈分别占用512个字节空间。此外还初始化各个模式下栈指针SP为栈空间中的最高地址。
6. 最后把CPU模式切换到USER模式，并把FIQ,IRQ使能打开，并且调用B MAIN语句来跳转到C文件下的main函数。

# 4.LED闪烁实验(C语言实现)

## 4.1.实验代码

```C
void delay(unsigned int Time){
	while(Time--);
}
int main()
{	
	/*config the GPX2CON*/
	*(unsigned int*)0x11000c40 = 0x10000000;

	while(1){
		/*led on*/
		*(unsigned int*)0x11000c44 = 0x00000000;
		delay(1000000);
		/*led off*/
		*(unsigned int*)0x11000c44 = 0x00000080;
		delay(1000000);
	}
	return 0;
}
```

## 4.2.寄存器封装

由于不断地写寄存器的地址来代替寄存器很容易出错，所以用宏定义来把寄存器地址定义成寄存器的名字，这样即使出错写错名字，编译器也能检查出来。

1. **方式1：宏**

   ```c
   #define GPX2CON (*(unsigned int*)0x11000c40)
   #define GPX2DAT (*(unsigned int*)0x11000c44)
   int main()
   {	
   	/*config the GPX2CON*/
   	GPX2CON = 0x10000000;
   
   	while(1){
   		/*led on*/
   		GPX2DAT = 0x00000000;
   		delay(1000000);
   		/*led off*/
   		GPX2DAT = 0x00000080;
   		delay(1000000);
   	}
   	return 0;
   }
   ```

2. **方式2：结构体**，前提是那一堆的寄存器在空间地址上是连续的，这样才能作为结构体成员。

   ```c
   typedef struct{
       unsigned int CON;//因为GPIO各个寄存器空间占32位，四个字节，而int正好4个字节，所以定义成员为int型
       unsigned int DAT;
       unsigned int PUD;
       unsigned int DRV;
   }gpx2;
   #define GPX2 (*(gpx2*)0x11000c40)
   int main()
   {	
   	/*config the GPX2CON*/
   	GPX2.CON = 0x10000000;
   
   	while(1){
   		/*led on*/
   		GPX2.DAT = 0x00000000;
   		delay(1000000);
   		/*led off*/
   		GPX2.DAT = 0x00000080;
   		delay(1000000);
   	}
   	return 0;
   }
   ```

## 4.3.寄存器操作标准化

1. unsigned int a;将a的第n位置1，其他位保持不变
     a = a | (1 << n)
2. unsigned int a;将a的第n位置0，其他位保持不变
    a = a & (~(1 << n))
3. unsigned int a;将a的第[7:4]位置0101，其他位保持不变
   1）先清0，再置位
   2）a = a & (~(0xF << 4)) ;a = a | (0x5 << 4)

# UART实验

## 1.UART

​	UART，称为通用异步收发器，是一种通用的串行，异步通信总线，该总线有两根数据线，可以实现全双工的发送和接收，在嵌入式系统中常用于主机与辅助设备之间的通信。

## 2.并行与串行

- 并行通信
  效率高，但线多布局难，线线之间存在干扰
- 串行通信

## 3.UART帧格式

![image-20240727114213155](C:\Users\z3254406361\AppData\Roaming\Typora\typora-user-images\image-20240727114213155.png)

最多只能发8位是为了避免累积误差,即最多发完一个字节后就要重新开始，就要设置停止位，并重新设置起始位来代表新的一次开始，因为是异步的，收发双方时钟不一样。

## 5.4.UART控制器

一般情况下处理器中都会集成UART控制器，我们实验UART进行通信时只需要对其内部的相关寄存器进行设置即可。![image-20240917071602420](C:\Users\z3254406361\AppData\Roaming\Typora\typora-user-images\image-20240917071602420.png)

发送接收原理，完整数据在缓冲区，发送移位寄存器，一个周期移移位发1bit数据出去，接收移位寄存器，一个周期移一位接收1bit到接收缓冲区。

## 5.5.实验步骤

用Arduino做类比

```c
1./*配置GPA1CON[7:0],将GPA1_0和GPA1_1分别设置成UART2的RX和TX*/  
SoftwareSerial mySerial(10, 11); // RX | TX

GPA1.CON = GPA1.CON & (~(0xFF << 0)) | (0x22 << 0);
2./*配置UBRDIV2和UFRACVAL2，设置波特率*/
Serial.begin(speed, config)
UART2.UBRDIV2 = 53;
UART2.UFRACVAL2 = 4;
/*配置ULCON2，设置8位数据位，1位停止位，无校验，正常模式*/
UART2.ULCON2 = UART2.ULCON2 & (~(0x7f << 0)) | (0x3 << 0);
3./*配置UCON2[3:0]，设为轮询模式*/
UART2.UCON2 = UART2.UCON2 & (~(0xf << 0)) | (0x5 << 0);  
4./*循环读取和接收数据，写入寄存器UTXH2，读取寄存器URXH2*/
    while(1){
        Serial.println("123");
        Serial.read();
    }
```

## 5.6.代码完善

```c
UART2.UTXH2 = 'A';
UART2.UTXH2 = 'B';
UART2.UTXH2 = 'C';
UART2.UTXH2 = 'D';
/*cpu执行速度远远快于发送器，当发送器才发完A时，cpu就往寄存器里依次存了A,B,C,D,A,B,C,D，再当发送器读寄存器时，可能是A,B,C,D，即ABCD的顺序变得随机了*/


/*当发送缓冲区的数据不为空时，执行while循环*/
while(!(UART2.UTRSTAT2 & (1 << 1)));
UART2.UTXH2 = 'A';
while(!(UART2.UTRSTAT2 & (1 << 1)));
UART2.UTXH2 = 'B';
while(!(UART2.UTRSTAT2 & (1 << 1)));
UART2.UTXH2 = 'C';
while(!(UART2.UTRSTAT2 & (1 << 1)));
UART2.UTXH2 = 'D';
```

## 5.7.输入输出重定向

C库里的输出是定向到显卡的，而对于没有操作系统的开发板调用自己实现的printf，输出信息是重定向到UART串口中。

printf->vsprintf->puts->putc

综上分析，没有操作系统的开发板的标准输入输出重定向到串口。

# 6.WDT实验

## 6.1.WDT简介

Watch Dog Timer即看门狗定时器，其主要作用是当发送软件故障时可产生复位信号使SOC复位，其本质是一个计数器。**看门狗也在SOC上**，因此使用时无需配置引脚，且CPU与看门狗电路独立，当cpu故障时，看门狗电路能正常工作。

## 6.2.4412芯片上的WDT控制器

![image-20240728104735845](C:\Users\z3254406361\AppData\Roaming\Typora\typora-user-images\image-20240728104735845.png)

- **PCLK**：100MHZ
- **8bit-Prescaler**：一级分频器，降低到1-256分之一
- **MUX**:二级分频器

## 6.3.实验步骤

1. 设置一级分频

   ```c
   WDT.WTCON = WDT.WTCON | (0xFF << 8);
   ```

2. 设置二级分频

   ```c
   WDT.WTCON = WDT.WTCON | (0x3 << 3);
   ```

3. 禁止中断信号，使能复位信号

   ```c
   WDT.WTCON = WDT.WTCON & (~(1 << 2));
   WDT.WTCON = WDT.WTCON | 1;
   ```

4. 设置计数器值，并使能WDT，让其开始工作

   ```c
   WDT.WTCNT = (3052 * 5);
   WDT.WTCON = WDT.WTCON | (1 << 5);
   ```

# 7.轮询与中断

## 7.1.CPU与硬件的交互方式

- 轮询
  CPU执行程序时不断地询问硬件是否需要其服务，若需要则给予其服务，若不需要一段时间后再次询问，周而复始
- 中断
  CPU执行程序时若硬件需要其服务，对应的硬件给CPU发送中断信号，CPU接收到中断信号后将当前的程序暂停下来，转而去执行中断服务程序，执行完成后再返回到被打断的点继续执行,有**SGI(Software Generated Interrupts)**软中断，**PPI**,**SPI**中断之分。
- DMA
  硬件产生数据后，硬件控制器可将产生的数据直接写入到存储器中，整个过程无需CPU的参与

## 7.2.按键实验（轮询方式）

```C
int main()
{	
	GPX1.CON = GPX1.CON & (~(0xF << 4));
	while(1){
		if(!(GPX1.DAT & (1 << 1))){
			printf("key2 pressed\n");
			while(!(GPX1.DAT & (1 << 1)));
		}else{
		}
	}
	return 0;
}
```

## 7.3.GPIO中断配置

SOC上的各类外设给CPU发送的信号是**IRQ**信号来请求中断。

### 7.3.1.实验步骤

1. 将GPX1设置为中断功能的引脚

   ```c
   /*将GPX1_2设置成中断功能*/
   GPX1.CON = GPX1.CON | (0xF << 8);
   ```

2. 设置中断触发方式为下降沿触发

   ```c
   /*设置GPX1_2的中断触发方式为下降沿触发*/
   EXT_INT41_CON = EXT_INT41_CON & (~(0x7 << 8)) | (0x2 << 8);
   ```

3. **消除抖动**——使能滤波电路FLTCON

4. 设置**MASK**，打开中断功能，所有设置才生效，中断才开始运作。

   ```c
   /*使能GPX1_2的中断功能*/
   EXT_INT41_MASK = EXT_INT41_MASK & (~(1 << 2));
   ```

5. **PEND**，看中断是否被挂起，0表示没中断发送，未挂起，1表示有中断发送，且被挂起。
   当cpu还在处理中断，其他中断又来的时候，又不希望cpu屏蔽新来的中断，所有就要用到挂起，挂起就是cpu接收到中断但还在处理其他中断时可以把新来的中断挂起稍后处理。

   每当相关引脚发出中断信号PEND相应的位被自动置为1，表示当前引脚中断被挂起，当该中断处理完后我们**需要手动设置为0**.

## 7.4.中断控制器

所有外设产生的中断信号并不直接发送给CPU，而是发送给中断控制器进行统一管理，中断控制器再与CPU打交道。

### 7.4.1.中断控制器作用

- **当多个中断同时产生时**，CPU<u>不能同时正确处理多个中断信号</u>，但中断控制器可以为每一个中断分配一个优先级,然后对这些中断挂起排队,然后按照优先级依次发送给CPU处理,优先级只影响排队先后，但是新来的高优先级中断信号并不能打断低优先级的正在处理的中断处理。
- **当一个中断正在处理中又产生其它中断**，如直接送给CPU，CPU接收不到，因为此时CPU早已经处于异常处理模式，且CPSR寄存器里的IRQ位是禁止状态的，因此<u>新的中断会被屏蔽</u>，但中断控制器可将新的中断挂起，待CPU空闲时再发送。
- **当一个中断产生时，对于多核处理器**，<u>应该把中断信号发给哪个CPU</u>，而中断控制器可以对来自外设控制器的中断信号进行统一管理，可以为每一个中断选择一个CPU处理，也可以为每一个中断信号来选择该中断信号的中断类型（FIQ或IRQ）
- **任何中断信号直接发送给CPU，CPU接收到中断信号后并不能区分是哪个外设产生的**，但中断控制器可以让CPU可查询中断控制器 ，来获取当前的中断信号是由哪个硬件产生的，然后再针对不同外设进行不同的中断处理。
- 可以打开或者禁止160个中断中的每一个中断，即中断控制器接收到中断信号，可以选择转发或者不转发给CPU。

### 7.4.2.SOC上的中断控制器

**Supports three interrupt types**

 Software Generated Interrupt (SGI)  软中断

 Private Peripheral Interrupt (PPI)  私有外设中断

 Shared Peripheral Interrupt (SPI)  共享外设中断

**Programmable interrupts that enable you to set the**  

 Security state for an interrupt.  

 Priority level of an interrupt.  设置优先级

 Enabling or disabling of an interrupt.  使能/屏蔽某个中断信号

 Processors that receive an interrupt. 选择处理器

### 7.4.3.寄存器分析

1. 设置**ICDDCR**——使能整个中断控制器的**总开关**

   ```c
   /*全局使能中断控制器使其能够接收外部设备产生的中断信号并转发给CPU接口*/
   ICDDCR = ICDDCR | 1;
   ```

2. 设置**ICDISER_CPU**——使能**每个中断信号的开关**。
   设置160个中断信号打开或者关闭,即控制器是否转发给CPU，某一位写0，对应中断不转发闭，1则转发。
   5个寄存器*32bit = 160bits = 160个中断。![image-20240730191432094](C:\Users\z3254406361\AppData\Roaming\Typora\typora-user-images\image-20240730191432094.png)

3. 设置**ICDIPTR_CPU**——每一个中断信号需要一个8bits的空间来**选择用哪个cpu**，故需要8*160 = 1280bit = 32 * 40个寄存器，故有40个ICDIPTR_CPU寄存器   。![image-20240730192801135](C:\Users\z3254406361\AppData\Roaming\Typora\typora-user-images\image-20240730192801135.png)

4. **设置ICCICR_CPUn**，使能/打通中断控制器到各个CPU的接口。

5. 中断类型——默认为IRQ类型

## 7.5.中断处理

### 7.5.1.LR寄存器原理

**R14(LR,Link Register)**

  链接寄存器，一般有以下两种用途：

   1.执行跳转指令(BL/BLX)时，LR会自动保存跳转指令下一条指令的地址，程序需要返回时将LR的值复制到PC即可实现。当执行BL指令时，**指令执行过程中**处理器内部就会将PC寄存器的值拷贝到LR寄存器，然后再将LR寄存器中的值自减4， 所以LR寄存器中保存的就是BL指令**下一条指令**的地址

  2.产生异常时，对应异常模式下的LR会自动保存被异常打断的指令的下一条指令的地址，异常处理结束后将LR的值复制到PC可实现程序返回。当执行一条指令时产生了一个IRQ中断，执行这条指令过程中处理器不会保存返回地址，而是**执行完成后**才会保存,但执行完成后PC的值又会自动增4，所以对于IRQ来说LR中保存的是被中断打断的指令的**下下条指令**的地址

**原理**

  当执行跳转指令或产生异常时，LR寄存器中不会凭空产生一个返回地址，其原理是当执行跳转指令或产生异常时，处理器内部会将PC寄存器中的值拷贝到LR寄存器中，然后再将LR寄存器中的值自减4

### 7.5.2.中断处理框架搭建

在start启动代码中，修改中断向量表进行跳转。

```asm
b reset
b .
b .向量
b .
b .
b .
@偏移地址为0x18，IRQ中断处理
b irq_handler
b .


...
...
...

irq_handler:
	@修正lr的值
	sub lr，lr，#4
	@因为IRQ模式下使用的R0-R12寄存器和USER模式下使用的是同一组，所以在处理异常之前需要先将之前USER模式下寄存器的值压栈保护。
	stmfd sp!,{r0-r12,lr}
	
	bl do_irq @do_irq:c语言的中断处理程序
	
	
	ldmfd sp!,{r0-r12,pc}^@^的作用是把spcr的值给cpsr，恢复之前的运行环境

```

### 7.5.3.中断程序编程

1. **修改中断挂起寄存器**——被挂起的程序会不断的发送中断信号给中断控制器，故会不断地进行中断处理，这是我们不想看到的，故需要在中断处理完后修改中断挂起寄存器的状态位——**写1清0，写0保持不变**

   ```c
   EXT_INT41_PEND = (1 << 1);
   ```

2. **获取ICCIAR_CPU的值**——因为irq中断处理程序处理的是irq异常，但又有许多外设控制器都可以发送irq异常，比如uart，wdt，gpio，不可能说这些外设都用同一个irq处理程序，所以需增加switch根据中断信号的id号来辨别是哪个外设中断，从而选择对应的中断处理程序。

   ```c
   unsigned int irq_num = 0;
   irq_num = CPU0.ICCIAR & 0x3FF;
   switch(irq_num){
   		case 0:
   			//hander 0 
   			break;
   		case 1:
   			//hander 1
   			break;
   		/*
   		 * ...
   		 * ...
   		 */
   		case 57:
   			printf("key2 pressed\n");
   			EXT_INT41_PEND = (1 << 1);
   			break;
   			/*
   			 * ... ...
   			 */
   		case 159:
   			// hander 159
   			break;
   		default:
   			break;
   }
   ```

3. **修改ICCEOIR_CPU的值**——由于CPU0处理完异常程序后，正常返回时，中断控制器是不知道此时cpu0已经空闲，故下次再有中断来选择cpu0时中断控制器认为cpu0还是在忙，故不会转发给cpu0，故需要我们往该寄存器写入中断信号的id57，来让cpu0告诉中断控制器57号异常处理完了，空闲了。

   ```c
   //通知中断控制器当前中断处理已经完成，可以处理其他中断
   //将当前中断的中断号写回中断控制器，以这样的方式告诉中断控制器当前中断已经处理完，可以发送其他中断了。
   CPU0.ICCEOIR = CPU0.ICCEOIR & (~(0x3FF))|(57);
   ```

## 7.6.中断总结

轮询虽然实现简单，但cpu执行效率低，而中断虽然实现复杂，但cpu执行效率高。

**中断实现的整体思路：**

1. **外设到中断控制器**：先确定哪些外设硬件需要请求中断，然后去该设控制器的相关寄存器里设置，包括引脚设置为中断功能，EXIT_INT4n设置中断触发方式，使能中断等，所有设置完成后，外设硬件控制器就能发送中断信号给中断控制器了。
2. **中断控制器到CPU接口**：让中断控制器接收外设控制器发来的中断信号并对其进行管理然后再转发给一个合适的CPU去处理。**首先**要使能整个中断控制器，**其次**再根据中断信号id使能相要的中断信号，**然后**再选择使用哪个CPU来处理该中断，**最后**再使能中断控制器到cpu的接口
3. **CPU到中断控制器**：
   1.修改启动代码的异常向量表--->修正lr的值，并压栈保护不同异常模式共用的那些寄存器的值--->跳转到c语言的中断处理程序-->出栈恢复现场，恢复cpsr的值。
   2.编写中断处理程序：获取cpu即将处理的中断信号的id，根据id执行响应地中断处理程序--->将挂起状态修改，把中断挂起态取消---->cpu处理完中断后，告诉中断控制器处理完了，cpu空闲了。

# 8.ADC实验

## 8.1.ADC简介

ADC(Analog to Digital Converter)即模数转换器，指一个能将模拟信号转化为数字信号的电子元件。

ADC的分辨率一般以输出二进制数的位数来表示，当最大输入电压一定时，位数越高，分辨率越高； n位的ADC能区分输入电压的最小值为满量程输入的1/2^n； 比如一个12位的ADC，最大输入电压为1.8v，那么该ADC能区分的最小电压为1.8v/2^12≈0.00044v，当转换的结果为m时，则实际的电压值为m*(1.8v/2^12)

## 8.2.4412下的ADC控制器

5MHZ时钟，可以达到1MSPS，故转换一次需要5个时钟。

When the APB bus clock(PCLK) frequency is 66MHz and the prescaler value is 65, total 12-bit conversion time is  as follows.  

 A/D converter freq. = 66MHz/(65+1) = 1MHz  

 Conversion time = 1/(1MHz / 5cycles) = 1/200kHz = 5us 

## 8.3.ADC寄存器

ADCCON:配置ADC寄存器，如精度，查看转换是否完成标志，配置转换是读取时开始还是想什么时候转换就什么时候转换等

ADCDAT:存放ADC转换结果的寄存器

ADCMUX：选择ADC模拟信号输入通道的寄存器

## 8.4.实验步骤及代码

```c
int main()
{	
	unsigned int ADC_Value;
	/*将ADC的转换精度设置成12bits*/
	ADCCON = ADCCON | (1 << 16);
	/*将ADC的分频器打开*/
	ADCCON = ADCCON | (1 << 14);
	/*设置ADC的预分频数为19+1,ADC的时钟频率=PLCK/(19+1)=5MHZ,ADC的转换
	 * 频率 = 5MHZ / 5 = 1MHZ*/
	ADCCON = ADCCON & (~(0xFF << 6)) | (19 << 6);
	/*关闭待机模式，使能正常模式*/
	ADCCON = ADCCON & (~(1 << 2));
	/*关闭通过读触发AD转换*/
	ADCCON = ADCCON &(~(1 << 1));
	/*设置选择转换通道，3通道*/
	ADCMUX = 3;
	while(1){
		/*开始转换*/
		ADCCON = ADCCON | 1;
		/*等待ADC转换完成*/
		while(!(ADCCON & (1 << 15)));
		/*读取ADC的转换结果*/
		ADC_Value = ADCDAT & (0xFFF);
		/*将结果转换成实际的电压值,以毫伏为单位*/
		ADC_Value = ADC_Value * 0.44;
		printf("ADC_Value = %dmv\n",ADC_Value);
	}
	return 0;
}
```

# RTC实验

## RTC简介

RTC(Real Time Clock)即实时时钟，它是一个可以为系统提供精确的时间基准的元器件，RTC一般采用**精度更高**32.768kHZ的晶振作为时钟源，有些RTC为了在主电源掉电时还可以工作，需要外加电池供电。位于SOC上。

## 4412的RTC控制器

RTC本身就是集成在SOC上的控制器，且没有使用任何引脚，因此不必配置芯片外设的外部引脚。

![image-20240731174305655](C:\Users\z3254406361\AppData\Roaming\Typora\typora-user-images\image-20240731174305655.png)

Leap Year Generator：判断是否为闰年

Alarm Generator ：产生Alarm中断信号

## 4412的RTC寄存器

BCDSEC：秒   

BCDMIN：分 

BCDHOUR：时   

BCDDAYWEEK：星期   

BCDDAY：日

BCDMON：月

BCDYEAR：年

RTCCON ：RTC控制器使能信号，只有使能时才能修改时间。

## 实验步骤及代码

```c
int main()
{
	unsigned int OldSec = 0,NewSec = 0;
	/*使能RTC控制器*/
	RTCCON = RTCCON | 1;
	/*设置时间*/
	RTC.BCDYEAR = 0x024;
	RTC.BCDMON = 0x07;
	RTC.BCDDAY = 0x31;
	RTC.BCDHOUR = 0x23; 
	RTC.BCDMIN = 0x59;
	RTC.BCDSEC = 0x50;
	RTCCON = RTCCON & (~1);
	while(1){
		NewSec = RTC.BCDSEC;
		if(NewSec != OldSec){
			printf("20%x-%x-%x %x:%x:%x\n",RTC.BCDYEAR,RTC.BCDMON,RTC.BCDDAY,
					RTC.BCDHOUR,RTC.BCDMIN,RTC.BCDSEC);
		}
		OldSec = NewSec;
	}
	return 0;
}
```

# PWM实验





# IIC实验

## 1.IIC总线简介

​	IIC,（Inter-Integrated Circuit），即集成电路总线。 IIC总线是Philips公司在八十年代初推出的一种**串行、半双工**总线。主要用于**近距离、低速的**芯片之间的通信；IIC总线有两根双向的信号线一根数据线SDA用于收发数据，一根时钟线SCL用于通信双方时钟的同步（通信双方器件内部本身有产生和接受时钟信号的电路）；IIC总线硬件结构简单，成本较低，因此在各个领域得到了广泛的应用。

​	IIC总线是一种**多主机（区分uart的点对点）**总线，连接在IIC总线上的器件分为主机和从机，主机有权发起和结束一次通信，而从机只能被主机呼叫；当总线上有多个主机同时启用总线时，IIC也具备冲突检测和仲裁的功能来防止错误产生；每个连接到IIC总线上的器件都有一个唯一的地址(7bit)，且每个器件都可以作为主机也可以作为从机(同一时刻只能有一个主机),总线上的器件增加和删除不影响其他器件正常工作；IIC总线在通信时总线上发送数据的器件为发送器，接收数据的器件为接收器。![image-20240801100219263](C:\Users\z3254406361\AppData\Roaming\Typora\typora-user-images\image-20240801100219263.png)

## 2.IIC总线通信过程

1. .初始状态各引脚线为高电平

2. 主机发送起始信号(低电平)启用总线

3. 主机发送一个字节数据指明从机地址和后续字节的传送方向

4. 被寻址的从机发送应答信号（低电平）回应主机

5. 发送器发送一个字节数据

6. 接收器发送应答信号回应发送器

7. … … （循环步骤4、5）

8. 通信完成后主机发送停止信号释放总线


## 3.IIC总线寻址方式

​	主机在发送起始信号后必须先发送一个字节的数据，该数据的高7位为从机地址，最低位表示后续字节的传送方向，'0'表示主机发送数据，'1'表示主机接收数据；总线上所有的从机接收到该字节数据后都将这7位地址与自己的地址进行比较，如果相同，则认为自己被主机寻址，然后再根据第8位将自己定为**发送器或接收器**。

## 4.字节传送与应答

​	数据传送时，先传送最高位，后传送低位，发送器发送完一个字节数据后接收器必须发送1位应答位来回应发送器。

## 5.同步信号

​	IIC总线在进行数据传送时，时钟线SCL为低电平期间发送器向数据线上发送一位数据，在此期间数据线上的信号允许发生变化，时钟线SCL为高电平期间接收器从数据线上读取一位数据，在此期间数据线上的信号不允许发生变化，必须保持稳定。![image-20240801101252895](C:\Users\z3254406361\AppData\Roaming\Typora\typora-user-images\image-20240801101252895.png)

## 11.5.典型时序

**主机向从机发送数据**![image-20240801100833748](C:\Users\z3254406361\AppData\Roaming\Typora\typora-user-images\image-20240801100833748.png)

**从机向主机发送数据**![image-20240801100857795](C:\Users\z3254406361\AppData\Roaming\Typora\typora-user-images\image-20240801100857795.png)

**主机先向从机发送数据，然后从机再向主机发送数据**![image-20240801100945835](C:\Users\z3254406361\AppData\Roaming\Typora\typora-user-images\image-20240801100945835.png)

## 11.6.4412下的IIC控制器

**To control multi-master I2C-bus operations, you must write values to these registers:**  

 Multi-master I2C-bus control register – I2CCON  

 Multi-master I2C-bus control/status register – I2CSTAT  

 Multi-master I2C-bus Tx/Rx data shift register – I2CDS  

 Multi-master I2C-bus address register – I2CADD（4412的IIC控制器作为从机时，用于设置从机地址）

**The four operation modes of the Exynos 4412 SCP I2C-bus interface are:**  

 Master Transmitter Mode: ![image-20240801122737723](C:\Users\z3254406361\AppData\Roaming\Typora\typora-user-images\image-20240801122737723.png) 

 Master Receive Mode  

 Slave Transmitter Mode  

 Slave Receive Mode

## 11.7.IIC寄存器

![image-20240801122927178](C:\Users\z3254406361\AppData\Roaming\Typora\typora-user-images\image-20240801122927178.png)

## 11.8.从MPU6050读写数据（参考6050手册的通信时序）

**向MPU6050的一个寄存器写一个字节的数据**

1.主机(Exynos4412)发送起始信号

2.主机发送从机地址(MPU6050的地址)及读写方向(写)

3.从机(MPU6050)发送应答信号

4.主机发送一个字节数据(要写的寄存器的地址)

5.从机发送应答信号

6.主机发送一个字节数据(要写到寄存器的数据)

7.从机发送应答信号
 	   8.主机发送停止信号

**从MPU6050的一个寄存器读一个字节的数据**

1.主机(Exynos4412)发送起始信号

2.主机发送从机地址(MPU6050的地址)及读写方向(写)

3.从机(MPU6050)发送应答信号

4.主机发送一个字节数据(要写的寄存器的地址)

5.从机发送应答信号

6.主机(Exynos4412)发送起始信号

7.主机发送从机地址(MPU6050的地址)及读写方向(读)
        8.从机(MPU6050)发送应答信号

9.从机发送一个字节数据(要读的寄存器中的数据)

10.主机发送非应答信号(不再接收更多的数据)==【可以参，mpu6050手册，上面的时序是要求主机非应答】

11.主机发送停止信号

## 11.9.实验步骤及代码

```c
/**********************************************************************
 * 函数功能：I2C向特定地址写一个字节
 * 输入参数：
 * 		slave_addr： I2C从机地址
 * 			  addr： 芯片内部特定地址
 * 			  data：写入的数据
**********************************************************************/

void iic_write (unsigned char slave_addr, unsigned char addr, unsigned char data)
{
	/*对时钟源进行512倍预分频  打开IIC中断（每次完成一个字节的收发后中断标志位会自动置位）*/
	I2C5.I2CCON = I2C5.I2CCON | (1<<6) | (1<<5);

	/*设置IIC模式为主机发送模式  使能IIC发送和接收*/
	I2C5.I2CSTAT = 0xd0;
	/*将第一个字节的数据写入发送寄存器  即从机地址和读写位（MPU6050-I2C地址+写位0）*/
	I2C5.I2CDS = slave_addr<<1;
	/*设置IIC模式为主机发送模式  发送起始信号启用总线  使能IIC发送和接收*/
	I2C5.I2CSTAT = 0xf0;

	/*等待从机接受完一个字节后产生应答信号（应答后中断挂起位自动置位）*/
	while(!(I2C5.I2CCON & (1<<4)));

	/*将要发送的第二个字节数据（即MPU6050内部寄存器的地址）写入发送寄存器*/
	I2C5.I2CDS = addr;
	/*清除中断挂起标志位  开始下一个字节的发送*/
	I2C5.I2CCON = I2C5.I2CCON & (~(1<<4));
	/*等待从机接受完一个字节后产生应答信号（应答后中断挂起位自动置位）*/
	while(!(I2C5.I2CCON & (1<<4)));

	/*将要发送的第三个字节数据（即要写入到MPU6050内部指定的寄存器中的数据）写入发送寄存器*/
	I2C5.I2CDS = data;
	/*清除中断挂起标志位  开始下一个字节的发送*/
	I2C5.I2CCON = I2C5.I2CCON & (~(1<<4));
	/*等待从机接受完一个字节后产生应答信号（应答后中断挂起位自动置位）*/
	while(!(I2C5.I2CCON & (1<<4)));

	/*发送停止信号  结束本次通信*/
	I2C5.I2CSTAT = 0xD0;
	/*清除中断挂起标志位*/
	I2C5.I2CCON = I2C5.I2CCON & (~(1<<4));
	/*延时*/
	mydelay_ms(10);
}

/**********************************************************************
 * 函数功能：I2C从特定地址读取1个字节的数据
 * 输入参数：         slave_addr： I2C从机地址
 * 			       addr： 芯片内部特定地址
 * 返回参数： unsigned char： 读取的数值
**********************************************************************/

unsigned char iic_read(unsigned char slave_addr, unsigned char addr)
{

	unsigned char data = 0;

	/*对时钟源进行512倍预分频  打开IIC中断（每次完成一个字节的收发后中断标志位会自动置位）*/
	I2C5.I2CCON = I2C5.I2CCON | (1<<6) | (1<<5);

	/*设置IIC模式为主机发送模式  使能IIC发送和接收*/
	I2C5.I2CSTAT = 0xd0;
	/*将第一个字节的数据写入发送寄存器  即从机地址和读写位（MPU6050-I2C地址+写位0）*/
	I2C5.I2CDS = slave_addr<<1;
	/*设置IIC模式为主机发送模式  发送起始信号启用总线  使能IIC发送和接收*/
	I2C5.I2CSTAT = 0xf0;
	/*等待从机接受完一个字节后产生应答信号（应答后中断挂起位自动置位）*/
	while(!(I2C5.I2CCON & (1<<4)));

	/*将要发送的第二个字节数据（即要读取的MPU6050内部寄存器的地址）写入发送寄存器*/
	I2C5.I2CDS = addr;
	/*清除中断挂起标志位  开始下一个字节的发送*/
	I2C5.I2CCON = I2C5.I2CCON & (~(1<<4));
	/*等待从机接受完一个字节后产生应答信号（应答后中断挂起位自动置位）*/
	while(!(I2C5.I2CCON & (1<<4)));

	/*清除中断挂起标志位  重新开始一次通信  改变数据传送方向*/
	I2C5.I2CCON = I2C5.I2CCON & (~(1<<4));

	/*将第一个字节的数据写入发送寄存器  即从机地址和读写位（MPU6050-I2C地址+读位1）*/
	I2C5.I2CDS = slave_addr << 1 | 0x01;
	/*设置IIC为主机接收模式  发送起始信号  使能IIC收发*/
	I2C5.I2CSTAT = 0xb0;
	/*等待从机接收到数据后应答*/
	while(!(I2C5.I2CCON & (1<<4)));


	/*禁止主机应答信号（即开启非应答  因为只接收一个字节）  清除中断标志位*/
	I2C5.I2CCON = I2C5.I2CCON & (~(1<<7))&(~(1<<4));
	/*等待接收从机发来的数据*/
	while(!(I2C5.I2CCON & (1<<4)));
	/*将从机发来的数据读取*/
	data = I2C5.I2CDS;

	/*直接发起停止信号结束本次通信*/
	I2C5.I2CSTAT = 0x90;
	/*清除中断挂起标志位*/
	I2C5.I2CCON = I2C5.I2CCON & (~(1<<4));
	/*延时等待停止信号稳定*/
	mydelay_ms(10);

	return data;

}


/**********************************************************************
 * 函数功能：MPU6050初始化
**********************************************************************/

void MPU6050_Init ()
{
	iic_write(SlaveAddress, PWR_MGMT_1, 0x00); 		//设置使用内部时钟8M
	iic_write(SlaveAddress, SMPLRT_DIV, 0x07);		//设置陀螺仪采样率
	iic_write(SlaveAddress, CONFIG, 0x06);			//设置数字低通滤波器
	iic_write(SlaveAddress, GYRO_CONFIG, 0x18);		//设置陀螺仪量程+-2000度/s
	iic_write(SlaveAddress, ACCEL_CONFIG, 0x0);		//设置加速度量程+-2g
}



/**********************************************************************
 * 函数功能：主函数
 **********************************************************************/

int main(void)
{

	unsigned char zvalue_h,zvalue_l;						//存储读取结果
	short int zvalue;

	/*设置GPB_2引脚和GPB_3引脚功能为I2C传输引脚*/
	GPB.CON = (GPB.CON & ~(0xF<<12)) | 0x3<<12;			 	//设置GPB_3引脚功能为I2C_5_SCL
	GPB.CON = (GPB.CON & ~(0xF<<8))  | 0x3<<8;				//设置GPB_2引脚功能为I2C_5_SDA

	uart_init(); 											//初始化串口
	MPU6050_Init();											//初始化MPU6050

	printf("\n********** I2C test!! ***********\n");
	while(1)
	{
		zvalue_h = iic_read(SlaveAddress, GYRO_ZOUT_H);		//获取MPU6050-Z轴角速度高字节
		zvalue_l = iic_read(SlaveAddress, GYRO_ZOUT_L);		//获取MPU6050-Z轴角速度低字节
		zvalue  =  (zvalue_h<<8)|zvalue_l;					//获取MPU6050-Z轴角速度

		printf(" GYRO--Z  :Hex: %d	\n", (zvalue * 2000)/32768);			//打印MPU6050-Z轴角速度
        //+-2000，+2000，-2000，低15位表示数据位，16位表示符号位，2^15 = 32768
		mydelay_ms(100);
	}
	return 0;
}
```

## 11.20.思路总结

1.首先了解IIC的工作原理，以及如何收发数据。

2.4412_SOC上有IIC控制器，且要与外部设备MPU6050通信，故需要配置引脚为IIC传输引脚。

3.然后了解IIC控制器的寄存器，再配置寄存器进行初始化，读写寄存器进行数据存取，以此向外部设备进行IIC通信。

4.由于MPU6050有许多寄存器，有些寄存器存的是温度，有些存的是角速度，有些存的是加速度，而IIC通信需要从把MPU6050的地址作为从机地址，并根据需求选择其内部的寄存器的地址作为主机发送给从机的数据来选择获取哪个寄存器的数据，故需要去了解MPU6050有哪些寄存器，以及这些寄存器如何进行IIC通信。

5.写代码时就根据思路依次配置号引脚，写数据到IIC控制器的寄存器配置IIC控制器，l利用IIC写数据到MPU6050寄存器设置其参数，配置其量程，采样频率，利用IIC从MPU6050寄存器读数据来获取想要的结果。

# 12.SPI通信原理及应用

## 12.1.SPI简介

SPI是串行外设接口的缩写，SPI是一种高速的、**全双工、同步**的串行通信总线；SPI采用主从方式工作，一般有一个主设备和一个或者多个从设备从设备；SPI需要至少4根线，分别是MISO,MOSI,SCLK,CS。SPI使用引脚较少且布线方便，所有越来越多芯片集成了这种通信协议。

## 12.2.寻址方式

当主设备要和某个从设备进行通信时，主设备需要先向对应从设备的片选线上发送使能信号表示选中该设备。![image-20240923220948886](C:\Users\z3254406361\AppData\Roaming\Typora\typora-user-images\image-20240923220948886.png)

## 12.3.通信过程

![image-20240923221227942](C:\Users\z3254406361\AppData\Roaming\Typora\typora-user-images\image-20240923221227942.png)

与其说是传输数据，不如说是交互技术，因为从机或主机八个周期发送一个数据的同时也正好接收了一个数据。

## 12.4.极性和相位

与IIC对比，SCL高电平接收数据，低电平放数据到总线上，且SDA,SCL空闲为高电平，这是定死的。但SPI是可以有2x2=4种工作模式的。

CPOL极性，决定SCLK空闲时状态。

CPHA采样，决定上升沿还是下降沿采样。

![image-20240923222302288](C:\Users\z3254406361\AppData\Roaming\Typora\typora-user-images\image-20240923222302288.png)

# 13.IIC和SPI的异同

![image-20240923222406886](C:\Users\z3254406361\AppData\Roaming\Typora\typora-user-images\image-20240923222406886.png)

# 实验总结

exyons_4412是SOC，即片上系统。其上面不仅仅只是有一块ARM处理器，还集成了许多其他的控制器，存储器ROM,RAM，比如GPIO,IIC,UART等控制器。ARM可以通过STM,LDM这两条ARM指令来对SOC上控制器的寄存器进行存取从而操作控制器控制外设。控制器叫控制器是因为其引脚连接外设，可以控制外设。由控制器延申出的引脚，再把ARM处理器与这些控制器集成封装成一块芯片，这块芯片就叫做4412，4412芯片引脚其实就是控制器上的引脚。然后芯片引脚继续往外延申，连接到了芯片之外的一些电路，这些电路就叫做外设。故芯片可以通过引脚发送信号给外设，从而控制外设。

外设有复杂外设（二级外设）和简单外设。简单外设只需要引脚发送高低电平或者PWM就能控制外设运行。复杂外设自身集成了芯片，芯片内部有寄存器，往寄存器里写数据来配置寄存器从而配置外设的参数后才可以用，而配置这些参数，肯定需要4412芯片通过引脚利用通信协议如UART,IIC等把这些参数作为通信数据传给外设，外设接收后存到寄存器，这样就完成了复杂外设的配置。

故4412与简单外设通信，只需要产生控制信号的引脚控制外设即可，而与复杂外设通信，除了要控制信号控制外设，肯定还要有通信引脚来传输参数配置外设。
