# >>>>>>>>C语言>>>>>>>>

# 	1.数据的表示

## 				1.1.数值数据表示

- **数码**：表示数的符号如：1 ，2，3    

- **基**：  数码的个数10进制0-9

- **位权**  

- **数制(进制)**

  ```c
  0Bxxxx//四位二进制数，4*1bit大小
  
  0Oxxxx//四位八进制数，4*3bit大小
  
  0x xxxx//四位16进制数，4*4bit大小
  ```

## 				1.2.进制与进制间的转换

- **十进制与其他进制互转**：
  		连续除以目标进制的基数，从低到高记录余数，直至商为0，反之，每一位乘以该位位权再相加的总和。
- **二进制与2^n进制互转**：
          对于二进制，每n位为一组计算的结果作为目标进制的一位，反之每一位拆成n为二进制。
- **其他进制与其他进制互转**：
          利用十进制或者二进制作为中间结果，即先其他进制转二进制或者十进制，再由十进制或二进制转其他进制。

## 1.3.计算机中数据的单位

内存的最小单位为**字节**(B),每个字节的空间都有一个地址，类似于每个字节是每个房间，地址就是每个房间的房间号。

## 				1.4.原码，反码，补码

- 计算机中存的是补码形式——两个绝对值相同的正负数的补码相加舍去最高位的进位的结果为全0

- 正数：原码（除了符号位，其余位是该数的绝对值的二进制），反码，**补码**均一样

- 负数：原码（除了符号位，其余位是该数的绝对值的二进制），反码符号位(最高位)与原码一样，其余位为原码取反，**补码**为反码+1

- **示例**：

  ```c
  int a=0xffffffec;
  	//则为变量a所开辟的内存中存的就是0xffffffec，用%d打印==>0xffffffec==>0x10000014==>转十进制-20，用%#x打印==>直接打印0xffffffec
          
          
  int a=-20; 
  	//赋值用的-20,是10进制有符号整数,则a在计算机中存的就是20转16进制再转补码==>0xffffffec，用%#x打印将-20转32位的补码形式(也即在内存中存的数据）==>转16进制==>打印
  ```
  
  汇编编译的结果：
  
  ```bin
  0x00000000  E3E02013  MVN       R2,#0x00000013
  0x00000004  E59F3014  LDR       R3,[PC,#0x0014]
  0x00000008  E5832000  STR       R2,[R3]
  
  
  0x0000000C  E3E02009  MVN       R2,#0x00000009 
  0x00000010  E59F300C  LDR       R3,[PC,#0x000C]
  0x00000014  E5832000  STR       R2,[R3]
  
  注:只有10进制可以用+，-来表示符号，而其他进制的符号位都是最高位用0，1表示正负的，所以其他进制赋值给变量时，这个值本身就是它的补码。不需要对其进行额外的补码转换，因为它已经是以补码形式表示的有符号整数。内存存的就是该进制转16进制的样子，不需要进行补码的转换。而10进制存时，需要进行补码的转换。
  ```

# 	2.C语言数据类型

在 C 语言中，数据类型指的是用于声明不同类型的变量或函数的一个广泛的系统。**变量的类型决决定变量的存储空间及数据范围**。

## 2.1.分类

- **基本数据类型**：整型、字符型、浮点型
- **构造类型**：数组类型、结构体类型、共用体类型、枚举类型
- **指针类型**
- **空类型**

## 		2.2.整型家族

有符号和无符号的char、short、int、long、long long均可以存储整数类型数据，其中short、int、long、longlong均属于整型家族的不同类型，32位和64位的区别仅在于long分别为4，8个字节。

### 		2.2.1整型变量

- int、unsigned int  
- short、unsigned short  
- long、unsigned long
- long long、unsigned long long

### 2.2.2 整型常量（4字节）

- **带前缀的常量：区分进制**
  十进制：不需要任何前缀
  八进制：0开头的前缀
  16进制：0x开头的前缀
- **带后缀的常量：区分有无符号，区分长短整型**
  L或l==>长整型
  U或u==>无符号整型

## 			2.3.字符型家族

### 2.3.1字符变量

可以直接理解成占一个字节的整型变量。

`char `（0~255）、`unsigned char`（-128~127 ）

**人为规定**：
				有符号字符变量存放其最小值-128时，其内存存的是10 000 000

### 2.3.2 字符常量（4字节）

用单引号括起来的ASCII码表中的字符。

### 					2.3.3 截断

将一个整型数据存储到char变量里面，由于char变量是一个字节大小，对于四个字节大小的整数，会发生截断，只**<u>保留补码的最后8位。</u>**

### 					2.3.4 整形提升

将截断后的8位补充到32位，并不是说给char类型变量的空间申请32bit的空间，而是进行运算时系统cpu把它进行整型提升再计算（这里的计算不单单是算术运算，打印也算是运算），并非真正的内存中提升。什么数据类型固定在计算机中存的几个字节就是几个字节，其他补位无非就是要用到该数据时，从内存里拿出该数据后再进行整型提升后再送到cpu里运算。

对char这种有符号位的采用左补24个符号位（截断后的8个比特位的符号位)。对unsigned char 这种无符号位的采用直接左补24个0。

## 					2.4 整型/字符型的打印

1. **%u**
   %u是以无符号的形式打印整数，所以我们整形提升后得到的32位补码直接可以作为原码打印。
2. **%d**
   %d是以有符号的形式打印整数，所以，我们整形提升后得到的32位补码，要先观察32的第一位，如果是1，则是**负数，需要将这32位补码转化为原码**；如果是0，则**是正数**，直接打印即可。
3. 只有**整型和字符型**才有有符号和无符号之分。

## 2.5 浮点型家族

### 2.5.1浮点型变量（8字节）

float-4字节，double-8字节 ，long double（c99新增，大小看编译器）

### 2.5.2 浮点数常量

**浮点型常量默认是`double`类型的**

0.008==8E-3       8000==8E+3

### 2.5.3浮点数表示

f=(-1)^s\*M\*2^E

```c
							float   double

​	s(占一位）：符号位  			1     1

​	E：指数           				8(127偏移量)    11(1023偏移量)

​	M:尾数，有效数位(规格化成1.xxxxxx，把1.去掉就是M)   			23    52
      
      
 0.125 == 0.001 = 1.000 * 2^-3
  
 s == 0
 E == -3+1023 = 1020 == 011 1111 1100
 M == 000 == 000000000000000000000... ...
```

### 				2.5.4 浮点类型比较

当一个小数可以精确表示时，`double`和`float`类型取同一个小数是相等的；当一个小数不可以精确表示时，`double`和`float`类型是不相等的。**浮点数做比较，利用差值的绝对值来与人为规定的精度来做比较**。

```c
#include <stdio.h>
#include <stdlib.h>
int main(){
    float a = 0.2;
    float b = 0.5;
    printf("%.15f,%.15f\n",a,b);
    if (a == 0.2)         
        printf("a == 0.2\n");
    else
        printf("a != 0.2\n");
    if (b == 0.5)
        printf("b == 0.5");
    if (abs(a - 0.2) <= 0.00001)//才是严谨写法
        printf("a == 0.2\n");
    return 0;
}
//  0.200000002980232,0.500000000000000
//  a != 0.2
//  b == 0.5
//  a == 0.2
```

## 		2.6 布尔类型_Bool

### 2.6.1布尔变量（1字节）

占一个字节

### 2.6.2布尔常量

只有 0 和 1

<u>**头文件stdbool.h中**</u>为`bool`，也定义了1为`true` 0为`false`

## 		2.7 void类型

作为函数返回值或者参数，指针类型，但是，不能***直接对 `void `型指针进行解引用***，而要先将其转换为特定类型的指针。可以有`void*`变量，但不能用`void`变量。

```c
void a = 5;
	//报错
void *a = "abcdef";
int b = 3;
void *a = &b
    //void类型变量不能接受任何赋值，但void型指针可以接受任何类型指针赋值
```

# 3.C语言类型转换

## 3.1.自动类型转换

- 赋值操作：结果转为`=`左边操作数的类型
- 二元运算：结果数转为精度高的类型

## 3.2.强制类型转换

`(type_name)expression`

## 				3.3.指针类型转换

数据类型大的转数据类型小的指针，可以利用指针查看数据类型大的指针里面存的是啥，比如`int a; char p = &a;p+1`，每次只移动一个字节，但`a`有四个字节，所以`printf("%u",p)`就可以看a的每个字节是怎么存的，从而判断大小端。`char`类型的转`int`类型的访问，会出错，类似于越界（超出指针所指空间范围）出错，故得到的值是随机的。

# 	4.运算符

## 4.1.分类

- 算术运算符(**结果均为右值**)：`+`、`-`、`*`、`/`、`%`、`++`、`--`
- 关系运算符:`>`、`<`...
- 逻辑运算符
- 赋值运算符：赋值，算术复合赋值，位运算赋值
- 特殊运算符：三目条件运算符，逗号运算符, **`sizeof`运算符**

## 4.2.自增

`[]++`看成，先`[]`参与运算（只参与一次运算，随之i就++），然后再`[] = [] + 1`，结果返回的**是右值，即x存的内容，是常量**。

`++[]`，先`[]=[]+1`，然后`[]`再参与运算，结果返回的是**左值，是[]自身。**

```c
int a[7] = {1,2,3,4,5,6,7};
int *p = &a[1];
int y;
y = (*--p)++;
//--优先级大于*==>【】这一坨是（*--p)，故先执行y = 【】，然后【】++，【】又拆成先p-1,再参与*,所以【】这一坨结果是a[0],
//故,y = a[0],a[0] = a[0] + 1
y = (*p--)++;
//有先算括号里的，然后用括号里的结果把【】这一坨换了即可！！
//(*p--)的结果是*p,虽然执行了*p,p--,但其返回结果p--并不参与后续运算
```

## 			4.3.取余

操作数只能是整数

## 			4.4.位运算

- **应用**：修改一个数a的第n位的值，需要用到另一个数b而另一个数b可由（0`>>`n)来得到，其中n表示要修改的是第几位。

- **操作数类型**：只能是整型和字符型

- **左移**：有/无符号：左移多少位，补多少个0

- **右移**：无符号，补0，称为逻辑移位；有符号，左边补最高位（符号位），称为算术移位

- **异或**：交换两个数

  ```c
  //原地交换两个数的值:
  a=a^b;
  b=a^b;
  a=a^b;
  //注意a和b不是同一个变量，他们的值可以一样，但他们所开辟的空间不能是同一个。
  ```

## 		4.5.逻辑运算

逻辑短路：

```c
int a = 0;
int b = -1,d = 0;
c = a++ && ++b && d++;
printf("%d,%d,%d,%d\n",a,b,d,c)
// 1，-1,0,0
```

## 4.6.逗号运算符

多个表达式用逗号分开，每个表达式的值分别运算，但整个表达式的值是最后一个表达式的值。

```c
while((0,0,printf("Ha Ha\n")));
//死循环，一直打印Ha Ha
```

# 5.构造类型

## 5.1.一维数组

### 5.1.1.定义和初始化，引用

```c
#include <stdio.h>
int main(){
    /*不初始化*/
    int a[5];                //全局数组默认是0，局部数组不确定
    /*定义时初始化,部分初始化*/
    int b[5] = {1,2,3};     //被初始化的元素为给定值，其余全为0
    int c[5] = {0}或者{};   //局部数组全部初始化为0
    /*定义后初始化*/
    int i;
    int d[5];
    for (i = 0; i < 5;i++)
        d[i] = i;
    /*缺省数组大小初始化*/
    int e[] = {1,2,3};      //数组大小赋值时给了几个元素大小就是几，这时不能定义后再赋值
    
    /*数组引用*/
    for (i = 0; i < 5;i++){
         a[i] = i;
    }
    return 0;
}
//数组大小一旦给定，不能再改变。
```

### 5.1.2.一维数组的内存分配

1. 数组的元素是连续存储的
2. 数组占用内存空间 = 数组元素个数*`sizeof`(数据类型)

### 5.1.3.数组名的含义a

1. 数组名代表整个数组，是常量，不能被修改
2. 数组名代表整个数组的首地址
3. 数组占用内存空间 = `sizeof`(数组名)
4. 数组元素个数 = `sizeof`(数组名)/`sizeof`(数组元素的数据类型)

### 5.1.4.数组越界

数组越界编译不报错，数组越界访问运行不报错，数组越界修改运行会报断错误。

## 5.2.二维数组

### 5.2.1.二维数组的定义和初始化a

```c
#include <stdio.h>
int main(){
    /*定义*/
	int a[2][2];
    /*初始化*/
    int a[2][2] = {{1,3},{2,4}};
    printf("%d %d\n",a[0][0],a[0][1]);
    printf("%d %d\n",a[1][0],a[1][1]);
    int b[2][2] = {{1},{4}};//未初始化的地方系统赋值为0
    printf("%d %d\n",b[0][0],b[0][1]);
    printf("%d %d\n",b[1][0],b[1][1]);
    int c[][2] = {{1,2},{2,4}};//不能省略列数
    printf("%d %d\n",c[0][0],c[0][1]);
    printf("%d %d\n",c[1][0],c[1][1]);
    /*
    	按行且连续存储，即每行最后一个元素地址与下一行第一个元素地址相邻
    	故当赋值只有最外层{}时，默认从第一个元素依次往下赋值，没有赋值到的地方
    	默认为0
    */
    printf("%p %p\n",&a[0][0],&a[0][1]);
    printf("%p %p\n",&a[1][0],&a[1][1]);
    int d[1][3] = {1,2};
    printf("%d %d %d\n",d[0][0],d[0][1],d[0][2]);
 	return 0;   
}
/*运行结果*/
1 3
2 4
1 0
4 0
1 2
2 4
0x7ffd580bd3b0 0x7ffd580bd3b4
0x7ffd580bd3b8 0x7ffd580bd3bc
1 2 0
```

### 5.2.2.二维数组的理解

`a`是二维数组名，由三个元素组成，每个元素`a[i]`由包含4个元素的一维数组组成，`a[i]`是每个一维数组的名字。

取下标[]等价于\*（），*()与&可以相抵，对于二维数组：a\[i][j]==\*(a[i]+j)，即\*加（）相当于取下标。

a为数组名,

- 如果a为一维数组：\*a==a[0];\*(a+i)==a[i]==元素内容；
- 如果为二维数组:\*a==a[0],\*(a+i)==a[i],a[i]为第i个一维数组的数组名，\*a[i]==a\[i][0],\*(a[i]+j)=a\[i][j];
- 数组名代表数组首地址，和整个数组

- 数组占用内存空间=sizeof(数组名)

- 数组行数=sizeof(a)/sizeof(a[0])

- 数组列数=sizeof(a[0])/sizeof(元素类型)

## 5.3.字符数组

### 5.3.1.定义

元素的数据类型是字符型

### 5.3.2.初始化

一维二维同int型数组一样，缺省地方赋值为'\0'

```c
char ch[5] = {'H','e','l','l','o'};
char ch[5] = {'B','o','y'};//缺省的地方默认为'\0'
```

## 5.4.字符串（常量-sizeof==所占空间，包含\0）

### 5.4.1.定义

C语言中无字符串变量，一般用字符数组处理字符串，结束标志'\0

```c
/*大小均为6*/
char ch[6] = {"Hello"};
char ch[6] = "Hello";//字符串常量初始化
char ch[] = "Hello";
/*不严谨*/
char ch[5] = "Hello";

char ch[6];
ch = "Hello" //error
注意:字符串不可以直接赋值给字符数组数组名。此时用strcpy函数，类似于用循环遍历字符数组，一个字符一个字符赋值.
    printf打印字符串%s只适用于有\0的字符串，对于没有\0的不是字符串而是字符数组，只能老老实实地通过for循环打印
```

### 5.4.2.字符串长度判断

- \0有两种含义，一种是字符串结束表示，还一种是表示八进制的前缀0.
- 077，会被认为是0，7，7，三个字符，但\077，则会被认为是一个八进制字符。
- 同时由于编译器的算法默认匹配最长的字符，故\077不会被看成\0 和7 、7三个字符，而是以最长优先的原则来匹配。
- 如果是\08，则是两个字符\0和8，因为八进制最大数码为7.

## 结构体

### 								结构体赋值

- 声明结构体变量后赋值

  ```c
  1)对每个成员依次赋值
          stu1.sno = 123;
  	    strcpy(stu1.name,"Tom");
  	    stu1.age = 18;
  2)用{}进行一次性赋值，但要进行强转
          stu1 = (struct student){123,"Tom",18};   
  ```

- 声明结构体变量时赋值

  ```c
  1)要与结构体属性定义顺序保持一致
  		struct st stu={值1,值2,值3}
  2)字符串可以直接赋值给字符数组数组名	
  		struct st stu={.属性1=值1,.属性3=值3}
  ```

- 定义结构体并声明结构体变量时赋值

  ```c
  struct st{
  	属性1;
  	属性2;
  	属性3;
  }stu1=赋值方法2,stu2=赋值方法2
  ```

### 				结构体大小(字节对齐)

**含义**：字节对齐主要针对结构体而言，通常编译器自动对其成员变量进行对齐，以此提高存储效率。让计算机在特定的内存地址去拿特定的数据类型。

**数据类型永远只是用来决定对齐数的**

**作用**：比如64位系统，一个指针也即一个地址大小为8字节，故当数据对齐8字节时，如果数据类型大小正好8字节，则访问一次内存就可以全部读取出来，其他小于8字节的，一定是2的倍数，故访问一次内存可以读取好几个数，如果不对齐，可能一个数据占两个地址，就需要访问两次内存。降低访存次数，以空间换时间。

**注意：**对齐会浪费空间，故应该能减少浪费就该减少浪费，通过调整成员的声明顺序等。

```c
/*结构体对齐后，其大小一定为最大字节数数据类型的字节数的整数倍*/
/*每个成员的起始地址（偏移量）为有效对齐的倍数，能整除有效地址*/
           自    默(64位)    有   大小

char       1     8     		1     8

double     8     8     		8     8

int        4     8     		4     4

int 	   4 	 8     		4	  4

char       1     8      	1     8
//自身对齐：数据类型本身的大小
//默认对齐：跟系统有关，64为为8字节，32位为4字节
//有效对齐：min(自身对齐，默认对齐）   
```

**1.如果嵌套结构体**：嵌套的结构体对齐到自己的最大对齐数的整数倍处，即嵌套结构体的对齐数是自己成员的最大对齐数，并不是对齐到该结构体自身大小的整数倍处，结构体的整体大小就是所有最大对齐数（包含嵌套结构体的对齐数）的整数倍。

**2.如果成员是数组**，其有效对齐位就是为啥数据类型的数组，其对齐位就是啥，数组无非就是n个相邻数据类型相同的数，并不改变对齐位。

### 取消字节对齐

1.在GCC编译器中，可以使用__attribute__((packed))属性来强制结构体成员非字节对齐。

2.**#pragma pack****（push****，1****）//** **设置对齐方式为1****字节**

**#pragma pack****（pop****）//** **恢复之前的对齐方式** 

### 结构体数组

赋值语法：

```c
struct 结构体名 数组名[] = {{},{},{}...};
struct 结构体名 数组名[] = {[0] = {},[1] = {},[2] = {},...};
```

## 		位域

### 			位域的定义

一个字节8位被分为几块区域，每块区域可以取一个名字并存放不同的信息，即一个字节存放多种信息，从而大大节省空间。

位域的定义：

```c
struct A{
    unsigned char a:2;
    unsigned char b:3;
    unsigned char c:3;//成员类型只能是整数类型(包括char)和枚举类型
};

//赋值使用方式同结构体一样

struct A t;
t.a = 3;//取值范围位0~3
t.b = 2;//0~7
t.c = 5;//0~7
printf("%d %d %d\n",t.a,t.b,t.c)
```

### 位域的大小计算

一个位域成员不允许跨越两个 unsigned int 的边界，如果成员声明的总位数超过了一个 unsigned int 的大小， 那么编辑器会自动移位位域成员，使其按照 unsigned int 的边界对齐。

不要被位域成员前面的数据类型大小迷惑，成员具体大小还是要看其占多少位，记住，**数据类型永远只是用来决定对齐数的**。

```c
struct S1{
  int a:16; 
  int b:16;
  int c:16;
  char d;
};
sizeof(S1) = 8;
```

## 共用体

### 		定义作用

共用体也叫联合体，就是不同数据类型的数据使用共同存储区域，其大小为最大数据类型的空间。

作用：
			1.发数据包之前不知道发什么数据类型，事先定义好几种数据类型，但都占用同一块空间。
			2.当老师和学生可以用同一个结构体时，不必声明两个结构体变量来分别存贮老师和学生，只需要定一个共同体来存贮即可		

```c
struct person{
    char name[10];
    int age;
    char sex[5];
    char phone[11];
};
//赋值使用方式同结构体一样


union un
{
	int num;
    char ch;
    struct person student;
    struct person teacher;
};

//共用体上的那些成员都是共享一块内存空间的。
//共用体的大小为其成员，包括结构体成员的大小的最大值，且该最大值为对齐数的倍数，对齐数计算方法同结构体一样
```

### 		共用体与结构体的区别

1.  大小计算不一样

   ```c
   union un{
       int num;
       char s[7];
   };
   //最大对齐数为4，而成员所占最大空间为7，故要对齐到8位,sizeof(union un) == 8
   union un{
   	char a;
       char b[7];
   }
   //最大对齐数为1，而成员所占最大空间为7，故只要对齐到7位，sizeof(union un) == 7
   ```

2. 赋值方式

   ```c
   如果用{.成员1=值1，.成员2=值2} 的方式赋值，则最后共用体的所有成员的值为值2；
   
   如果用共用体变量 = {值} 的方式赋值，则{}里只能有一个值。
   ```

## 枚举型

### 		 定义

```c
enum e {
	one,//第一个成员值默认为0，可以指定他的值
   	two,//其他成员默认都是在前一个成员的基础上加1，也可以指定他的值.
   	three,
   	four，//，号不是分号
    five
};

//定义和赋值同结构体一样
enum e t;
t = one;
printf("%d\n",t);

//即确定某个变量只能是某几个值，则可以为枚举型。
//同一程序下，不同枚举类型的成员不能重名

枚举成员是一个常量，可以将其作为定义数组的长度大小，也可以将其作为一个整型值初始化或赋值给一个整型变量，甚至将其作为表达式的一部分
```

###   		特点

   	1.默认第一个成员从0开始，后面成员依次+1
   	
   	2.有特定值的成员后面，从特定值开始依次+1
   	
   	3.同一个枚举类型中，成员值可以相同
   	
   	4.不同枚举类型中，成员名不能一样（成员重复定义）。

# 6.指针类型

## 6.1.指针的基本用法

### 6.1.1指针的作用

- 使程序简洁，紧凑，高效
- 有效地表示复杂的数据结构
- 动态分配内存
- 能直接访问硬件
- 能够方便的处理字符串
- 得到多于一个函数的返回值

### 6.1.2.内存地址

在计算机中存储器的容量是以字节为基本单位的，内存的每个字节给一个编号，内存编号也叫内存地址。

### 6.1.3.指针和指针变量

1. 指针就是内存地址
2. 指针变量，存放内存地址的变量

### 6.1.4.指针的目标

指针指向谁，谁就是指针的目标

### 6.1.5.指针的解引用

- *p <==>指针的目标
- p<==>指针变量

- &p<==>指针变量自己占用的存储区域


### 6.1.6.指针的大小

看系统多少位，32位系统，大小4字节；64位系统，大小8字节

## 6.2.空指针

空指针可以接受任何类型指针的赋值。

## 6.3.指针的运算

### 6.3.1指针的赋值

只能赋地址常量或者指针变量，不能是普通整数，0除外

- 把一个普通变量的地址赋值给相同数据类型的指针
- 一个已有地址值的指针变量赋值给相同类型的指针
- 一个数组的地址赋值给相同数据类型的指针

### 6.3.2指针的算术运算

指针运算是以指针所存放的地址作为运算量而进行的；

指针运算的实质就是地址的计算。

移动步长是指针的目标，指针+1移动多少空间，究其本质还是要看指针目标的类型是啥。

指针有自增，自减，两个指针相减，但没有两个指针相加。

- 自增自减
  \*p++和(\*p)++不一样，一个指针变量自身++，变了；一个指针变量自身没变，但其所指目标++，变了

- \*++p和++\*p

  ```c
  ++ 优先级高于*
  *p++;//等价于先p++再*p，即指针先参与*，再++。
  (*p)++;//等价于p的内容++
  ++*p;==++(*p)
  *++p;==++p->*p
  *（p++）==*p++
  //记住（）并不影响后置的++/--仍然后执行的特性。
  ```

- **应用**：大小端问题

### 6.3.3.指针的关系运算

大小的比较比的就是地址的大小，不是地址内容的大小。

指针的运算是以指针所指向的类型的数据的个数为单位去描述的，并非是对指针所指向的地址的字节为单位运算的。即p+1，的结果并非p的地址+1，而是要看p所指空间存的是啥类型数据，改类型数据所指空间是n个字节，则p+1是移动n个字节。指针的比大小比的是其所指向的地址的大小，而不是地址里存的数据的大小。

## 6.4.指针与数组

### 6.4.1.指针与一维数组

数组指针是指数组在内存中的起始地址，数组元素的地址是指数组元素在内存中的起始地址。

一维数组的数组名就是一维数组的指针

int a[ ],*p; p = a; *p == a[0]  == *(a+0) == p[0];

即[ ] == * ==解引用

### 6.4.2.指针与二维数组

1. 一级指针与二维数组
   用一级指针遍历的依据在于二维数组在内存中是连续存储的。

2. 数组指针与二维数组

   `a`是二维数组名，由三个元素组成，每个元素`a[i]`由包含4个元素的一维数组组成，`a[i]`是每个一维数组的名字，即a[i]也是数组名，不能a[i]++     

   二维数组名代表二维数组起始地址，数组名加一，是移动一行元素。因此二维数组名也被称为行地址。

   行指针变量，存放行地址的指针变量，int(\*p)[3],[ ]里的3指的是指针加一移动一行，一行有3个元素。

3. 行指针，int(\*p)[x] 行指针**(也叫数组指针），**p+1指针移动x个元素数据；

4. 一维数组名取&变成行地址；二维数组名表示行地址，取解引用变为一维数组名。

   ```c
   int a = 10;		
   int *p = &a;
       //p所指空间存的是a的值，一个整数10，但p是int型，故p+1移动4个字节
   	//a+1 == 11
   int a[5] = {0};
   int (*p)[5] = &a;
   	//p所指空间存的是数组a，一个数组a[5]的首地址，但p是int型的行指针，故p+1移动4*5个字节
   	// a+1 == &a[6]
   int *p = (int*)&a;
   	//p所指空间存的是a,一个数组a[5]的首地址,但p是int型的指针，故p+1移动4个字节
   	//a+1 == &a[6],
   ```

### 6.4.3.数组名与指针的区别

- 含义不同
  数组名代表一个数组，存放相同类型的元素；指针代表存储地址的变量。

- 使用不同
  数组名是地址常量，不能修改；指针是变量，可以存储其他变量，也可以自增。

- 长度不同
  sizeof数组名 == 整个数组所占空间大小，sizeof指针 == 指针大小，与操作系统有关

- 本质不同

  指针是变量，数组名是常量

### 6.4.4.数组指针与指针数组的区别

int \*p[5]指针数组，是一维数组，每个元素都是int*

指针数组经常结合二维数组使用，存储每行首元素地址，本质是数组，存储的内容是指针而已。

int (*p)[5]数组指针，指向的内容是含有5个元素的一维数组，本质是指针，一维数组名取地址，或者二维数组名都可以赋值给它。

## 			6.5.字符指针与字符串

任何指针能够进行存取数据的前提是其内容，也即其指向的是一块与指针相同类型的空间，该空间可以是malloc动态申请的，也可以是声明该类型变量时为该变量开辟的空间（不能是局部变量的空间，因为局部变量的会被释放）。

char *s = "hello",并不是把字符串赋值到指针中，而是把字符串的首地址给p了。

```c
char *s="hello";
	//s为字符指针，其所指的地址是字符串常量地址，常量存放在内存的常量区，也即静态区，其可以访问，但不可修改，否则会报段错误。这里说的常量不是指这个指针是常量不可变的，而是指针所指的内容是常量不可变的
char s[]="hello";
    //s为数组名，其所指空间为一个数组变量，即所指内容可以改变，故scanf（"%s",s)可以。
char *s="hello"
    //s为字符指针，其所指向的是一个字符串常量，即所指内容不可变，故scanf("%s",s)不可以，否则会报段错误
```

## 			6.6.多级指针

int **p == int\*  *p,\*p代表p是一个指针，int\*代表p所指空间存的是int\*类型，即是指针。

多级指针的运算也是以指针目表为单位的。即以指针的大小8字节（64位系统）为单位的

## 6.7.void指针

- 万能指针其实就是void*类型的指针，而void\*指针一般被称为通用指针或叫泛指针。
- void指针不属于任何类型，不可以对其进行算术运算，因为编译器不知道要增减多少个字节，必须强制为其他类型才可运算解引用等。
- 使用前必须初始化，被初始化时，其他类型指针赋值给void指针不报错，但是使用初始化好了的void指针进行运算比如解引用，赋值等时必须强转。

## 			6.8.const指针

- 由const修饰的数据就是常量了，不能修改，为只读。
- 修饰变量：
  const int  var,修饰的是int，即var空间里的int类型的值不能直接修改，但可以通过指针int的指针间接修改
- 修饰指针：
  const int*p,const修饰的是int，即指针p指向的是常量int的地址，也即指针p所指向的地址的内容不能变，但可以改变p所指向的地址，也即p指向另外一个常量的地址。
- int\* const p修饰的是指针p，即指针p是常量，也即不可以改变p的内容也就是p所指向的地址，但可以改变p所指向地址的内容。

## 6.9.函数指针

- 存放了函数的入口地址，函数名代表了函数的入口地址，类似于数组名；

- 函数指针定义： 
      char (*p)(形参1，形参2);即一定要加（），赋初值：p=fun,   使用：p(形参1，形参2)
- 函数指针数组定义：
      在函数指针p后面加上[数组大小].char(*p[N])(形参1，形参2)比如，p[0] = add ;p[1] = sub......
- 作用：
      相同类型的好几个函数比如加减乘除，用p来改变所指向的函数来进行操作。

# 7.程序控制结构

- <u>判断条件(（赋值语句））多加一个括号告诉编译器我=就是赋值，不是==手误漏写了一个=</u>
- `if`不加花括号时，默认只匹配一条语句，而`if else`算作一套C语句。
- **浮点型**不能做 `switch`的参数类型
- `continue`语句是循环控制语句，表示结束本次循环，进行下一次循环，而不终止整个循环的执行。`switch`语句是条件分支语句，做多条件判断，不能使用循环控制语句。
- break跳出的是最里面的一层循环

# 	8.输入输出专题

## 			8.1.行缓冲(scanf)

- 当我们使用`scanf`函数输入数据时，输入的字符首先被放入到一个缓冲区中。这个缓冲区是行缓冲的，意味着输入的字符会在这里被暂时存储，直到我们按下回车键进行换行，然后才会进行I/O操作。
- 例如，如果我们使用`scanf`输入一个整型数据`10`，当我们按下回车后，标准输入缓冲区中实际上存储的是“10\n”，其中`\n`是换行字符。

## 			8.2.匹配和读取(scanf)

- `scanf`函数内部有两个“扫描探头”：一个工作在匹配字符串上（匹配探头），另一个工作在输入流上（输入探头）。
- 匹配探头首先读取格式字符串中的第一个匹配字符（如`%d`、`%f`等）。如果它是一个格式符，那么输入探头就开始工作，从输入流中读取相应类型的数据，如果不是格式符，是其他字符如空白符，逗号等，输入也需要空白符换行符来匹配，如scanf里显示地写了逗号，则输入也要，号，否否则直接结束。
- ```c
  int ret,a,b;
  ret = scanf("%d,%d\n",&a,&b);
  //输入12 2 回车---->a = 12   /,匹配到空格-->sacnf直接结束/ret = 1
  //输入12,2 回车---->a = 12 ,b = 2,回车不会结束scanf，此时不会在最后一个字符遇到\n时停止，需要再输入其他的非\n的字符才可以结束输入
  ```

- 输入探头会扫描输入流中的字符，并将它们存放到一个输入缓存区中。然后，输入缓存区会判断现存的这些字符是否与当前的格式符匹配。

## 			8.3.转换和存储(scanf)

- 在`scanf`函数中，空格（包括空格符、制表符`\t`和换行符`\n`）通常被用作输入字段之间的分隔符，但它们的具体行为取决于格式说明符（如`%d`, `%s`, `%c`等）和输入缓冲区的状态。

  1. **对于`%d`、`%f`等数值类型**：
     当`scanf`读取一个数值类型（如整数或浮点数）时，它会跳过任何前置的空白字符（**<u>包括空格、制表符和换行符</u>**），然后开始读取数值。一旦读取到一个非数值字符（如字母或符号），它就会停止读取并返回。但是，这个非数值字符（以及任何后续的字符）仍然会留在输入缓冲区中。
  2. **对于`%s`字符串类型**：
     当`scanf`使用`%s`格式说明符读取字符串时，它会读取直到遇到第一个空白字符（空格、制表符或换行符）为止。这意味着，如果输入字符串中包含空格，`%s`将只会读取到第一个空格之前的部分。而且，任何读取字符串后的空白字符都会留在输入缓冲区中。
  3. **对于`%c`字符类型**：
     当`scanf`使用`%c`格式说明符读取字符时，它会读取并返回下一个可用的字符，不论它是什么。这包括空格、制表符和换行符。因此，如果你试图使用`%c`读取一个字符后立刻读取另一个字符，但中间有一个换行符，`%c`将会读取并返回这个换行符。
  4. **对于换行符（`\n`）**：
     如果`scanf`的格式字符串中没有显式地包含`%c`来读取换行符，并且输入中包含了换行符，那么换行符通常会被留在输入缓冲区中，直到下一次读取操作。但是，如果`scanf`的格式字符串中包含了`%*c`（其中`*`表示跳过该输入项），并且放在适当的位置，它可以用来跳过并丢弃换行符。

  总的来说，空格和换行符在`scanf`中的行为取决于你使用的格式说明符和输入缓冲区的内容。如果你需要更精细地控制输入，可能需要考虑使用其他函数（如`fgets`）来读取一行输入，然后使用字符串处理函数（如`sscanf`、`strtok`等）来解析输入。

- ```c
  #include <stdio.h>
  #include <string.h>
  int main(){
      int ret;
      int a,b;
      char c;
      memset(&ret,0,13);
      ret = scanf("%d%d%c",&a,&b,&c)//12#32\n
      printf("%d\n",a);//12
      printf("%d\n",b);//0
      printf("%d\n",c);//0
      printf("%c\n",getchar());//#
      printf("%c\n",getchar());//3
      printf("%c\n",getchar());//2
      printf("%c\n",getchar());//\n
      return 0;
  }
  ```

  

- 转换后的数据会被存储在提供给`scanf`函数的变量中，供后续程序使用。

- `scanf`函数会根据格式字符串中的格式说明符的顺序，按照变量的地址顺序将数据存储到相应的变量中。

### 			8.4.scanf的返回值

- `scanf`函数返回成功读入的数据项数。如果所有的数据项都成功读入，那么返回值就是格式字符串中格式说明符的数量；如果只有部分数据项被成功读入，返回值就是实际成功读入的数据项数；如果读入失败或遇到文件结束符，返回值就是EOF（End Of File）。

# 	9.函数

## 				9.1.函数的基本用法

- 函数的调用
  函数名(实际的参数)，如果函数有返回值，可以作为一个运算量出现在表达式中;
- 函数的声明
  函数类型 函数名（形参），其中形参的变量名可以与函数定义的一样，可以不一样，甚至可以省略.只保留变量的数据类型

## 				9.2.函数的传参

将实参的值或者地址传递给形参的过程

### 9.2.1.全局变量

全局变量就是在函数体外说明的变量，全局变量一经定义后就会在程序的任何地方可见。

### 9.2.2.值传递

调用函数将实参传递给被调用函数，被调用函数将为形参开辟新的存储空间，在函数中改变形参不会影响到实参的值。

### 9.2.3.指针传递

### 9.2.4.一维数组传参

- 全局传参，即定义数组为全局数组
- 指针传参，即实参传入数组的首地址即数组名，形参为相同类型的指针
- 数组名传参，`fun(int array[],int size)`，**形参int array[]本质上也是一个指针变量，不是真正的数组名，不具有数组名`sizeof(array)`==数组总大小的性质。**

### 9.2.5.字符数组传参

与一维数组传参一样，唯一不同的是不要size，因为字符串本身带有'\0'来作为结束符。

### 9.2.6.二维数组传参

- 普通的一级指针作为形参，二维数组的a[i]作为实参,`fun(int *a,int n,int m);fun(a[i],n,m)`
- 行级指针作为形参，二维数组名作为实参；`void fun(int (*a)[n],int m,int n)或者void fun(int a[][n],int m ,int n)`
- 普通二级指针作为形参，`int *p={a[0],a[1],a[2]),fun(p,m,n),void fun(int* *a,int m,int sn)`

## 				9.3.指针函数

### 9.3.1.概念及用法

数据类型 *fun（形参1，形参2........）,返回值为地址量。

指针函数返回值只能返回如下地址：

1. 全局变量的地址
2. 字符串常量的地址
3. static变量的地址
4. 堆的地址（用malloc函数动态申请的内存）
5. 主调函数的内存地址:char* fun(char \*s){return s}

### 				9.3.2.函数指针

- 存放了函数的入口地址，函数名代表了函数的入口地址，类似于数组名；

- 函数指针定义： 
      char (*p)(形参1，形参2);即一定要加（），赋初值：p=fun,   使用：p(形参1，形参2)
- 函数指针数组定义：
      在函数指针p后面加上[数组大小].char(*p[N])(形参1，形参2)比如，p[0] = add ;p[1] = sub......
- 作用：
      相同类型的好几个函数比如加减乘除，用p来改变所指向的函数来进行操作。

### 9.3.3.函数指针与指针函数的区别

理解这两个概念的关键在于注意它们的声明和使用方式。函数指针的声明中，括号的位置决定了它是指向函数的指针；而指针函数的声明则明确指出它返回的是一个指针。

# 			10.关键字

## 10.1.typedef

使用：typedef已有数据类型新的数据类型；

```c
//修饰行指针
typedef int (*PTR)[3]; 
PTR p;
//函数指针
typedef (*ptr_to_fun)(形参1，形参2..,,,,); 
ptr_to_fun p;
```

## 				10.2.define

\#define M 2+3 与#define N （2+3）的区别

### 								10.2.1.define与const 常量的区别

- 宏没有分号，不需要等号赋值，而const有分号，且需要等号赋值。

- 宏在预处理时进行文本替换，而const是在程序运行时使用。

- 宏不会分配内存，而const会分配内存。

- 宏定义可以用undefine取消而失效，而const在作用范围内永久有效。

- #define不受作用域范围限制，哪怕写道某个函数内部，在外部也能用。

### 								10.2.2.宏函数的使用

```shell
gcc -E xxx.c -o xxx.i//预处理，即将用到宏的地方全部进行简单的文本替换
```

```c

#define debug printf("Hello,world\n")   //不带参宏，不带分号
#define debug(s) printf("%s\n",s)   //带参宏，不带分号
#define MAX(a,b) ((a)>(b)?(a):(b))	//带多个参宏，不带分号
int main(){
    char s[] = "Hello,world"
    debug;
    debug(s);
    return 0;
}
//注意：
	1.如果define后面的语句不与define在同一行的话要加上反斜杠\，以表示连接
    2.对于带参数的宏，如果函数体用到了参数进行计算，一定要加括号
	#define SQUARE(n) (n)*(n)
     	//计算平方和，SQUARE(3+4)这样的计算结果才不会出错
    3.#define do{printf("hello");printf("world\n");printf("...");}while(0)
 //用do-while的原因是把多条语句合并成一条语句！！
```

### 10.2.3.宏函数与普通函数的区别

 1).宏调用效率比函数高的多
        2).但宏参没有类型与类型检查
        3).函数可以递归，但宏不可以

## 		10.3.typedef与define的区别

1. 语法不同
   typedef是关键字，其语句后面有分号，define是预处理指令后面没有分号。
2. 执行时间不同
   typedef在编译阶段执行，会进行类型检查，而define在预处理时执行，只会进行简单的文本或标识符的替换，不进行类型检查
3. 作用域不同
   typedef在函数外定义，则其作用域范围从定义开始至文件结尾，而当其定义在函数内时，作用范围从定义开始至文件结束，而define无论在哪里定义，其作用范围为从定义开始至文件末尾。

## 10.4.volatile关键字

### 10.4.1.C语言中变量的定义

存储类型 特征修饰 数据类型 变量名  static volatile int value

### 10.4.2.存储类型	

决定变量的存储位置

​	auto 	 只能修饰局部变量。存在栈

​	static 	既可以全局也可以局部。存在静态区DATA。只能在本文件用

​	extern   只能修饰全局变量告诉编译器不用再申请空间了，因为它在其他文件已经申请空间了

​	register 只能局部且整型，不能浮点型，没有地址

### 10.4.3.特征修饰	

决定变量的特征属性

const只读，被修饰的变量本质还是变量，只读变量，不是常量

volatile,被修饰的变量表示该变量值随时都有可能发送变化。![image-20240726202038065](C:\Users\z3254406361\AppData\Roaming\Typora\typora-user-images\image-20240726202038065.png)

![image-20240726202110043](C:\Users\z3254406361\AppData\Roaming\Typora\typora-user-images\image-20240726202110043.png)

![image-20240726203229480](C:\Users\z3254406361\AppData\Roaming\Typora\typora-user-images\image-20240726203229480.png)

### 10.4.4.数据类型	

决定变量的存储空间及数据范围

### 10.4.5.变量名字	

决定变量的引用标识

## 10.5.volatile应用场合

1. 中断

   中断处理程序中若修改其他程序使用的变量，需要volatile来修饰该变量

2. 多线程
   多个线程都要访问的变量也需要用volatile修饰

3. 硬件寄存器
   硬件寄存器的值可能随着硬件的状态变化而变化，需要volatile修饰

## 10.6.extern

extern是C语言中的一个关键字，它主要用于声明一个变量或函数是在其他文件（或同一文件的其他位置）中定义的，以便在当前文件中引用它们，使得变量和函数的跨文件共享成为可能，从而提高了代码的可维护性和可重用性。告诉编译器不用再申请空间了，因为它在其他文件已经申请空间了。**extern的原理很简单，就是告诉编译器：**“你现在编译的文件中，有一个标识符虽然没有在本文件中定义，但是它是在别的文件中定义的全局变量，你要放行！”

优点：不就不会引入大量头文件，进而不会引入大量的无关函数。这样做的一个明显的好处是，会加速程序的编译（确切的说是预处理）的过程，节省时间。

# 		11.变量作用域和生命周期

## 11.1.变量的存储类型

变量的存储类别决定了变量的作用域，生命周期以及默认初始值。

- auto
      常在函数体中或循环体复合语句中，不能是全局变量，作用域即在函数体内或者复合语句中。
- register
      定义在局部。处于寄存器中，不能用&来取地址。
- static
      定义在全局/局部，在内存中以固定地址存放，程序运行期间一直存在，默认初始值为0，其所修饰的全局变量或者函数不能被其他文件用extern进行引用。下次再调用该值时仍然保存上次的值。
- extern
      声明的文件引用另一个文件中的全局变量，且声明的文件并不会再开辟新的空间，而是在文件链接时直接引用，也可以声明函数。

## 11.2.变量作用域

在C语言中，当在函数内部引用一个变量时，编译器会首先查找该函数内部是否有该名称的变量。如果在函数内部找到了同名变量，则使用该变量；否则，编译器会在更广泛的作用域（如全局作用域）中查找该变量。

由于局部变量val（值为30）在main函数的作用域内是可见的，并且覆盖了全局变量val=20，因此printf会打印局部变量val的值，即30。同一作**用域中**，变量不能重名。

# 12.内存管理

## 12.1.内存管理的意义

不同分区存放的数据，赋予不同的生命周期，带来了更大的灵活性。

## 		12.2.内存分区

```shell
#可以用size命令查看内存区域大小
size a.out
```

- 代码区text（运行前）
  存放函数体的二进制代码，cpu要执行的二进制机器指令，共享只读。

- 全局静态区 （运行前）
  存放全局变量和静态变量(函数体内外的静态)以及常量(包含const，字符串常量等)，生命周期为整个程序运行期间。BSS(blocks started by symbols)：
      全局/静态未初始化数据，
  data:

  ​    全局/静态初始化数据，文字常量，字符串常量。

- 栈区stack（运行后）
  编译器自动分配，存放函数参数，返回值和局部变量；

- 堆区heap（运行后）
  malloc，手动分配释放，不主动释放则要等程序结束自动释放

## 		12.3.动态内存使用

函数体中局部变量，存放在栈区，空间随着函数结束而释放，故函数返回值为该变量的**地址**是不安全的，故函数体内要利用动态申请**堆区**的内存，其生命周期更长，并作为函数的返回值地址。

## 12.4.堆栈的区别

1.管理方式不同，栈由操作系统自动分配释放，无需我们手动控制；堆的申请和释放工作由程序员控制，容易产生内存泄漏；

2.分配方式不同，堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。

3.空间大小不同，栈的大小要远远小于堆的大小。

4.生长方向不同，堆的生长方向向上，内存地址由低到高；栈的生长方向向下，内存地址由高到低

## 12.5.野指针

野指针产生的原因：

1、指针定义时未被初始化：指针在被定义的时候，如果程序不对其进行初始化的话，它会指向随机区域，因为任何指针变量（除了static修饰的指针变量）在被定义的时候是不会被置空的，它的默认值是随机的。

2、指针被释放时没有被置空：我们在用malloc开辟内存空间时，要检查返回值是否为空，如果为空，则开辟失败；如果不为空，则指针指向的是开辟的内存空间的首地址。指针指向的内存空间在用free()或者delete（注意delete只是一个操作符，而free()是一个函数）释放后，如果程序员没有对其置空或者其他的赋值操作，就会使其成为一个野指针。

3、指针操作超越变量作用域：不要返回指向栈内存的指针或引用，因为栈内存在函数结束的时候会被释放，

## 12.6.内存泄漏

内存泄漏（Memory Leak）是指程序在运行过程中，已动态分配的堆内存由于某种原因未被释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。这一现象并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误或疏忽，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。

# 	13.GCC编译

## 		 13.1.GCC简介

GNU C Complie编译器

## 13.2.GCC编译过程

1. gcc -E(预处理)    .c ---> .i
2. gcc -S(编译:检查语法错误) .i ---> .s(汇编文件)
3. gcc -c(汇编)     .s-->.o(二进制文件)
4. gcc(链接)         各种.o-->可执行文件.elf

所有的.c文件都有经过预处理，编译，汇编三个步骤独立（不依赖不依靠其他文件的功能，库函数，即不是说别的函数调用了stdio库，我就可以不调了）生成.o文件，然后所有.o文件链接形成一个可执行文件。

## 13.2.常用GCC命令

```shell
gcc -I（大小i） 指定头文件的路径：指定头文件

gcc -l（小写L） 库名 ：链接库
	#gcc tets.c -lpthread

gcc -L 指定库的路径

gcc -O/O2  优化代码，同volatile里优化意思一样

gcc -g     进行调试---->gdb ./a.out
```

## 		13.3.条件编译

好处：通过命令传宏来决定执行哪些代码，省的总注释来注释去的,即相当于一个开关，常用于底层开发代码中。

```c
//1. 根据宏是否被定义来进行条件判断并进行条件编译
#ifdef
#ifndef

#endif
    
    
//2.根据宏的值。。。。。。。
#if VALUE//根据宏的值为真还是假来
#endif

gcc xxx.c -D 宏1    //相当于给程序里添加宏定义的语句即#define 宏1 
gcc xxx.c -D VAULE = 1   //把value的值赋值为1 
```

# 		14.GDB调试

## 14.1.进入调试模式

```shell
gdb 可执行文件名
```

## 14.2.设置断点

```shell
break 
#设置断点，后面可以跟函数名或行号，表示在某一行打断点
```

## 14.3.运行程序

```shell
1.
start  #进入程序的入口处，等待执行程序
continue #statrt后往后顺序执行，直到遇到一个断点处

2.
r(run):#直接让代码运行至断点处

3.
n(next) #从断点处开始一条一条的执行
```

## 14.4.打印信息

```shell
print (&)变量名 #查看变量的值，加上&查看变量的地址

x /nxb &s:打印变量s在内存存储的具体的内容，格式为从结构体首地址开始分别输出n个字节的内容，格式显示为16进制。

bt:打印调用栈



bt：查看栈

l(list):不记得代码了，敲一个l显示一段代码内容。
```


Edit



Step

Help

Quit



 

GDB调试程序

gcc -g xxx.c ：如果程序出错（非语法错误，比如越界，段错误)，则会生成core和a.out文件

gdb a.out core（core文件):在core文件里查看出错原因

gdb a.out -p 进程pid：调试**正在运行**的进程

![image-20240621124813998](C:\Users\z3254406361\AppData\Roaming\Typora\typora-user-images\image-20240621124813998.png)

![image-20240621125023445](C:\Users\z3254406361\AppData\Roaming\Typora\typora-user-images\image-20240621125023445.png)

# 15.Makefile

## 		15.1.makefile概述

1. **含义：**

   make是一个命令，是一个解释makefile中指令的命令,make，制作，当前目录已有，则用当前目录的，没有就根据制作规则语句进行制作。

2. **直接敲make**
   默认访问的是当前目录下名为makefile的文件；

3. **make -f 指定文件的文件名：**
   指定文件为makefile文件

4. **好处：**
   1.一旦写好makefile文件，只需一个make命令，整个工程完全自动编译，极大提高了软件开发的效率。

   2.提升编译效率：不是一步编译时，第二次make时，只编译修改了的文件。（利用文件时间戳来确定文件是否被修改过了）。

## 		15.2.makefile基本语法

### 		15.2.1.makefile 基本语法

target... : prerequisites ...

​	command

### 		15.2.2.解释

1. **target目标**
   它是我们要生成的东西，省略文件的路径时，默认为当前路径，目标文件可以是我们所需的最终文件或者可执行文件，也可以不是我们最终要生成的文件——伪目标。一个伪目标,仅仅是为了执行某条shell语句实现某个功能，并不生成文件。

2. **prerequisites**

   要生成那个target所需要的文件，默认在当前目录下找，如果没有则找有无生成该依赖的makefile语句，此时依赖就是另外一条语句的目标。

3. **command**

   任意shell命令，不一定是gcc命令，**@**作用是不显示命令再显示结果而是直接显示执行命令的结果。


### 		15.2.3.make解析规则

1. 只敲一个make，默认只找第一条目标，故只用make执行makefile有多条语句时，应把生成最终目标的语句放在最前面，因为make默认只识别makefile的第一条语句，找依赖文件，默认**在当前目录**下找，如果有该名称的文件，则直接用该文件，如果没有，则makefile中找是否有该依赖文件作为目标文件存在于另外一条语句中，有该语句，则先执行完该语句。

2. make  目标名：则寻找生成该目标的语句进行执行。

3. .PHONY（虚假的意思）:目标名
   解决**make默认执行的第一条语句**或者**指定执行的语句**中的目标名（可以是伪目标）与当前目录下文件名重名的冲突，此外新生成的文件会覆盖当前目录下重名的那个文件，以.PHONY做目标，会找并执行第一条伪目标语句。

## 		15.3.makefile变量

### 		1.创建变量的目的

用来代替一个**文本字符串**，该字符串可以是：

1.系列文件的名字

2.传递给编译器的参数

3.需要运行的程序

4.需要查找源代码的目录

5.需要输出信息的目录

6.etc

最终就是便于维护和修改makefile文件，改一处，实现多次改。

### 		2.自定义变量

1. 声明时就要赋值，赋值多个字符串时，用空格隔开。
2. 取值方式：$(x)或${x}==取x的值，$$表示打印真实的$符号。
3. SRC = $(shell pwd)/obj ：shell命令执行结果作为值给变量赋值，但$(shell pwd）会被立马执行，其结果为make执行的当前工作目录，当SRC传递其他目录下的文件时，传递的并不是$(shell pwd),而是make工作目录。

### 		3.变量赋值

- =一般赋值,多个条语句对同一变量赋值，最终结结果为最后一条语句的值
- ?=如果前面已经给该变量赋值了，则此次赋值失效，否则执行此次赋值 

- :=如果前面有值了则覆盖掉原来的值，与？=相反

- +=追加赋值

### 		4.自动变量

针对文件名，自动指变量的值会根据修改自动调整

#### 1.依赖文件

- $+所有依赖文件，可重复·    

- $^ 所有依赖文件，不重复      

- $<第一个依赖文件，按生成时间排序的第一个

- $?:所有时间戳比目标文件晚的依赖文件，即上一次修改时间比目标文件生成时间晚的文件，用于打印第二次编译时哪些依赖文件被修改了。

#### 2.目标文件

- $*：不包含后缀 ，用于打印，对于本身没后缀的无效，对于可执行文件a.txt，他还是没后缀，.txt也算文件名不算后缀名，故打印无后缀的只能用$@  
- $@目标文件完整名字，有后缀名的也包含后缀名，用于打印和编译        


 		作用：提高编程速度，每次只要写一句gcc命令再不断复制粘贴带有自动变量的相同的语句即可。makefile隐含变量,针对shell命令，可以赋值，不赋值则用默认值.

#### 3.命令（有默认值）

- CC：默认值--cc 赋值交叉编译 CC = arm-linux-gcc

- CPP：默认值--$(CC) -E预编译

- RM：默认值rm -f


#### 3.命令的选项（无默认值）

- CFLAGS= -c -g -Wall 

- CPPFLAGS

- CXXFLAGS

- LDFLAGS


**通配符**：<u>%.c ：%.o用通配符的前提是在通配符使用语句前已经出现过了%.c的范围是哪些.c文件，不然%可以匹配任意，那么有无穷多个目标了，此外通配符并不匹配路径！！，所以带有路径的文件通配，要自己加上路径</u>

## 	15.4.makefile的条件判断

1. ifeq（a,b）：a,b是否相等，if与（）间要隔开！！！

2. ifneq：是否不相等

3. ifdef  ARCH：只有ARCH**定义过且赋过值**才算定义过，无论是在文件中定义还是在传参时定义，规则都一样

4. ifndef   endif


## 	15.5.makefile常用函数

#### 1.格式

$(<函数名> <参数1,参数2>)或者${<函数名> <参数1,参数2>}

#### 2.举例

一个文件名应该 == 绝对路径/文件名，缺省绝对路径只有文件名默认都是当前目录下的文件，当文件名（无论有路径）赋值给变量时，其特性就不是文件了，就是一个字符串，赋值的时候缺省路径那么该字符串就没有路径，变量就是变量。

```shell
$(wildcard PATTERN)
	#功能：列出当前目录下所有符合模式PATTERN格式的文件名,比如*.c列出当前目录下所有.c文件
	#返回值：空格分割的，存在当前目录下的所有符合模式PATTERN格式的文件名,PATTERN是文件名，不是字串！！！	
	#PATTERN：可以使用shell下的可识别的所有通配符
作用：
	SRC = add.c sub.c test.c xxx.c.....www.c#此时SRC仅仅只是一串字符，不会说有默认当前目录下的这些文件这种说法
	取代：SRC = $(wildcard *.c),大大简洁了代码！！
$(pastsubst <pattern>,<repalcement>,<text>)
	#它用于将一个字符串中符合特定模式的子串替换为另一个字符串，不符合的字串就不换
	#text:要进行替换的对象，若有多个则用空格隔开，text是字串
	#pattern：替换对象满足的文件名字格式，pattern也是字串。
	#replacement：替换成什么格式的文件名，replacement也是字串。
	#返回值是替换后的文件名，包含没有被替换的，比如，text为1.c，2.cpp，pattern为*.c，则返回值为1.o,2.cpp
```

## 	15.6.makefile自定义函数 

​	**定义**：

​			define 函数名 

​				函数体		//用$(0….9)来获取第n个参数，第0个参数是函数名字

​			endef

​	**调用：**$(call 函数名 参数）

# 	16.make命令的使用

```shell
make #默认访问文件名为makefile的文件

make -f file#make文件名为file的文件

make -i #忽略所有执行出现的错误导致的停止，即使出错了，也会接着往下执行，不会在出错的地方直接停止了。这很重要，特别是当一个工程要编译几个小时时，编译了好久因为出错停了又得重来。

make -n #只打印要执行的命令有哪些，并不执行这些命令

make -s #只执行，不打印命令

make -w #当工程庞大分了好多文件目录时，打印当前的目录来表示当前编译进入到哪个目录了，告诉你从哪跳到哪了

make -C #指定哪个目录下有makefile(默认加了-w的功能)，让make去执行它    
```

#  	16.分目录管理源码(目录作为目标或依赖的问题)

```makefile
#*.c-->src目录
#*.o-->obj目录
#当前目录的make执行makefile时，也去执行其他目录下的makefile则当前目录下的makefile要用到   
make -C 目录名1 目录名2 目录名3.... 这条shell语句，又因为执行shell语句要用到目标：依赖这样的格式,则应为：
1.SRCDIR = ./src/
	$(SRCDIR):
		make -C $@
		#执行结果：
		'src/'已是最新
#一切皆文件，目录也是文件,则会出现重名的问题，解决办法，以SRCDIR为目标的语句中添加依赖，依赖不能是目录，不然也会出现同样问题。
 $(SRCDIR): ECHO
	make -C  $@
 ECHO:
 	echo Hello
 	
 	
2.利用.PHONY解决,一个makefile文件中只能使用一次
 .PHONY:$(SRCDIR)
  $(SRCDIR):
		make -C  $@
		
3.
export 变量1，变量2，变量…..#将当前makefile的变量传递给其他makefile文件使用
如果把带有路径的文件名赋值给变量，当该变量在一个文件夹中定义赋值，而在另外一个文件夹中使用时应该用绝对路径。
```

# 	17.makefile总结

- **默认条件**
  假设目标名是test，如果当前目录中有test.c（一定要是.c文件才可），即存在以目标名为前缀，.c为后缀的C源文件，哪怕有test.c,test.txt并存，只要有test.c,则都算满足默认条件。

- **默认语句**
  $(CC)  $(FLAGS)  xxx.c -o xxx，CC FLAGS可以赋值，也可以使用默认值，其中FLAGS没有默认值。

- **执行步骤**

  假设当前目录下有add.c   a.txt  b.txt  makefile  sub.c  test.c  test.txt这些文件


1.**只有一个目标，无依赖无命令**

```makefile
###1.目标满足默认条件
	test:
		#有以test为前缀,.c为后缀得test.c，且命令缺省，满足默认条件
		#执行结果：
		cc     test.c   -o test


###2.目标不满足默认条件
	a:
		#不存在以a为前缀,.c为后缀得a.c，不满足默认条件，且命令缺省。
		#执行结果：
		make: 对“a”无需做任何事。
```

**2.有目标，有依赖，但没命令**		

```makefile
	###1.目标满足默认条件，且缺省命令，且依赖当前目录存在，执行默认语句
		test:a.txt
			#执行结果：
			cc     test.c a.txt   -o test
			
			
	###2.目标满足默认条件，且缺省命令，但依赖不存在当前目录，则需要make依赖，创造成功但命令缺省，则执行默认语句，不过默认语句要加上依赖文件
		#2.1如果依赖作为目标满足默认条件，则先执行默认语句创造依赖，再执行本次make语句
		test:add
			#执行结果：
			cc     add.c   -o add
			cc     test.c add   -o test
		#2.2如果依赖作为目标不满足默认条件，且没有制作依赖的语句，则全报错
		test:a
			#执行结果：
			make: *** 没有规则可制作目标“a”，由“test” 需求。 停止。
		#2.3如果依赖作为目标不满足默认条件，且有制作依赖的语句，先执行创造依赖的语句，制作依赖的语句可以当作新的语句来继续进行判断是否制作成功，若成功，再执行本次make默认语句
		test:a
		a:add
			#执行结果：
			cc     add.c   -o add
			cc     test.c a   -o test
	
	
	
	###3.目标不满足默认条件，且缺省命令，先创建依赖，依赖创建规则同上，又因为缺省命令，所以此次make语句相当于不会执行，不是报错(此时叫伪目标)。
		a:add
			#执行结果：
			cc     add.c   -o add
		a:b
			#执行结果：
			make: *** 没有规则可制作目标“b”，由“a” 需求。 停止。
		a:b
		b:add
			#执行结果：
			cc     add.c   -o add
```

3**.有目标，有命令，但没依赖。**

不存在满不满足默认条件的问题，因为满足默认条件了，只是为了执行默认语句命令，都有了命令，肯定不是默认命令了啊，故目标满不满足默认条件不影响

```makefile
###无论目标满不满足默认条件，都会按照命令执行
	a:
		@echo hello
		#执行结果：
		hello
		
	test:
		@echo hello
		#执行结果：
		hello
		
		
###如果目标与当前目录下文件重名：解决办法.PHONY
	test.c:
		@ehoc hello
		#执行结果:
		make: “test.c”已是最新。
	
	.PHONY:test.c
	test.c:
		@ehoc hello
		#执行结果:
		hello
```

4.**有目标，有命令，有依赖**

```makefile
#先制作依赖，再根据命令不是默认命令制作目标!!,不存在满不满足默认条件的问题，因为满足默认条件了，只是为了执行默认语句命令，都有了命令，肯定不是默认命令了啊，故目标满不满足默认条件不影响
```

makefile每条语句生成的目标都只是作为中间结果，和最终的一个目标，这些中间结果和最终目标文件会不会在当前目录下创建是要看以它们为目标的语句所用的shell命令是不是会去在当前目录下创建文件。不会在当前目录下创建目标文件的语句：叫做伪目标语句。

# >>>>>>数据结构与算法>>>>>>

学习任何数据结构，要想清楚它属于什么逻辑结构，利用什么存储结构，以及如何组织各个数据属性作为结构体中的数据，这些都是对数据结构的组织定义。其次就是对组织好的结构数据进行增删查改，排序，就是算法了。

# 0.导学

## 1.分文件编程

- .h 数据结构的定义，以及声明有哪些操作
- .c 操作的具体实现
- main.c  主要调用.h里定义的函数实现主要逻辑

## 2.数据结构算法思路

1.确定算法函数的三要素：功能，返回值，形参

2.根据传入的参数，分别对处于临界之外（算法不处理），临界值（假设是临界值之内的值看看是否出错来确定应该属于临界值之外还是之内），临界之内（一般项，算法需处理的）做处理。

3.**画图**，根据已有思路进行关键步骤分析，写成形参为一般项时的取值范围，最后根据步骤编写相应代码。（当调用其他函数时，也要考虑其他函数返回值的情况）

4.思考返回值的值。

# 1.数据结构引入

## 1.1.数据结构种类

1. **可以找到任意多个元素，它们之间存在某种关系的**
   线性表，树，图

2. **元素之间除了同属于一个集合，再无其他关系**

   集合


## 1.2.数据结构理解

逻辑结构+存储结构+操作

### 1.2.1.逻辑结构

数据元素运算之间具体的抽象关系

- 线性结构(线性表，栈，队列）

- 集合

- 树形结构

- 图状结构


### 1.2.2.存储结构

在计算机中具体存储的实现方法

- 顺序存储：空间连续

- 链式存储

- 索引存储：存数据文件+索引表==书的内容+书的目录，根据索引表确定存取地址

- 散列存储：根据数据本身来确定存取地址


### 1.2.3.数据的操作

增删查改，排序

# 2.线性表

## 2.1.线性表的表示

- **一般表示**
  L=（a0，a1，……an-1），L为表名

- **二元组表示**

  L=（D|R)


## 2.2.操作

1）建空表

2）置空表

3）是否为空，是否为满

4）求表长

5）查找某个元素的值

6）定位

## 2.3.顺序表及其操作的实现

 

## 2.4.单链表及其操作的实现

### 2.4.1.结点组织定义

```c
typedef int Data_t;
typedef struct node{
	Data_t data;
	struct node *next;
}listnode,*linklist;
```

### 2.4.2.操作

- 链表的倒序

  链表一分为二，成为两个链表，不需要再`malloc`重新建一个新表了。  

### 2.4.3.带头结点和不带头结点的函数区别

- 一个返回值可以为void，一个返回值必须为linklist或者传二级指针
- 注意指针（不要以为传的是指针就不会）为形参时也会存在局部变量改变但不改变外部引用变量的情况 

# 3.队列

## 3.1.一般队列

先进先出

## 3.2.循环队列

### 3.2.1.判断队满队空

为了区分空队和满队，满队的最后一个空间不存元素。

队空：front=rear

队满：rear+1 == front

### 3.2.2.初始化

创建空队列，头和尾相等就可以，不一定要为0；

## 3.3.链式队列

带头结点的删除（两种方法）：

1.当只有一个结点时，删除后，还要让rear重新等于front

2.每次只删除头节点，队头front指向的元素作为删除后新表的新头结点。

栈和队列的应用：球钟问题

 

 

树：

递归程序特征：

1.有递归特征

2.有递归出口

查找：

顺序查找：ASL = o(n)

折半查找：ASL = o(log2(n+1)) 前提：顺序表有序

分块查找：块间有序，块内无序

哈希查找：key与记录的存放地址有关系 f:key->add add = H(key) key是自变量，add是因变量

​       1.选用什么样的哈希函数 （

保留除数法：H（key）= key%p p选取为质数，p大，则余数范围大，冲突概率小，但太大浪费空间

填充因子：α=n（记录个数）/m（表长）取值在0.7~0.8之间 p应该为不大于m的最大质数

）

​       2.有冲突了选用什么样的方法解决冲突

（1.开放地址法：H=(H(key)+d)%m 

   d的取法:

线性探测法

二次探测法

 2.链地址法：相同地址下按key值有序插值）

排序：

插入排序：

直接插入排序

二分插入排序

交换排序：

冒泡排序

快速排序



### Ncurses库：

#include  <curses.h>

——————————————————————

**1.initscr(void)**

​		//创建窗口，包括为窗口分配内存

**2.int endwin(void)**

​		//释放窗口

——————————————————————————

**3，int curs_set(int  visiblility)**

​		//设置光标是否可见

​		//visibility 0不可见，1可见

**4.int move(int dest_x,int dest_y)**

​	//移动到指定的行和列

**5.int addch(const chtype char)**

​	//在当前光标位置添加字符

————————————————————————————————————

**6.int refresh(void)**

​	//刷新物理屏幕，将获取的内容显示到显示器上

**7.int keypad(WINDOW *window_ptr,bool key_on)**

​	//启用F1-F12功能键

​	//example:keypad(stdscr,1)stdscr,当前工作界面，1启用设置

——————————————————————————————————————

**8.int getch(void)**

​	//读取键盘输入的一个字符，会阻塞等待！！

**9.chtype inch(void)**

​	//获取当前屏幕光标位置的字符，记得强转chtype为char型

**10 noecho();**

​	//不显示手动键盘输入的字符，当摁下q控制某个行为时，只执行该行为，不显示q

**11.int start_color(void);**

​	//启动color机制

**12int init_pair(short pair_number,shrort foreground,short background);**

​	//配置颜色对

​	//pair)number表示第几次调用init_pair函数，即第几组

​	1.黑COLOR_BLACK，品红

​	2红，青

​	3绿，白

​	4.黄，蓝

**13 int COLOR_PAIR(int pair_number)**

​	//设置颜色属性，设置完颜色对，可以通过此函数实现

**14int attron(COLOR_PAIR())**

**15 int attrof(COLOR_PAIR())**

# ——C++面向过程——

# 第一个C++程序

## C++文件名格式

```shell
vim hello.cpp
#c++文件一般命名为.cpp文件,.cxx,.hpp（相当于声明和定义放一起）,.cc
```

## 程序内容介绍

```c++
/*  iostream
	c++ 使用IO相关的函数时的标准头文件 类似于stdio.h
	c++ 风格的很多头文件没有.h后缀
	c++兼容c，c++中可以使用c的stdio.h或者c++的cstdio
*/
#include <iostream>
/*名字空间*/
using namespace std;
int main(int argc, char *argv[]){
    /*类似于printf("hello world\n")
    	cout 输出对象
    	endl 相当于\n
    */
	cout << "hello world" << endl;
	return 0;
} 
```

## 编译源文件

```shell
g++ hello.cpp -o hello

g++ hello.cpp -o hello -stdc++=11#指定使用c++11的标准编译，比如默认的编译器版本过高时，默认舍弃了一些用法如auto_ptr<T>指针，而代码中用到了这个指针，直接默认版本编译，会报错，因此要指针使用支持该指针语法的编译器版本即可。

gcc hello.cpp -o hello -lstdc++

./hello
```

## 嵌套C语言

### extern "C"介绍

​	extern "C"起作用的时候是在：C++调用C中的函数。由于C++和C是两种不同的编译和连接方法，所以在交叉调用的时候，就需要增加一些机制起到让两者无缝兼容的目的。而extern "C"正是这一种机制，规定在编译C++源文件时，那些调用自C文件的部分（需要用extern "C"修饰其在头文件中的声明），按照与C文件编译兼容的方式进行。那么显然在不涉及C++调用C中函数的情况，extern "C"是不起作用的。在编译C文件的时候，编译器是不会自动添加“\__cplusplus”的宏定义；而在编译C++文件的时候，编译器会自动的对“\__cplusplus”进行宏定义。

### 测试源码

-  **add.c**

  ```c
  #include "add.h"
  void add_fun(int a,int b)
  {
      printf("%d\n",a + b);
  }
  ```

- **add.h**

  ```c
  #ifndef _ADD_H_
  #define _ADD_H_
  #include <stdio.h>
  void add_fun(int a,int b);
  #endif
  ```

- **main.cpp**

  ```c++
  #include "add.h"
  int main(int argc ,char** argv)
  {
      add_fun(1,2);
      return 0;
  }
  ```

- **编译**

  ```shell
  g++ -S main.cpp
  gcc -S add.c
  ```

- **编译结果_add.S**

  ```shell
  	.file	"add.c"
  	.section	.rodata
  .LC0:
  	.string	"%d\n"
  	.text
  	.globl	add_fun
  	.type	add_fun, @function
  add_fun:   #!!!!!!!!!!!
  .LFB0:
  	.cfi_startproc
  	pushq	%rbp
  	.cfi_def_cfa_offset 16
  	.cfi_offset 6, -16
  	movq	%rsp, %rbp
  	.cfi_def_cfa_register 6
  	subq	$16, %rsp
  	movl	%edi, -4(%rbp)
  	movl	%esi, -8(%rbp)
  	movl	-8(%rbp), %eax
  	movl	-4(%rbp), %edx
  	addl	%edx, %eax
  	movl	%eax, %esi
  	movl	$.LC0, %edi
  	movl	$0, %eax
  	call	printf
  	leave
  	.cfi_def_cfa 7, 8
  	ret
  	.cfi_endproc
  .LFE0:
  	.size	add_fun, .-add_fun
  	.ident	"GCC: (Ubuntu 4.8.4-2ubuntu1~14.04.4) 4.8.4"
  	.section	.note.GNU-stack,"",@progbits
  
  ```

- **编译结果_main.cpp**

  ```shell
  	.file	"main.cpp"
  	.text
  	.globl	main
  	.type	main, @function
  main:
  .LFB0:
  	.cfi_startproc
  	pushq	%rbp
  	.cfi_def_cfa_offset 16
  	.cfi_offset 6, -16
  	movq	%rsp, %rbp
  	.cfi_def_cfa_register 6
  	subq	$32, %rsp
  	movl	%edi, -20(%rbp)
  	movq	%rsi, -32(%rbp)
  	movl	$10, -8(%rbp)
  	movl	$5, -4(%rbp)
  	movl	-4(%rbp), %edx
  	movl	-8(%rbp), %eax
  	movl	%edx, %esi
  	movl	%eax, %edi
  	call	_Z7add_funii     #！！！！！！！！！！！！！！！
  	movl	$0, %eax
  	leave
  	.cfi_def_cfa 7, 8
  	ret
  	.cfi_endproc
  .LFE0:
  	.size	main, .-main
  	.ident	"GCC: (Ubuntu 4.8.4-2ubuntu1~14.04.4) 4.8.4"
  	.section	.note.GNU-stack,"",@progbits
  
  ```

- **链接结果**

  ```shell
  #在连接程序的最后阶段，出现错误提示：
  /tmp/cc7e9Shj.o：在函数‘main’中：
  main.cpp:(.text+0x28)：对‘add_fun(int, int)’未定义的引用
  collect2: error: ld returned 1 exit status
  ```

- **原因分析**

  ​	因为`add.c`程序在编译的时候被翻译成了函数标号`add_fun`。也就是说`add.c`文件的add_fun()函数在编译的时候，其对应的标号是**add_fun**。

  　　而main.cpp文件调用该函数的地方，编译后却使用了标号**`_Z7add_funii`**。那么显然在连接的时候，连接器无法将这两个标号连接到一起，而出现上述错误。

- **解决——使用extern “C”关键字**

  ```c
  //修改config.h，内容为
  #ifndef    __CONFIG_H
  #define    __CONFIG_H
  extern "C" void config(void);
  #endif
  ```

  由于extern "C"修饰了void add_fun(void)，所以在`main.cpp`调用该函数的时候按照C文件的编译方式进行编译，所以其对应的标号为**add_fun**。add_fun函数所在的文件add.c文件编译出的标号与之一致，就能成功的连接。

# 输入输出流

- 输入流：从输入设备流向内存的字节序列

- 输出流：从内存流向输出设备的字节序列


cout和插入运算符“<<”：执行cout语句时遇到<<运算符就会将要输出的信息插入到输出流中去，优势在于**自动解析**要输出的数据类型。

cin和>>：执行cin时遇到>>运算符会从输入字节流中取一个数据放到>>后面的变量中去。

1)假如ch是char类型，输入34，只有3会被存进去，4继续留在输入流中。

2)当要输入多个变量时，一直输入直到遇到数据类型不匹配时停止输入并把出错的那个变量直接赋值为0.

```c++
#include <iostream>
using namespace std;
int mian(){
    int a;
    float b;
    char c;
    cin >> a >> b >> c//12.34a
    cout << "a:" << a << "b:" <<b << "c:" << c
    return 0
}

执行结果
    12 0.34 a
```

# 名字空间

## 作用

解决命名冲突的变量或者函数名,故不同名字空间里可以定义相同名字的变量或者函数

## 语法

```c++
namespace ns1{
    int num;
    void func(void){
        cout << "fun1"<< endl;
    }
}
namespace ns2{
    int num;
    void func(void){
        cout << "fun1"<< endl;
    }
}
```

## 名字空间成员访问

1. ::访问——ns1::func();
2. 引用单个成员——using ns1::func;  func();
3. 引用所有成员——using namespace ns1
4. 无名名字空间引用——::成员名，即::前面无名字
5. 坑：

   ```c++
   #include <iostream>
   using namespace std;
   namespace ns1{
   	void func(void){
   		cout << "ns1 func" << endl;
   	}
   }
   namespace ns2{
   	void func(void){
   		cout << "ns2 func" << endl;
   	}
   }
   int main(int argc, char *argv[]){
       ns1::func();
   	using ns1::func;
   	func();//这个编译器知道一定是ns1的，因为此时ns2未引入
   	using ns2::func;
   	func();//此时两个名字空间都引入，但func编译器也不知道是哪一个名字空间的
   	return 0;
   }
   //error: call of overloaded ‘func()’ is ambiguous
   //故后用using引用方式要注意此情况，而ns1::func()需要用一次引入一次，但不会此情况
   ```

## 名字空间嵌套

```c++
#include <iostream>
using namespace std;
namespace ns1{
	void func(void){
		cout << "ns1 func" << endl;
	}
	namespace ns2{
		void func2(void){
			cout << "ns2 func" << endl;
		}
	}
}
int main(int argc, char *argv[]){
	using ns1::func;//using namesapce ns1
	func();
	using ns1::ns2::func2;//using ns2::func2
	func2();
	return 0;
}
```

# C++数据类型

## 对C数据类型的扩展

在C数据类型的基础上引入了字符串类型，对并对结构体，联合体，枚举，布尔类型做了改进。

## 结构体

- C++结构体中可以直接定义函数，谓之成员函数(方法)
- C++结构体定义好后再声明时可以省略struct，赋值方式同C

  ```c++
  struct Complex{
      double r;
      double i;
      void init(double rr,double ii){
          r = rr;
          i = ii;
      }//定义成员函数
      double real(){
          return r;
      }
      double image(){
          return i;
      }
  };
  Comlex a; //声明时省略关键字
  a.init(3,5);
  cout << a.real() << "+" <<a.image()<<"i"<<endl;//3+5i
  ```

## 联合体

- 一样可以省略union关键字
- 支持匿名联合体，即联合体没有名字，引用成员时直接用成员名

  ```c++
  #include <iostream>
  #include <cstring>
  union{
      char r;
      int i;
  };
  using namespace std;
  int main(int argc, char *argv[]){
  	i = 2;//把匿名联合体的成员当局部变量用
      cout << i << endl;
  }
  ```

## 枚举

- 可以省略enum
- C++的枚举类型是一个单独的数据类型，不是整型，不能当整型使用，如进行赋值，自加自减等

  ```c++
  #include <iostream>
  enum Complex{
      r,
      i
  };
  using namespace std;
  int main(int argc, char *argv[]){
  	Complex a;
  	a = r;
  	cout << a << endl;//0
  	a++; //error
       a = 3; //error
  	return 0;
  }
  //1.
  enum_t.cpp: In function ‘int main(int, char**)’:
  enum_t.cpp:11:10: error: no ‘operator++(int)’ declared for postfix ‘++’ [-fpermissive]
     11 |         a++;
        |         ~^~
  //2.
  enum_t.cpp: In function ‘int main(int, char**)’:
  enum_t.cpp:11:13: error: invalid conversion from ‘int’ to ‘Complex’ [-fpermissive]
     11 |         a = 3;
        |             ^
        |             |
        |             int
  
  ```

## 布尔类型

- C++布尔类型是基本数据类型，表示逻辑的真假
- 单字节的整数，值为true为1和false为0，默认输出0或1，但输出加上boolalpha 后输出就是true或false
- 任何其他数据类型可以隐式转为布尔类型，0为false，非0为true

## 字符串

- 兼容了C的字符串处理方法和函数
- 专门设计了string类型表示字符串
- string的定义

  ```c++
  string s1 = "Hello";
  string s2("Hello");
  string s3 = string("Hello")  
  ```
- string的拷贝

  ```c++
  string s1 = "hello";
  string s2 = s1;
  ```
- string 的连接

  ```c++
  s1 +=s2;
  s1 = s1 + " " + s3;
  s2 = s2 + " " + s4;
  ```
- 字符串比较

  ```c++
  if (s1 == s2)
  ```
- 随机访问

  ```c++
  string s = "hello";s[0] = "H";
  ```
- 获取长度:s.size(),s.length()不算\0
- 转为C风格字符串：const char* c_str();const char*p = s.c_str();
- 字符串交换：void swap(string &s1,string &s2)

# 5.类型转换

也分隐式（编译阶段完成转换），显示转换

## 5.1.显示转换

```c++
int a = 4;
float b = (float)a;
float c = float(a);
```

## 5.2C++独有的更严格的强制转换运算符

- **static_cast**：常用于基本类型数据之间，void*与其他类型指针之间的转换。其他情况不允许。（低风险）

- **dynamic_cast**：主要用于**具有多态**继承关系的**父子类**指针或引用之间的显示转换。
  在程序运行时发生转换。相比于其他转换的好处在于虽然**编译时不会报语法错误，但运行时会出错的话**，转换的指针就会被赋值为NULL。
  因此库有用于判断运行时是否出错，即不仅能检查语法上是否出错，也能检查执行时转换是否成功。即有了问题我可以分析出来。
  C语言的强制哪怕出错了，也不会告知，但这种类型强制出错了会返回null，我们就可以通过指针是否为null来编写强制出错处理的代码。

  ```c++
  class C{};
  class Base{
      virtual ~Base{};
  };
  class Derived:public Base{};
  int main(){
      Base *pb,b;
      Derived *pd,d;
      C c;
      pb = &d;//向上造型，隐式转换
      pb = dynamic_cast<Base*>(&d);//向上造型，显示转换
      
      pb = dynamic_cast<Base*>(&c);//C类与Base类毫无关系，虽然编译时此处不报错，但是运行时转换失败，pd值为NULL。
      if(pb){
          cout << "ok" << endl;
      }else
      {
          cout << "error" << endl;
      }
  }
  
  error
  ```

- **const_cast**：去除常属性，如把const int变为int

- **reinterpret_cast**:用于任意类型指针或引用之间的转换，也可以指针与整数之间的转换。（高风险）

```c++
#include <iostream>

using namespace std;

int main(int argc, char *argv[]){
	float a = 2.3;
	int b = static_cast<int>(a);
	cout << "a:" << a << endl; //2.3
	cout << "b:" << b << endl; //2
	int *p = &b;
	void *q = static_cast<void*>(p);//正确
	void *p2 = &a;
	float *q2 = static_cast<float*>(p2);//正确
	float *q3 = static_cast<float*>(p);// error: invalid ‘static_cast’ from type ‘int*’ to type ‘float*’
    float *q3 = reinterpret_cast<float*>(p);//正确
    q3 = 0x20;//error: invalid conversion from ‘int’ to ‘float*’
    q3 = static_cast<float*>(0x20);//error: invalid ‘static_cast’ from type ‘int’ to type ‘float*’
    q3 = reinterpret_cast<float*>(0x20);//正确
	return 0;
}

int a = 100;
double b = static_cast<double>(a);
void* p = malloc(100);
char *p = malloc(100);
int *a = (int*)p //C
int *a = int*(p)//C++
int *a = static_cast<int*>(p)//error
int *a = reinterpret_cast<int*>(p)//可以
int a = static_cast<int>(p)//error
int a = reinterpret_cast<int>(p)//可以
    //整数与指针之间的转换相当于C中给指针赋值一个整数，可以认为直接赋值了一个地址
```

# 6.引用

## 6.1.定义

- 引用是某个对象/变量的别名

  ```c++
  int a = 10;
  int &ar = a;
  //给变量名取了别名，a和ar占用同一块位置空间
  cout << "&a:" << &a << "---" << a  << endl;
  //&a:0x7ffee37157ec---10
  cout << "&ar:" << &ar << "---" << ar  << endl;
  //&b:0x7ffee37157ec---10
  ```

- 引用在定义时就必须初始化

  ```c++
  int& c;
  //error: ‘c’ declared as reference but not initialized
  c = a;
  ```

## 6.2.用途意义

1. 简化编程，用指针的地方可以用引用。
2. 引用作为函数的形参没有再申请内存空间，可以使系统开销更小。
3. 引用可以作为函数参数和函数返回值。

## 6.3.注意事项

1. 引用必须在定义时就初始化

2. const常引用，一般引用是对左值如变量的引用，不能对右值如常量,，表达式进行引用。

3. 常引用，常引用可以引用变量和常量，表达式，也叫万能引用，但通过常引用变量不能修改变量的值

   ```c++
   int &i = 10;
   //error: cannot bind non-const lvalue reference of type ‘int&’ to an rvalue of type ‘int’
   const int &i = 10
   //正确
   i++;
   //error: assignment of read-only reference ‘i’
   ```

## 6.4.引用的本质

引用的本质其实就是指针常量 :<数据类型 >  *const p,所以必须定义时赋初值，又因为指针常量指向哪个区域虽然不能改，但其所指向的区域的内容是可以改的，故其内容不能是常量，正因如此才不能赋值常量，因为常量不能改。

## 6.5.引用型参数

即函数的形参是引用，如果不希望函数内部的实现对形参进行改动，则形参应该为常引用，此时，实参既可以传变量这些左值也可以传常量这些右值。

## 6.6.返回引用

在函数内部实现定义的变量，函数返回值是该变量的引用，但当函数执行完后，函数内部变量属于局部变量会被回收，故后续利用其引用可能会出错，相当于利用一个野指针，所以返回引用多用在后面面向对象实现类的成员函数或者运算符重载时返回的引用是外部传进来的变量的引用的情况。

## 6.7.指针和引用的区别

- 指针指向一块内存，它的内容是所指内存的地址；引用是某块内存的别名。 
- 指针是一个实体，而引用仅是个别名；引用使用时无需解引用（*），指针需要解引用； 
- 引用只能在定义时被初始化一次，之后不可变；指针可变； 
- 引用不能为空，指针可以为空； 
- “sizeof 引用”得到的是所指向的变量（对象）的大小，而“sizeof 指针”得到的是指针本身的大小；

# 7.C++函数

## 7.1.缺省参数

在C++中，函数的形参列表中的形参是可以有默认值的。有默认值的参数即为默认参数。在函数调用时，有默认参数可以缺省。

### 7.1.1.语法

```c++
int add(int x,int y ,int z = 100){
    return x+y+z;
}
int main(){
    cout << add(1,2,3) << endl;
    cout << add(1,2)   << endl;
    return 0;
}
```

### 7.1.2.注意事项

1. 传的实参中没有给z，用默认值，传了就用指定值
2. 默认值靠右原则，即如果某个参数有默认值，其后面的都必须有默认值。
3. 函数的声明和实现只能有一个位置去说明有默认参数，不然就报错。

   ```c++
   int add(int x,int y ,int z = 100);
   int add(int x,int y ,int z =100){//error: default argument given for parameter 3 of ‘int add(int, int, int)’ 
       return x + y + z;
   }
   //倘若声明给的是z = 100，实现给的是 z = 200，编译器不知道到底要用哪个默认值，为了省事，干脆把声明和实现的缺省参数默认值一样的情况也归为此类错误。
   ```

## 7.2.哑元

### 7.2.1.定义

只有类型没有变量名的参数

### 7.2.2.使用场景

- 兼容旧代码，保证函数的向下兼容性

  ```c++
  void fun(int i,int j){...}---> void fun(int i){...};//麻烦，函数升级，应用要修改代码
  void fun(int i,int j){...}---> void fun(int i,int /*哑元*/){...};
  ```

- 操作符重载，区分前后++和---

  ```c++
  Integer& operator++(){...};//前++
  Const Integer operator++(int){...};//后++
  ```

## 7.3.函数重载

### 7.3.1重载定义

**同一作用域**中，函数**名称相同**，但参数表必须有所区分（形参的类型或个数或顺序不一样），将构成重载关系。故多个函数只要参数表有区别，这些函数的函数名可以重名。

```c++
#include <iostream>

using namespace std;

void swap(int *a,int *b){
	int tmp = *a;
	*a = *b;
	*b = tmp;
}
void swap(char *a,char *b){
	char tmp = *a;
	*a = *b;
	*b = tmp;
}
int main(int argc, char *argv[]){
	int x = 10;
	int y = 20;
	swap(&x,&y);
	cout << x << " " << y <<endl; 
	return 0;
}
```

### 7.3.2重载的实现

编译器将形参变量的类型作为最终函数名的一部分。

```shell
nm a.out

...
...
000000000000121a T _Z4swapPcS_
00000000000011e9 T _Z4swapPiS_
...
...
```

### 7.3.3.注意事项

- 形参变量名不同，不**构成**重载关系。

- 函数返回值类型不同，不构成重载关系的要素，即不**影响**重载关系。

### 7.3.4.函数匹配选择优先级

1. **完全匹配**
   函数形参有与实参类型完全匹配的（最高优先级）
2. **常量转换**
   char实参，const char形参常量转换（较好优先级）
3. **升级转换**
   short实参匹配int形参升级转换（一般优先级）
4. 降级转换//较差 :降级转换是相对于省略匹配来将的，即不能float在int和short里进行降级，而是在int和省略号里降级为int，或者在short和省略号里降级为int
5. 省略号匹配//最差

```c++
#include <iostream>
using namespace std;
void bar(int a){
	cout << "bar(int)" << endl;
}
void bar(char a){
	cout << "bar(char)" << endl;
}
void bar(...){
	cout << "bar(...)" << endl;
}

void foo(int a){
	cout << "foo(int)" << endl;
}
void foo(const char a){

	cout << "foo(const char)" << endl;
}
int main(int argc, char *argv[]){
	char a = 'a';
	bar(a);  //bar(char),完全匹配
	foo(a);  //bar(const),常量转换
	float b = 2.3;
	bar(b);  
    //此时要注释掉bar(int)或者bar(char),那么执行结果是bar(char)或者bar(int)
    //即供选择的不能是两个不一样类型的比当前类型低级的类型，而必须是一个低级类型，一个省略号
	short c = 2;
	bar(c); 
	return 0;
}
```

### 7.3.5.二义性问题

- 默认类型转换带来的二义性
  即实参到形参都是升级或者降级转换

  ```c++
  void bar(int a){
  	cout << "bar(int)" << endl;
  }
  void bar(char a){
  	cout << "bar(char)" << endl;
  }
  float b = 2.3;
  bar(b);//解决问题，强转实参b
  
  In function ‘int main(int, char**)’:
  error: call of overloaded ‘bar(float&)’ is ambiguous
     21 |         bar(b);
        |         ~~~^~~
  note: candidate: ‘void bar(int)’
      3 | void bar(int a){
        |      ^~~
  note: candidate: ‘void bar(char)’
      6 | void bar(char a){
        |      ^~~
  ```

- 缺省参数带来的二义性

  ```c++
  void fun(int a,int b,int c = 100){...}
  void fun(int a,int b){...}
  fun(1,2)
      //ambisguos
  ```

## 7.4.内联函数

```c++
inline int add(int x,int y){//即加一个inline关键字
    return x + y;
}
int main(void){
    int ret = add(3,5)//int ret = 3 + 5,即直接把内联函数的执行逻辑展开，并不调用函数
}
```

### 7.4.1.好处

不需要建立函数调用的运行环境的栈空间，不需要进行参数传递，不需要跳转，让执行效率更高。

### 7.4.2.注意

- inline只是建议编译器内联，但编译器不一定会做内联
- 调用内联函数之前，要先调定义和声明好函数是内联的
- 一般几行代码的函数用内联，但像递归和一些执行复杂逻辑的函数不用内联

# 8.动态内存管理

也可以用C语言那一套

- new：申请内存 == malloc

  ```c++
  int *p1,*p2,*p3;
  p1 = new int;
  	//p1 = (int*)malloc (sizeof(int));
  p2 = new int(123);
  	//申请一个int类型空间，并初始化为123,不是空间地址即p2的值为123，而是空间里存的是123
  p3 = new int[123];
  	//申请123个int类型内存空间,即申请数组
  ```

- delete：释放内存 == free

  ```c++
  delete p1;
  delete p2;
  
  /*释放整个大小为123的数组空间*/
  delete []p3;
  
  /*释放一个int型内存空间p3[0]*/
  delete p3;
  ```

# ——C++面向对象——

面向对象更适合于开发大型软件，更有利于代码的复用。

# 面向对象三大特性

## 1.封装

​	将数据和操作数据的函数包装在一起的主要目的就是实现封装和隐藏。隐藏就是不让结构体外的函数直接修改结构体中的数据，只能通过结构体的成员函数对数据进行修改。

为了实现数据的隐藏，C++新增3三个访问权限限定符

- public公有的，函数和数据可以被结构体内外的任何函数包括main函数访问。
  <u>自己，子类以及外部都能访问</u>
- protected保护成员，与继承相关，能被派生类访问，但不能被类外的任何地方访问。
  <u>只能自己和子类访问，但外部不能访问</u>
- private （隐藏）私有的，只能被结构体内部函数访问。
  <u>只有自己能访问，子类以及外部不能访问</u>

## 	2.继承

## 	3.多态

# 面向对象实现手段

## 1.结构体

​	C++特有的内部可以调用或者实现函数的结构体

- **struct 关键字：**用于定义结构体，它告诉编译器后面要定义的是一个自定义类型。
- **成员变量：**成员变量是结构体中定义的数据项，它们可以是任何基本类型或其他自定义类型。<u>在 struct 中，这些成员默认是 public，可以直接访问。</u>
- **成员函数：**结构体中也可以包含成员函数，这使得结构体在功能上类似于类。成员函数可以操作结构体的成员变量，提供对数据的封装和操作。
- **访问权限：**与 class 类似，你可以在 struct 中使用 public、private 和 protected 来定义成员的访问权限。在 struct 中，默认所有成员都是 public，而 class 中默认是 private。

## 2.类

### 2.1.定义作用

功能与struct相同，但更安全的一种全新数据类型,更安全是因为**类成员默认都为private，而结构体成员默认都为public。**

### 2.2.语法格式

```c++
class class_name{
    private:
    	....
        ....
    public:
    	void fun1();
    	void fun2();
    	int fun3();
         ...
            
};
void class_name::fun1(){
    
}
void class_name::fun2(){
    
}
int class_name::fun3(){
    
}
//类内声明函数，类外定义函数
```

# 构造函数

## 1.构造函数初步

​	构造函数是与类同名的特殊成员函数，主要用来初始化对象的数据成员，即一次调用全部初始化好。当创建一个类的对象时，构造函数会自动被调用，从而省去了手动调用实现。

## 2.特点

- 与类同名（包括大小写）
- 没有返回类型，连void都不写
- 可以有0-多个参数
- 可以被重载
- 创建类对象时由系统自动调用，不允许在程序中显示调用

```c++
#include <iostream>  
using namespace std;  
class Box {  
public:  
    double length;   // 长度  
    double breadth;  // 宽度  
    double height;   // 高度  
    // 默认构造函数  
    Box() {  
        cout << "Default Constructor called." << endl;  
        length = breadth = height = 0.0;  
    }  
    // 参数化构造函数  
    Box(double l, double b, double h) {  
        cout << "Parameterized Constructor called." << endl;  
        length = l;  
        breadth = b;  
        height = h;  
    } 
};  
  
int main() {  
    Box Box1;           // 调用缺省/默认构造函数  
    Box Box2(3.3, 1.1, 1.5); // 调用参数化构造函数 
    Box Box3() //error，错误
    return 0;  
}
```

## 3.缺省构造函数

​	如果没在类里面实现构造函数，系统自动送一个构造函数一个无参数的构造函数，前提是没有在类里面自定义任何形式的构造函数，而这个被送的函数就是缺省构造函数。

```c++
#include <iostream>  
using namespace std;  
class Price{
	public:
		int ge;
		int shi;
		int bai;
		Price(){
			cout << "Default Constructor called2" << endl;
			ge = shi =bai = 0;
		}
};
class Box {  
	public:  
		int length;   // 长度  
		int breadth;  // 宽度  
		int height;   // 高度  
		Price  price;
};  

int main() {
	Box Box1;           // 调用缺省/默认构造函数  
	cout << Box1.length << " " << Box1.breadth << " " << Box1.height << endl;
    //Default Constructor called2
	//1956810952 29921 1956810376
	return 0;  
}
```

注意：

- 如果一个类没有定义任何构造函数，那么编译器会为其提供一个缺省无参构造函数。
- 对基本类型成员变量，缺省构造函数不做初始化（**<u>都没有构造函数，编译器不知道要赋什么样的初值，所以就不初始化</u>**）。
- 对类类型成员变量，缺省构造函数将自动调用相应类的构造函数来初始化。
- 如果一个类只要自定义了构造函数，无论是否有参数，编译器不再提供缺省构造函数。

## 4.重载构造函数

​	即在类里面定义多个构成重载关系的构造函数。

```c++
#include <iostream>  
using namespace std;
struct Param{
	int l,b,h;
};
class Box {  
	public:  
		int length;   // 长度  
		int breadth;  // 宽度  
		int height;   // 高度  
		Box();
		Box(int l,int b,int h);
		Box(Param &param);
};
Box::Box(){
	cout << "defalut constrcutor" << endl;
}
Box::Box(int l,int b,int h){
	length = l;
	breadth = b;
	height = h;
	cout << "constrcutor(int,int,int)" << endl;
}
Box::Box(Param &param){
	length = param.l;
	breadth = param.b;
	height = param.h;
	cout << "constructor(Param &param)" << endl;
}

int main() {
	Box Box1;           // 调用缺省/默认构造函数  
	Box Box2(3,4,5);    //调用参数构造函数
	Param param;					//调用结构体参数构造函数
	param.l = 3;
	param.b = 4;
	param.h = 5;
	Box Box3(param);
	return 0;  
}

defalut constrcutor
constrcutor(int,int,int)
constructor(Param &param)

```

## 5.类型转换构造函数

### 5.1.定义

​	将一个其他类型的变量或者常量直接赋值给类，编译器会优先找类中参数与该变量或者常量类型相同的构造函数，利用该变量或者常量通过该构造函数构造出一个类，这样就是类赋值给类（**不会调用类型转换构造函数、拷贝赋值函数，注意区分**），就不会报错了。

​	类型转换构造函数特点就是只有一个参数。

```c++
#include <iostream>
#include <cstring>
using namespace std;
class A{
private:
	int i;
public:
	A(int para){
		i = para;
	}
	A(const char* s){
		i = strlen(s);
	}
	explicit A(char jj){
		i = static_cast<int>(jj);
	}
};
int main(int argc, char *argv[]){
	A a1 = 1;
	A a2 = "Hello";
	A a3 = A('A');
}
```

### 5.2.explicit关键字

- 构造函数前面没加explicit关键字，赋值时写成下面两种形式均可	
- 如果加了explicit关键字，则必须写成强制转换形式

```c++
Integer b = Integer(1);
Integer b = 1;//error: conversion from ‘int’ to non-scalar type ‘Integer’ requested
```

## 6.拷贝构造函数

### 6.1.语法

​	未自定义的话，编译器同样送一个缺省拷贝构造函数。

- 对基本类型成员变量，按字节复制（**<u>因毕竟有已经初始化好的对象赋值给我，我就可以直接调用它里面的基本数据成员的值作为此次拷贝的值）</u>**
- 对于类类型成员变量，调用相应类的拷贝函数

### 6.2.注意事项

#### 拷贝构造函数调用时机

1. 用已定义对象作为同类型对象的构造函数的实参A a1(a2);
2. 以对象的形式向函数传递参数。
3. 从函数中返回对象。

#### 拷贝构造过程风险高且效率低，设计应尽可能避免

1. 避免和减少对象的拷贝

2. 传递对象形参，使用**引用型**参数

3. 从函数中返回对象，用**引用型返回值**


### 6.3.深拷贝与浅拷贝

- **浅拷贝**
  类中的缺省拷贝构造函数，对指针形式的成员变量按字节复制，而不会复制指针所指向的内容，这种拷贝方式称为浅拷贝。**系统给的默认拷贝构造函数为浅拷贝**

- **深拷贝**
  自定义拷贝函数，新建一个成员变量，重新为指针指向内容的申请一块空间，即自定义实现深拷贝。

  ```c++
  #include <iostream>
  using namespace std;
  class A{
  	private:
  		int *data;
  		int *price;
  	public:
  		A(){
  			cout << "A(void)" << endl;
  			data = new int(1);
  			price = new int(1.5);
  		}
  		A(const A &that){//深拷贝构造函数
  			cout << "A(const A)" << endl;
  			data = new int(*that.data);
  			price = new int(*that.price);
  		}
  		void print(){
  			cout << *data << " " << *price << endl;
  		}
  };
  ```

### 6.4.拷贝赋值

**含义**：一个对象已经存在时，用另外一个已存在的对象给他赋值，就发生了拷贝赋值。比如已经声明并创建了对象i1，i2，当执行i2 = i1语句时,编译器会将其翻译成i2.operator = (i1)，即执行operator=成员函数进行处理。

**operator=函数**此函数称为拷贝赋值操作符函数，同样，**没有定义时编译器同样会自动分配，且为浅拷贝**。因此自定义拷贝赋值函数相当于进行等号运算符重载。

```c++
#include <iostream>
using namespace std;
class A{
	private:
		int *data;
		int *price;
	public:
		A(){
			cout << "A(void)" << endl;
			data = new int(1);
			price = new int(1.5);
		}
		A(int arg){
			cout << "A(int)" << endl;
			data = new int(arg);
			price = new int(arg);
		}
		A(const A &that){//深拷贝
			cout << "A(const A)" << endl;
			data = new int(*that.data);
			price = new int(*that.price);
		}
		void print(){
			cout << *data << " " << *price << endl;
		}
		A &operator=(const A &that){//深拷贝赋值
			cout << "A::operator" << endl;
			if(this != &that){
				delete data;  
				delete price;
				data = new int(*that.data);
				price = new int(*that.price);
			}
			return *this;//返回对象本身是为了支持i1 = i2 = i3这种链式连续赋值操作。
						//i2 =i3的返回结果是i2对象自身，故后面才能执行i1= i2;
		}
};
int main(int argc, char *argv[]){
	A a1;//A(void),无参构造函数
	A a2(a1);//A(const A),拷贝构造函数
	A a3 = a1;//A(cosnt A)，拷贝构造函数
	A a4;//A(void),无参构造函数
	a4 = 10;//A(int),类型转换函数，转成A，然后再拷贝赋值函数A operator
	a2 = a3;//A operator 拷贝赋值函数
	return 0;
}
```

## 7.构造函数总结

​	编译器给的函数都是public权限的。

### 7.1.构造函数定义总结

- 构造函数说白了就是在声明类的时候，由系统自动调用构造函数就已经完成了类成员的初始化。

- 构造函数可以重载，从无参数的无参构造函数到有多个参数的一般构造函数；从基本数据类型的参数构造函数到复杂数据类型（如结构体）的参数的构造函数。

- 一般的构造函数 

  ```c++
  定义: A(形式参1，形参2，......){...};
  使用: A a(实参1，实参2，......);
  ```

- 类型转换构造函数

  ```c++
  定义:explict A(形参){...};
  使用：A a = A(实参);  
  //多用于结构体或者其他复杂数据类型赋值给类对象。
  ```

- 拷贝构造函数

  ```c++
  定义：A(const A& parm){...};
  使用：A a; A b = a ;A c(a);
  ```

- 拷贝，一般，类型转换构造函数都构成重载关系。


### 7.2.构造函数参数个数总结

1. 0个参数，无参构造函数(自定义)，系统给的缺省构造函数
2. 1个参数，带参构造函数(自定义)，拷贝函数(形参为const 类名& 形参名)，类型转换构造函数。
3. 2个及两个以上参数，带参构造函数(自定义)。

### 7.3.拷贝构造、拷贝赋值、类型转换构造区分

拷贝构造，是构造函数，只有当构造某个不存在的对象时才会调用。

拷贝赋值，是赋值函数，赋值的两个操作数对象都是先前已经存在的。

类型转换构造，也是构造函数，但与拷贝构造函数不同的是，拷贝构造函数的参数是一个已经存在的同类型对象，而类型转换函数，虽然把其他类型的参数强制转换成了类类型参数，但这并不算生成了一个后续可以被认为已存在的对象。

# 初始化列表

## 1.语法格式

:成员1(值1)，成员2(值2)......

```c++
Box::Box(int l,int b,int h){
	length = l;
	breadth = b;
	height = h;
	cout << "constrcutor(int,int,int)" << endl;
}
等价于
Box::Box(int l,int b,int h):length(l),breadth(b),height(h){
	cout << "constrcutor(int,int,int)" << endl;
}
```

## 2.必须用初始化列表的场景

- 如果A类a有B类类型成员b，而B类又没有无参构造函数，则必须通过初始化列表显示指明其初始化方式。

  即如果A类的构造函数没有用初始化列表，则调用A类构造函数时，也会自动调用B类构造函数，但是调用B类构造函数时，由于没有带参数给B类，故编译器会以为我们想调用B类的无参构造函数，但B类又没用无参构造函数，所以编译器报错。
- 继承时基类没有无参构造函数，由于继承是要在创建子类之前就把父类创建好，但父类没有无参构造函数，此时要在子类的构造函数中利用初始化列表初始化父类。

  ```c++
  #include <iostream>
  using namespace std;
  class B{
  public:
  	B(int data){
  		cout << "B(int)" << endl;
  	}
  };
  class A{
  private:
  	B  m_data;//error: no matching function for call to ‘B::B()’，由于已经定义了B的构造函数，系统不会分配缺省的无参构造函数，故此时这样声明编译器由于找不到无参构造函数而报错
  public:
  	A(void):m_data(1){//用初始化列表解决上述问题
  		cout << "defalut constructor(void)" << endl;
  	}
  };
  int main(int argc, char *argv[]){
  	A a;
  }
  ```

- **“const”修饰的成员变量**以及**引用型**成员变量必须在初始化列表中初始化。
  const修饰的成员变量以及引用(如int const *p)都是只读的，故必须在声明时就初始化，不能声明后初始化，因此要在系统调用构造函数时就给它们赋好值，因此要用到初始化列表。

  ```c++
  #include <iostream>
  int num = 100;
  using namespace std;
  class A{
  private:
  	const int m_c;
  	int &m_r;
  public:
  	A():m_r(num),m_c(1){
  		//m_c = 1;  //error:assignment of read-only variable ‘m_c’
  		//m_r = num;//error:assignment of read-only variable ‘m_r’
  
  		cout << "defalut constructor(void)" << endl;
  	}
  };
  int main(int argc, char *argv[]){
  	A a;
  }
  class A{
      public:
      	int& m_r;
      	const int m_c;
      	A(void):m_r(100),m_c(100){
          }
  };
  ```

## 3.初始化顺序

​	类中成员变量按声明顺序依次被初始化，而与初始化表中的顺序无关。

```C++
#include <iostream>

using namespace std;
class B{
public:
	B(int data){
		cout << "B(int)" << endl;
	}
	B(){
		cout << "B(void)" << endl;
	}
};
class A{
private:
	B  m_data;
	B  m_r;
public:
	A(void):m_r(),m_data(1){
		cout << "defalut constructor(void)" << endl;
	}
};
int main(int argc, char *argv[]){
	A a;
}
//执行结果
B(int)
B(void)
defalut constructor(void)

```

# this指针

## 1.定义

​	在程序运行时，类的成员函数存放在进程空间里的代码段里，而其他的私有数据会单独开辟一块空间。
​       对于多个类的对象来说，只有私有数据占自己的一块内存空间，而成员函数是在进程代码段供同一进程中同一类的各个对象共享的，但是代码段里被共享的函数是如何区分传入的参数是哪个对象的呢？此时this指针就起到了作用。<u>**this是一个用于标识对象自身的隐式指针，代表对象自身的地址**。</u>

在编译类成员函数时，C++编译器会自动将this指针添加到成员函数的参数列表中。在用类的成员函数时，调用对象会把**自己的地址通过this指针传递给成员函数**。其实调用成员函数时，编译器会隐式地传入了this指针，访问的变量其实就是this->变量名。

```c++
#include <iostream>
using namespace std;
class A{
private:
	int m_data;
public:
	A(){
		this->m_data = 1;
	}
	void print(){
		cout << this->m_data << endl;
	}
};
int main(int argc, char *argv[]){
	A a1;
	a1.print();
	return 0;
}
```

## 2.使用场景

- 类中的成员变量和类成员函数形参变量名字一样，可以通过this指针区分
- 从成员函数中返回调用对象自身（返回自引用），支持链式调用
- 在成员函数中销毁对象自身（对象自销毁）

```C++
#include <iostream>
using namespace std;
class Counter{
    private:
    	int count;
    public:
    	Counter(int count = 0){
            this->count = count;//成员变量与参数变量重名
        }
    	Counter &add(void){
            ++count;
            return *this;//返回对象本身
        }
    	void print(void){
            cout << count << endl;
        }
        void destroy(void){
        	delete this;//销毁对象本身
        }
}


int main(void){
    Counter cnt;//构造函数初始化为0
    cnt.print();//0
    cnt.add().add().add();//链式操作，3
    cnt.print();//3
    
    Counter* pcn = new Counter;
	pcn->print();
	pcn->destory();
}
```

# 常成员函数

## 1.定义

​	为了禁止成员函数修改成员数据的值，可以将它设置为常成员函数。设置方法就是在函数体之前加上const关键字。用于函数的操作只对成员变量进行读操作。**<u>其实fun const{}的本质就是把this变成const this</u>**

```c++
#include <iostream>
using namespace std;
class A{
private:
	int m_data;
public:
	A(){
		m_data = 1;
	}
	void add() const{//error: increment of member ‘A::m_data’ in read-only object

		m_data++;
	}
	void print(){
		cout << m_data << endl;
	}
};
int main(int argc, char *argv[]){
	A a1;
	a1.print();
	a1.add();
	a1.print();
	return 0;
}
```

## 2.注意事项

- 常对象只能调用常函数，非常对象既可以调用非常函数，也可调用常函数，且优先调用非常函数。
  常对象之所以为常对象，是其数据肯定不能变，故肯定不能调用非常对象，不然可能会调用到尝试修改自身数据的函数

  ```c++
  class A{
  private:
  	int m_data;
  public:
  	A(){
  		m_data = 1;
  	}
  	void add(){
  		m_data++;
  	}
  	void print() const{
  		cout << m_data << endl;
  	}
  };
  int main(int argc, char *argv[]){
  	A a1;
  	const A a2;
  	a2.print();
  	a2.add();//error: passing ‘const A’ as ‘this’ argument discards qualifiers 
  	return 0;
  }
  ```

- 函数名和形参表相同的成员函数，常函数和非常函数构成重载关系，因为区别在于this一个有const，一个没const。
- 被mutable修饰的成员又可以在常函数中被修改，相当于编译器开了个后门。

# 析构函数

## 1.定义

作用与构造函数相反，用于对象生存期结束时，完成对象的清理工作。析构函数的名字是：~类名。

```c++
~X(){...}
```

## 2.特点

- 无参数无返回值

- 不能重载

- 只能由系统调用，不能显示调用

  1.栈对象【自动调用】，离开其作用域时析构函数自动调用，如离开if分支，就是离开了if作用域。

  2.堆对象【手动调用】，执行delete操作时析构函数自动调用。

## 3.缺省析构函数

​	没有定义，操作系统送一个

- 对基本数据成员，不做处理
- 对类对象成员，调用类的对应析构函数

```cpp
#include <iostream>
using namespace std;
class B{
public:
	B(){
		cout << "class B constructor(void)" << endl;
	}
	~B(){
		cout << "free B" << endl;
	}
};
class A{
private:
	int m_data;
	B b1;
public:
	A(){
		m_data = 1;
		cout << "class A constructor(void)" << endl;
	}
	~A(){
		cout << "free A" << endl;
	}
};
int main(int argc, char *argv[]){
	A a1;
	return 0;
}
//执行结果
class B constructor(void)
class A constructor(void)
free A
free B
```

## 4.对象创建和销毁顺序

对象创建：

- 分配内存
- 构造成员子对象
- 调用构造函数

对象销毁：

- 调用析构函数
- 析构成员对象
- 释放内存

# 智能指针

https://blog.csdn.net/qq_56896418/article/details/141301814

使用智能指针，主要是为了防止内存泄漏。特别是对应大型工程，难免会有遗漏new完之后忘记delete的地方，从而造成内存泄漏。

在现代C++编程中，智能指针是管理动态内存和资源的关键工具。<memory>头文件提供了几种智能指针，包括`std::unique_ptr`、`std::shared_ptr` 和 `std::weak_ptr`。每种智能指针有其独特的用途和特点。

## 1.`unique_ptr`

`std::unique_ptr`是一种独享的智能指针（一个指针只能指向一段内存），它负责管理一个动态分配的对象的生命周期，并保证在 `std::unique_ptr`被销毁时，所管理的对象会被正确释放。`std::unique_ptr`不能被复制，但可以被移动

### 1.创建智能指针

```cpp
//C++11: 
std::unique_ptr<Task> taskPtr(new Task(23));
//C++14: 
std::unique_ptr<Task> taskPtr = std::make_unique<Task>(34);
```

### 2.不能复制

`unique_ptr`不能直接复制，必须使用`std::move()`转移其管理的指针，转移后原unique_ptr为空。`std::unique_ptr<Task> taskPtr4 = std::move(taskPtr2);`

### 3.成员函数

| 成员函数  | 作用                                                         |
| --------- | ------------------------------------------------------------ |
| reset(q)  | 令智能指针p中存放指针q，即p指向q的空间，reset参数为空则重置unique_ptr为空，最后delete其原来关联的指针。 |
| release() | 仅仅只是释放关联指针的所有权，置unique_ptr为空，不delete关联指针，返回的是关联的普通指针。 |
| get()     | 获取普通指针，返回的是关联的普通指针                         |

### 4.防止内存泄漏

- `unique_ptr`是C++ 11提供的用于防止内存泄漏的智能指针中的一种实现，是一个装指针的容器，且拥有关联指针的唯一所有权，独享被管理对象指针所有权的智能指针。`unique_ptr`对象包装一个普通指针，并负责其生命周期。当该智能指针对象被销毁时，会在其析构函数中删除关联的普通指针。
- `unique_ptr`具有`->`和`*`运算符重载符，因此它可以像普通指针一样使用。由上一节可知，如果是处于堆上，new生成的对象。需要我们去手动delete，一个是如果代码量多，忘记delete了，那么很容易造成内存泄漏，且也要时刻注意是否需要delete语句很麻烦，所以引入unique_ptr指针，相当于自动delete。

```cpp
#include <iostream>
#include <memory>
struct Task {
    int mId;
    Task(int id ) :mId(id) {
        std::cout << "Task::Constructor" << std::endl;
    }
    ~Task() {
        std::cout << "Task::Destructor" << std::endl;
    }
};
int main()
{
    //利用普通指针创建unique_ptr实例
    std::unique_ptr<Task> taskPtr(new Task(23));
    //通过 unique_ptr 访问其成员
    int id = taskPtr->mId;
    std::cout << id << std::endl;
    return 0;
}

输出：
Task::Constructor
23
Task::Destructor
```

`unique_ptr<Task>`对象 `taskPtr`接受普通指针作为参数。现在当main函数退出时，该对象作为栈中的变量因超出作用范围就会调用其析构函数，在`unique_ptr`对象`taskPtr `的析构函数中，会删除关联的普通指针，这样就不用专门delete Task对象了。这样不管函数正常退出还是异常退出（由于某些异常），也会始终调用`taskPtr`的析构函数。因此，原始指针将始终被删除并防止内存泄漏。

## 2.`shared_ptr`

`std::shared_ptr `是一种共享的智能指针，它允许多个` std::shared_ptr `实例共享对同一个动态分配对象的所有权。对象的生命周期由引用计数控制，当最后一个 `std::shared_ptr `被销毁时，对象才会被释放。

```cpp
#include <iostream>
class Ball {
public:
    Ball();
    ~Ball();
    void bounce();
};
Ball::Ball() {
    std::cout << "Ball init" << std::endl;
}

Ball::~Ball() {
    std::cout << "Ball destroy" << std::endl;
}

void Ball::bounce() {
    std::cout << "Ball bounce" << std::endl;
}
#include <iostream>
#include "Ball.h"
using namespace std;
#include <memory>
int main() {
    shared_ptr<Ball> ball1 = make_shared<Ball>();
    cout << "ball1 use count: " << ball1.use_count() << endl;
    shared_ptr<Ball> ball2 = ball1;
    cout << "ball1 use count: " << ball1.use_count() <<" ball2 use count: " << ball2.use_count() << endl;
    shared_ptr<Ball> ball3 = ball1;
    cout << "ball1 use count: " << ball1.use_count() <<" ball2 use count: " << ball2.use_count() <<" ball3 use count: " << ball3.use_count() << endl;
    ball1.reset();
    cout << "ball1 use count: " << ball1.use_count() <<" ball2 use count: " << ball2.use_count() <<" ball3 use count: " << ball3.use_count() << endl;
    ball2.reset();
    cout << "ball1 use count: " << ball1.use_count() <<" ball2 use count: " << ball2.use_count() <<" ball3 use count: " << ball3.use_count() << endl;
    ball3.reset();
    cout << "ball1 use count: " << ball1.use_count() <<" ball2 use count: " << ball2.use_count() <<" ball3 use count: " << ball3.use_count() << endl;
    return 0;
}
```

结果：

```bash
Ball init
ball1 use count: 1
ball1 use count: 2 ball2 use count: 2
ball1 use count: 3 ball2 use count: 3 ball3 use count: 3
ball1 use count: 0 ball2 use count: 2 ball3 use count: 2
ball1 use count: 0 ball2 use count: 0 ball3 use count: 1
Ball destroy
ball1 use count: 0 ball2 use count: 0 ball3 use count: 0
```



# 静态成员

## 定义

直接理解为**局限在类中的全局变量**，即为该类类型的任意对象均可以共享访问。

类在实例化时，只有非静态成员变量才会有对应的内存空间，故即使没声明类对象，也能访问类的静态成员。

**类的静态成员(变量和方法)属于类本身，在类加载的时候就会分配内存，可以通过类名直接去访问；**

**非静态成员（变量和方法）属于类的对象，所以只有在类的对象产生（创建类的实例）时才会分配内存，然后通过类的对象（实例）去访问。**

## 9.2.静态成员变量

### 9.2.1.初始化

```c++
class 类名{
    static 数据类型 变量名;//声明
};
数据类型 类名::变量名 = 初值;//只能在类外面进行初始化
```

### 9.2.2.访问方式

- 类名::静态成员变量；

  ```c++
  cout << A::data << endl;
  ```
- 对象.静态成员变量；

  ```
  A a1;
  cout << a1.data << endl;
  ```

## 9.3.静态成员函数

- 静态成员函数可以在类的内部也可以在外部定义，定义和普通成员函数没啥区别。
- 静态成员函数**没有this指针，没有const属性**，可以把静态成员函数理解为限制在类中使用的全局函数。
- 静态成员函数只能访问静态成员，**因为没有this指针，所以访问不了非静态成员变量**，但是在非静态成员函数中既可以访问静态成员，也可以访问非静态成员。
- 静态成员函数也要受到类的private，public访问控制限定符一样的约束。
- 在类外访问时，访问方式同静态成员变量一样。

```c++
#include <iostream>

using namespace std;

class A{
public:
	int data;
	A(){
		cout << "constructor (void)" << endl;
	}
	static void print(){
		cout << "static fun" << endl;
		data = 1;//error: invalid use of member ‘A::data’ in static member function
	}
};
int main(int argc, char *argv[]){
	A::print();//static fun
	A a1;//constructor (void)
	a1.print();//static fun
	return 0;
}
```

# 友元

类的封装具有信息隐藏能力，但也带来了访问效率问题。

C++通过友元给某些函数一项特权，可以避免利用成员函数而直接访问类中的私有成员从而提高效率，使用的关键字是friend。

## 10.1.友元函数

专指类外的定义的其他的,不属于类成员的函数。

```c++
#include <iostream>
using namespace std;
class A{
private:
	static int m_data;
public:
	//friend void print();
    //In function ‘void print()’:error: ‘int A::m_data’ is private within this context
};
int A::m_data = 1;
void print(){
	cout << A::m_data << endl; 
}
int main(int argc, char *argv[]){
	print();
}

```

## 10.2.友元类

一个类是另外一个类的友元时，该类的所有函数也是另外一个类的友元函数。友元类是单向的不是双向的。

```c++
#include <iostream>
using namespace std;
class B{
private:
	int m_data;
public:
	B(){
		m_data = 2;
	}
	//friend class A;
    //In member function ‘void A::print(const B&)’,error: ‘int B::m_data’ is private within this context
};
class A{
private:
	int m_data;
public:
	A(){
		m_data = 1;
	}
	void print(const B &that){
		cout << that.m_data << endl;
	}
};
int main(int argc, char *argv[]){
	B b1;
	A a1;
	a1.print(b1);
}
```

## 10.3.友元成员函数

专指类中的成员函数。

错误示例：

```c++
#include <iostream>

using namespace std;
class A;//1.先声明class A,编译器就去检查创建A类的代码
class B{
private:
	int m_data;
public:
	B(){
		m_data = 2;
	}
  	friend void A::print(const B &that);//3.报错，说A类是不完整的
};
class A{
private:
	int m_data;
public:
	A(){
		m_data = 1;
	}
	void print(const B &that);
};
void A::print(const B &that){
	cout << that.m_data << endl;//2.不能直接访问B.data，因为只知道A的声明，不知道具体定义是啥，编译器怎么知道B有无data成员，故此处报错。
}
int main(int argc, char *argv[]){
//	B b1;
//	A a1;
//	a1.print(b1);
}
可以声明一个类而不定义它
   class Screen;//declaration of the Screen class
   这个声明,有时候被称为前向声明(forward declaration),在程序中引入了类类型的Screen.在声明之后,定义之前,类Screen是一个不完全类型(incompete type),即已知Screen是一个类型,但不知道包含哪些成员.
   不完全类型只能以有限方式使用,不能定义该类型的对象,不完全类型只能用于定义指向该类型的指针及引用,或者用于声明(而不是定义)使用该类型作为形参类型或返回类型的函数.
```

修正

```c++
#include <iostream>

using namespace std;
class B;
class A{
private:
	int m_data;
public:
	A(){
		m_data = 1;
	}
	void print(const B &that);//虽然B是incompete type,但这里只用了引用，并未试图定义对象或者访问成员。
};
class B{
private:
	int m_data;
public:
	B(){
		m_data = 2;
	}
  	friend void A::print(const B &that);//类A在此次只是作为作用域，并未尝试去访问其成员，因此只要知道有一个类
    //是A，不必知道其具体成员内容也可以。
};
void A::print(const B &that){
	cout << that.m_data << endl;
}
int main(int argc, char *argv[]){
//	B b1;
//	A a1;
//	a1.print(b1);
}
```

# 单例模式

- 单例模式,也称为单件模式，意图是保证一个类仅有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。

- 面向对象编程中，每个对象都应该抽象代表一个设备，并通过对象完成对设备的管理和维护。

- 有些情况下只允许一个类实例化一个对象很重要，如打印机管理，设备管理器，任务管理器等。


## 一般实现方法

1. 私有化构造函数、拷贝构造函数。防止外界再创建对象时构造。
2. 使用静态成员变量维护单一的单例对象，即相当于在private里面声明一个该类单的对象，且是static的。
3. 定义public权限的静态成员函数用于获取单例对象（让外界能够获取操作实例对象）。

## 饿汉式实现（栈区）

饿汉式的对象在类产生的时候就创建了，一直到程序结束才释放。即对象的生存周期和程序一样长，因此该实例对象需要存储在内存的全局数据区，故使用[static](https://so.csdn.net/so/search?q=static&spm=1001.2101.3001.7020)修饰。

```c++
#include <iostream>

using namespace std;

class A{
private:
	int m_data;
	A(int arg = 10){
		m_data = arg;
	}
	A(const A& that){}//拷贝构造也能创建对象，故拷贝构造也要改
	static A m_instance;
public:
	static A& getInstance(){
		return m_instance;
	}
	void print(){
		cout << m_data << endl;
	}
};
A A::m_instance = 123;//调用类型转换构造函数，由于是饿汉模式，所以在main函数调用之前就构造好了。


int main(int argc, char *argv[]){
	A &a1 = A::getInstance();
	A &a2 = A::getInstance();
	A &a3 = A::getInstance();
	A a4 = 2;//error: ‘A::A(int)’ is private within this context
	a1.print();
	a2.print();
	a3.print();
	cout << &a1 << endl;
	cout << &a2 << endl;
	cout << &a3 << endl;
}
```

## 懒汉式实现（堆区）

是在第一次调用getInstance()的时候，才创建实例对象。直接把对象定义为static，然后放在getInstance()中。第一次进入该函数，就创建实例对象，然后一直到程序结束，释放该对象。
用时再new创建，当引用计数为0时再delete删除，但很麻烦，还有维护引用计数，因此可以使用unique_ptr智能指针。

```cpp
// 懒汉式单例的实现
#ifndef C_SINGLETON_H
#define C_SINGLETON_H
 
#include<iostream>
#include<memory>
using namespace std;
class CSingleton
{
private:
    CSingleton(){ cout << "单例对象创建！" << endl; };
    CSingleton(const CSingleton &);
    CSingleton& operator=(const CSingleton &);
    ~CSingleton(){ cout << "单例对象销毁！" << endl; };
 
    static CSingleton *myInstance;
 
 
public:
    static CSingleton * getInstance()
    {    
        if (nullptr == myInstance)
        {
            myInstance = new CSingleton();
        }
        return myInstance;
    }
 
private:
    // 定义一个内部类
    class CGarbo{
    public:
        CGarbo(){};
        ~CGarbo()
        {
            if (nullptr != myInstance)
            {
                delete myInstance;
                myInstance = nullptr;
            }
        }
    };
    // 定义一个内部类的静态对象
    // 当该对象销毁时，顺带就释放myInstance指向的堆区资源
    static CGarbo m_garbo;
};
 
#endif
```

## 线程安全问题

对于懒汉式这两种情况，当调用`getInstance()`函数时，如果对象还没产生（第一种状态），就需要产生对象，然后[返回对象](https://marketing.csdn.net/p/3127db09a98e0723b83b2914d9256174?pId=2782&utm_source=glcblog&spm=1001.2101.3001.7020)指针。如果对象已经存在了（第二种状态），就直接返回对象指针。当单线程时，没有问题。但是，**多线程情况下，如果一个函数中不同状态有不同操作，就要考虑线程互斥的问题了**。因此，我们需要修改一下`getInstance`中的实现。

# ——继承——

# 1.继承

## 1.1.定义

继承，基于一个已有类创建新类，使类与已有类具有同样的功能，即新类具有已有类相同的数据成员和成员函数。继承是代码重用的基本工具。已有类称为基类（父类/超类），新类称为派生类（子类）。继承可以看成申请新的空间并复制基类中被继承的成员，继承与否主要看子类是否为其分配了内存空间，并不是看是否能访问，有些成员虽然不能被继承，但仍可以被子类访问。

- 基类的<u>**构造函数和析构函数**</u>不能继承
  尽管派生类不直接继承基类的构造和析构函数，有自己的构造和析构函数，但是派生类的构造函数一定会调用基类的某一个构造函数，析构函数也是一样。
- 基类的<u>友元函数</u>不能继承
- <u>静态数据成员和静态成员函数</u>不能继承
  即不会在子类中为其生成内存空间来拷贝一份，因为静态数据成员和静态成员函数在类实例中本身就不会生成内存空间存储，但仍然可以访问。

```c++
#include <iostream>

using namespace std;

void Friend_fun();
class Base{
public:
	int a;
	static int b;
	friend void Friend_fun(const Derived &a);
	Base(int arg){
		cout << "Base(int)" << endl;
		a = arg;
	}
	void print(){
		cout << "Base::a ==" << a << endl;
		cout << "Base::b ==" << b << endl;
	}
	static void fun(){
		cout << "static void fun" << endl;
	}
	~Base(){
		cout << "~Base" << endl;
	}

};
int Base::b = 100;
class Derived:public Base{
	public:
		Derived():Base(10){//初始化列表
			Base::Base(10);//error:cannot call constructor ‘Base::Base’ directly
			print();//继承了，可以直接调用
			cout << "Derived" << endl;
		}
		~Derived(){
			cout << "~Derived" << endl;
		}
};
void Friend_fun(const Derived &a){
	cout << a.a << endl;
    cout << a.b >> endl;
	cout << a.c << endl;//error:int Derived::c’ is private within this context
}
int main(int argc, char *argv[]){
	Derived a;
    cout << sizeof(a) << endl;//8
	//a.print();
	//Friend_fun();	
}
//执行结果：
Base(int)
Base::a ==10
Base::b ==100
Derived
~Derived
~Base
```

## 1.2.继承的方式

### 1.2.1.语法格式

```c++
class 派生类名:继承方式 基类名{
    成员声明和定义
};
```

### 1.2.2.继承方式

- **公有继承**
  继承方式为public的继承称为公有继承，在这种继承中，基类成员的访问权限在派生类中保持不变。

  基类不能访问父类的私有成员。

  ```c++
  #include <iostream>
  
  using namespace std;
  
  void Friend_fun();
  class Derived;
  class Base{
  private:
  	int a;
  protected:
  	int b;
  public:
  	int c;
  	Base(){
  		cout << "Base(void)" << endl;
  		a = 1;
  		b = 2;
  		c = 3;
  	}
  	void print(){
  		cout << a << " " << " " << b << " " << c << endl;
  	}
  	~Base(){
  		cout << "~Base(void)" << endl;
  	}
  };
  class Derived:public Base{
  private:
  	int d;
  public:
  	Derived(){
  		cout << "Derived(void)" << endl;
  	}
  	void print(){
  		cout << a << endl;//error: ‘int Base::a’ is private within this context
  		cout << b << endl;
  		cout << c << endl;
  	}
  	~Derived(){
  		cout << "~Derivedi(void)" << endl;
  	}
  };
  int main(void){
      Derived test;
      cout << test.a << endl; // error: ‘int Base::a’ is private within this context
      cout << test.b << endl; //error: ‘int Base::b’ is protected within this context
      cout << test.c << endl; //正确
      cout << test.d << endl; //error: ‘int Derived::d’ is private within this context
  }
  ```

- **保护继承**
  基类公有成员到了派生类里变成保护成员，其他权限不变。

- **私有继承**
  基类所有的成员到子类中全变成私有。

# 2.基类与派生类的关系

子类对象会继承基类的属性行为，任何时候子类对象都可以被当做基类类型对象，通过子类对象可以直接访问基类成员，如同基类对象在访问它们一样。

## 2.1.造型

**向上造型：**将子类类型的指针或者引用转换为基类类型的指针或者引用；这种操作性缩小的类型转换，在编译器看来是安全的，可以隐式转换

**向下造型：**将基类类型的指针或者引用转换为子类类型的指针或者引用；这种操作性放大的类型转换，在编译器看来是危险的，不能隐式转换，但可以显示转换即利用强转。

```c++
#include <iostream>

using namespace std;

class Human{
public:
	int age;
	string name;
	Human(const string &name,int age){
		this->age = age;
		this->name = name;
	}
	void eat(const string &food){
		cout << "我正在吃" << food << endl;
	}
	void sleep(int hour){
		cout <<"我每天睡" << hour << "小时" << endl; 
	}
};
class student:public Human{

public:
	int sno;
	student(int sno,const string &name,int age):Human(name,age){
		this->sno = sno;
	}
	void who(){
		cout << "我是" << name << "," << "今年" << age << "岁" << "我的学号是:" << sno << endl; 
	}
	void learn(const string &course){
		cout << "我正在学习" << course << endl;
	}
};
class teacher:public Human{
private:
	int sno;
	int salary;
public:
	teacher(int sno,int salary,const string &name,int age):Human(name,age){
		this->sno = sno;
		this->salary = salary;
	}
	void teach(const string &course){
		cout << "我正在教" << course << endl;
	}
	void who(){
		cout << "我是" << name << "," << "今年" << age << "岁" << "我的工号是:" << sno << endl; 
	}
};
int main(int argc, char *argv[]){
	student s1(1001,"Tom",23);
	s1.who();
	s1.eat("宫保鸡丁");
	s1.learn("C++");
	s1.sleep(8);
	cout << "==========" << endl;
	Human* p;
	p = &s1;//向上造型（合理），可以隐式转换
	p->eat("宫保鸡丁");
	s1.sleep(8);
	p->who();//error: ‘class Human’ has no member named ‘who’
	cout << "==========" << endl;
	student *ps = static_cast<student*>(p);//向下造型(合理)
	ps->eat("宫保鸡丁");
	ps->sleep(8);
	ps->who();
	cout << "==========" << endl;
	Human h("刘备",26);
	student *s = static_cast<student*>(&h);//向下造型(不合理由),因为human里没有sno，故新建一个human对象再造型，sno值不确定
	s->eat("宫保鸡丁");
	s->sleep(8);
	s->who();
	return 0;
}
```

## 2.2.成员函数重定义(名字隐藏)

### 2.2.1.重定义

简单说就是子类中定义了同父类**中同名**的函数，对父类的成员函数造成了隐藏，即子类对象调用该同名函数时调用的是子类的，而不是父类的，好像父类的被藏起来了一样。**父类和子类的同名函数无论如何都不构成重载关系，因为子类父类可以看成是两个作用域。**

### 2.2.2.解决方法

默认调用的是派生类的成员函数，如要调用基类的成员函数，则要加作用域限定符，指明作用域来访问父类。

## 2.3.派生类的构造与析构

### 2.3.1.构造

- 如果子类构造函数没有显示指明基类部分（基类子对象）的初始化方法，那么编译器将会自动调用基类的无参构造函数初始化基类子对象。
- 如果希望以有参的方式初始化基类部分，那么必须使用初始化列表来显示指明
- 子对象构造顺序

​					1.分配内存

​					2.构造基类子对象（按继承表顺序）

​					3.构造成员子对象（按声明顺序）

​					4.执行子类构造函数代码。

### 2.3.2.析构

与构造相反。

```c++
#include <iostream>

using namespace std;

class Member{
private:
	int member;
public:
	Member(){
		cout << "Member(void)" << endl;
	}
	~Member(){
		cout << "~Member(void)" << endl;
	}
};
class Base{
private:
	int base;
public:
	Base(int arg){
		base = arg;
		cout << "Base(int)" << endl;
	}
	~Base(){
		cout << "~Base(int)" << endl;
	}
};
class Derived:public Base{
private:
	int derived;
	Member mm;
public:
	Derived():Base(100){
		cout << "Derived(void)"  << endl;
	}
	~Derived(){
		cout << "~Derived(void)"  << endl;
	}
};
int main(int argc, char *argv[]){
	Derived d1;
	return 0;
}
//执行结果
Base(int)
Member(void)
Derived(void)
~Derived(void)
~Member(void)
~Base(int)
```

# 3.多重继承

C++允许一个类从一个或多个基类派生，如果一个类只要一个基类，称为单一继承。

如果一个类具有两个或两个以上的基类，就称为多重继承。

```c++
class 派生类名：继承方式 基类名1，继承方式 基类名2,.....{};
```

## 3.1.多重继承成员名字冲突

问题：多个基类里面有同名成员。

解决方法:调用使用时加作用域限定符，说明是哪个基类的成员。

## 3.2.钻石继承

钻石继承，一个派生类继承的多个基类又源自一个公共的祖先（公共基类）

![image-20240709134210970](C:\Users\z3254406361\AppData\Roaming\Typora\typora-user-images\image-20240709134210970.png)



### 3.2.1.存在问题

使得人的一些基本成员到助教中去就重复了，就有两个年龄，两个名字了。且调用学生的方法，就只改了学生继承过来的名字和年龄，教师继承过来的不变。

```c++
#include <iostream>
using namespace std;
class People{
private:
	string m_name;
	int m_age;
public:
	People(const string &name,int age){
		m_name = name;
		m_age = age;
	}
	void print(){
		cout << m_name << " " << m_age << " ";
	}
	void set(int age){
		m_age = age;
	}
};
class Teacher: public People{
private:
	int m_salary;
public:
	Teacher(int salary,const string &name,int age):People(name,age){
		m_salary = salary;
	}
	void print(){
		People::print();
		cout << m_salary << " " << endl; 
	}
	void set(int age){
		People::set(age);
	}
};
class Student:public People{
private:
	string m_level;
public:
	Student(const string &level,const string &name,int age):People(name,age){
		m_level = level;
	}
	void print(){
		People::print();
		cout << m_level << " " << endl; 
	}
	void set(int age){
		People::set(age);
	}
};
class Doctor:public Teacher,public Student{
public:
	Doctor(const string &name,int age,const string &level,int salary):Teacher(salary,name,age),Student(level,name,age){
	}
};
int main(int argc, char *argv[]){
	Doctor d1("张三",23,"研究生",1000);
	d1.Student::print();//23
	d1.Student::set(22);
	d1.Student::print();//22
	d1.Teacher::print();//23
	return 0;
}
张三 23 研究生 
张三 22 研究生 
张三 23 1000 
```

### 3.2.2.解决方法

​	虚继承

- 在继承表中使用virtual关键字修饰
- 位于继承链末端的子类负责构造公共基类子对象，利用初始化列表来构造

# 4.继承与组合

- 继承与组合是C++实现代码重要的两种主要方法。

- 继承是is-a的关系，比如水果和梨

- 组合是has-a的关系，即一个类有一个成员是另一类类的对象


# ——多态——

# 1.多态

多态通俗的讲，就是用一个相同的名字定义许多不同的函数，这些函数可以针对不同数据类型实现相同或相似的功能，即所谓的“一个接口，多种实现”。<!--【多态关系是在父类和子类之间的，不具有继承关系的两种类不能谈论多态】-->

# 2.虚函数

虚函数是实现多态的基础

被virtual关键字修饰的成员函数称为虚函数。

如果将**基类**中的某个成员函数声明为虚函数，那么**子类中**与该函数具有相同原型的成员函数也就是虚函数，并且对基类中版本形成覆盖，即函数重写。

如果子类提供了对基类虚函数有效的覆盖，那么通过指向子类对象的基类指针，或者通过引用子类对象的基类引用，调用该虚函数，实际被执行的将是子类中的覆盖版本，而不再是基类中的原始版本，这种语法现象被称为**多态**。

多态的意义在于，一般情况下，调用哪个类的成员函数由调用者指针或者引用本身类型决定的，而有了多态，调用哪个类的成员函数由调用者指针或者引用的实际目标对象的类型决定。

这样一来，源自同一种类型的同一种激励，竟然可以产生多种不同的响应，也就是对于同一个函数调用，能够表达出不同的形态，即为多态。

# 3.虚函数覆盖条件

只有基类的函数被覆盖了，后面基类指针所调用的函数才能是子类的函数，才能形成多态。

- 只有类的成员函数才能声明为虚函数，而全局函数，静态成员函数，构造函数都不能被声明为虚函数，析构函数可以为虚函数
- 只有在**基类中以virtual关键字声明**的虚函数，才能作为虚函数被子类覆盖，而与子类有没有加virtual关键字无关
- 虚函数在子类中的版本和基类中版本要具有相同的函数签名，即**函数名，参数表，常属性**一致。
- 如果基类虚函数返回基本类型数据，那么子类中的版本必须返回相同类型数据；
- 如果基类虚函数返回类类型指针(A\*)或引用(A&)，那稍微放宽点，允许子类中的版本返回**子类类型**的指针或引用(B\*)(B&)。

```c++
#include <iostream>
using namespace std;
class Base{
public:
    virtual Base(){
        cout << "Base(void)" << endl;		//error: constructors cannot be declared ‘virtual’

    }
	virtual static void func1(){			 //error: member ‘func1’ cannot be declared both ‘virtual’ and ‘static’		
		cout << "static fun1" << endl;
	}
	void fun(){                               //在void前面加virtual后执行结果为：
        									  //A::fun  B::fun  C::fun
		cout << "Base::fun" << endl;
	}
};
class A:public Base{
public:
	void fun(){
		cout << "A::fun" << endl;
	}
};
class B:public Base{
public:
	void fun(){
		cout << "B::fun" << endl;
	}
};
class C:public Base{
public:
	void fun(){
		cout << "C::fun" << endl;
	}
};

int main(int argc, char *argv[]){
	Base* p[128];
	p[0] = new A;
	p[1] = new B;
	p[2] = new C;
    A a1;
	Base b1 = a1;				//向上造型，可以隐式转换。
	b1.fun();
	p[0]->fun();
	p[1]->fun();
	p[2]->fun();
	return 0;
}
```

执行结果：

```shell
Base::fun
Base::fun
Base::fun
Base::fun
```

# 4.覆盖与隐藏的区别

### 覆盖（Overriding）

覆盖发生在子类和父类有相同名称、相同参数列表（包括参数类型、顺序和数量）的虚函数（virtual function）之间。当子类定义了这样一个与父类同名的虚函数时，我们说子类覆盖了父类的虚函数。在运行时，通过基类指针或引用调用该虚函数时，会根据对象的实际类型（即对象的动态类型）来调用相应的函数版本，这被称为多态。

**特点**：

- 发生在虚函数之间。
- **函数名、参数列表必须完全相同。**
- 调用哪个函数**取决于对象的**实际类型（运行时绑定）。
- 允许子类改变父类虚函数的行为。

### 隐藏（Hiding）

隐藏发生在子类和父类有相同名称的函数之间，但参数列表不同，或者父类函数不是虚函数而子类定义了同名的函数（无论参数列表是否相同）。在这种情况下，子类函数隐藏了父类中的同名函数，而不是覆盖它。当通过基类指针或引用调用该函数时，如果调用的是被隐藏的函数，则始终调用基类中的版本，除非使用子类对象直接调用。

**特点**：

- 不限于虚函数，可以发生在**任何同名函数**之间。
- 参数列表可以不同。
- 调用哪个函数**取决于指针或引用的类型**（编译时绑定）。
- 不是多态的一种形式，因为它不依赖于对象的实际类型。

# 5.产生多态的条件

- 除了要满足函数重写的语法要求，还必须通过指针或引用调用虚函数才能表现出来。<!--【注意不能利用变量执行“变量名.函数名”的语句来调用，否则不会表现出多态性】-->
- 调用虚函数的指针也可以是this指针，当使用子类对象调用基类中的成员函数时，该函数里面的this指针将是一个基类指针类型的，且指向的是子类对象的地址，再通过this去调用满足重写要求的虚函数同样可以表现多态的语法特性。

# 6.纯虚函数

如果一个虚函数只声明不定义，称为纯虚函数或抽象方法。

## 6.1.语法格式

```c++
class 类名{
    public:
    	virtual 返回类型 函数名（形参表） = 0；
};
```

假设有图形类Figure,设计计算面积成员函数area(),Figure只是一个纯抽象意义上的概念，由于图形多种多样，不存在计算面积或体积的**具体方法**，所有只能将成员函数area()设计为纯虚函数。

## 6.2.抽象类

如果类中包含了纯虚函数，那么这个类就是抽象类，抽象类只能作为其他类的基类，不能用来建立对象，因为你成员方法都没定义，建立对象也用不了。

如果类中所有成员函数都是纯虚函数则可以称为纯抽象类。

## 6.3.总结

1.成员函数重载发生在同一个作用域内，函数名相同但参数列表（参数的数量、类型或顺序）不同的多个函数。

2.覆盖（也称为重写）发生在有继承关系的两个类中，子类有一个和父类签名完全相同的成员函数（返回类型、函数名和参数列表都必须相同）。需要注意的是，基类的成员函数必须为虚函数（使用 `virtual` 关键字）。

3.隐藏发生在有继承关系的两个类中，子类有一个和父类名称相同的成员函数，但是参数列表不同，此时子类版本的函数隐藏了所有同名的父类函数，无论父类中的函数参数列表是否相同。

# 7.虚析构函数

**问题引出：**

```c++
#include <iostream>

using namespace std;

class Base{
public:
	Base(){
		cout << "Base(void)" << endl;
	}
	static void func1(){
		cout << "static fun1" << endl;
	}
	virtual void fun(){
		cout << "Base::fun" << endl;
	}
	~Base(){
		cout << "free Base" << endl;
	}
};
class Derived:public Base{
public:
	Derived(){
		cout << "Derived(void)" << endl;
	}
	void fun(){
		cout << "A::fun" << endl;
	}
	~Derived(){
		cout << "free Derived" << endl;
	}
};
int main(int argc, char *argv[]){
	Base* p;
	p = new Derived;
	p->fun();
	delete p;
	return 0;
}
```

```shell
Base(void)
Derived(void)
A::fun
free Base
#问题在于明明调用了两个构造函数，却只调用了Base的析构函数而没调用子类的析构函数从而造成内存泄漏
```

**问题解决：**在Base类的析构函数前加virtual.

# 7.虚函数实现技术

每一个含有虚函数（无论是其自身函数继承来的）的类都至少有一个与之对应的虚函数表，其中存放着该类所有的虚函数的函数指针。占4字节

![image-20240709154659060](C:\Users\z3254406361\AppData\Roaming\Typora\typora-user-images\image-20240709154659060.png)

当编译器编译以下test函数时只知道pb是B*类型的指针，并不知道它指向的具体对象类型：

pd可能指向的是B的对象，也可能是D的对象。

只有当程序执行过程中给test函数传递了具体参数才能确定pb指向了哪个对象，从而确定访问哪个虚表，从而实现多态。

![image-20240709155142632](C:\Users\z3254406361\AppData\Roaming\Typora\typora-user-images\image-20240709155142632.png)

# 8.运行时类型信息

## 8.1.typeid操作符typeinfo类类型

- typeid操作符既可用于类型也可用于对象，返回type_info类型的类对象的常引用，用于表示类型信息。
- typeinfo类的成员函数name(),可以获取**字符串形式**的类型信息，即类对象或者变量的**名字。**

  ```c++
  #include <iostream>
  #include <typeinfo>
  using namespace std;
  class Base{};
  class A{};
  int main(int argc, char *argv[]){
      if(typeid(a) == typeid(b)){
          cout << typeid(int).name() << endl;
          cout << typeid(float).name() << endl;
          cout << typeid(string).name() << endl;
          cout << typeid(Base).name() << endl;
          cout << typeid(A).name() << endl;
      }
  	return 0;
  }
  
  i
  f
  NSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE
  4Base
  1A
  ```
- typeinfo类支持“==”和“！=”操作符，可以直接用于判断类型是否相同，如果类型之间存在**多态**的继承关系，typeid还可以利用多态的特性确定实际对象的类型。

  ```c++
  #include <iostream>
  #include <typeinfo>
  using namespace std;
  class Base{
  	public:
  		virtual void foo(){};
  };
  class A:public Base{
  	public:
  		void foo(){};
  };
  class B:public Base{
  	public:
  		void foo(){};
  };
  class C:public Base{
  	public:
  		void foo(){};
  };
  void fun(const Base& base){
  	//由于base具有多态性，但此函数不知道基类指针在程序运行时具体指向的是哪个子类的对象，故为了满足对不同子类对象执行不同逻辑的要求，需要判断base的类型，此时用到typeid
  	if(typeid(base) == typeid(A)){
  		cout << "base is A" << endl;
  	}
  	else if(typeid(base)==typeid(B))
  		cout << "base is B" << endl;
  	else if(typeid(base)==typeid(C))
  		cout << "base is C" << endl;
  	else
  		cout << "Unkonw type" << endl;
  }
  int main(int argc, char *argv[]){
  	A a;
  	B b;
  	C c;
  	fun(a);
  	fun(b);
  	fun(c);
  	return 0;
  }
  base is A
  base is B
  base is C
  ```

# >>>>>>>运算符重载>>>>>>>

运算符重载关键在于设计运算符重载函数的**返回值**和**参数**

# 1.双目运算符

## 1.1.什么是双目运算符

具有左右两个操作数的操作符L#R

## 1.2.重载实现方式

成员函数形式：L.operator#(R)

友员函数形式:  operator#(L,R)

## 1.3.算术运算符重载

- +,-,*,/,%
- <u>表达式结果是右值。</u>
- 左右操作数既可以是左值也可以是右值。

## 1.4.赋值运算符重载

=，+=，-=，*=

- <u>表达式结果是左值</u>，就是左操作数自身，为了支持x=y=100这样的链式操作。
- 左操作数必须是左值，右操作数可以是左值，也可以是右值。x=y，y=100.

# 2.单目运算符重载

~取反，-相反数，与或非，自增自减。

## 2.1.计算类单目运算符

- <u>表达式结果是右值 a = -a;</u>
- 操作数可以是左值也可以是右值 -a,-10

实现方式

​		成员函数形式：O.operator#()

​		友员函数形式:  operator#(O)

## 2.2.前缀自增减运算符

- <u>表达结果是左值，</u>而且结果返回自身，即自身内容要更新
- 操作数是左值

## 2.3.后缀自增减运算符

- <u>表达式结果是右值，</u>是操作数自增减前的副本
- 操作数必须是左值

## 2.4.[]运算符重载

- 表达式结果是左值，即要满足a[i]=x,x=a[i]这种操作，且结果是自身，不是自身的副本
- 操作数可以左值可以右值

```c++
#include <iostream>
#include <cstring>
using namespace std;

typedef char data_type;
class Work{
private:
	data_type *arry;
	int size;
public:
	Work(const char* str){
		this->size = strlen(str);
		arry = new data_type[size+1];
		strcpy(arry,str);
	}
	data_type &operator[](int index){
		if(index >= size){
			cout << "index out of range";
			return arry[size];
		}
		return arry[index];
	}
	~Work(){
		delete [] arry;
		arry = NULL;
	}
};
int main(int argc, char *argv[]){
	Work A("Hello");
	A[4] = 'A'; //[]的结果返回必须是返回引用，即a[4]该元素自身，如果不加引用，则函数系统调用返回的是a[4]的值是一个常量，给常量赋值，系统必报错。
	cout << "arry[4]:" << A[4] << endl;
	cout << "arry[5]:" << A[5] << endl;
	return 0;
}
```

# 3.特殊运算符重载

## 3.1输入输出运算符重载

注意：因为无法向标准库类添加成员函数，所以只能使用全局函数即友员形式

```c++
friend ostream& operator<<(ostream &os,const 类名& 对象名)
{
    os << "hello,world" << endl;
    return os;//cout << a << b << ....返回引用为了支持链式操作
}
friend istream& operator >> (istream &is，const 类名& 对象名)
{
    .....
    return is;
}
```

## 3.2new，delete运算符重载

- 通过new创建类对象时，将首先调用该操作符函数分配内存（可重载），然后再调用该类的构造函数。

  ```c++
  void* operator new(size_t size){
  	return malloc(size);
  }
  ```

- 通过delete销毁类对象时，将首先调用该类的析构函数，然后再调用该操作符函数释放内存（可重载）

  ```c++
  void operator delete(void* p){
      free(p);
  }
  ```

# >>>>>>>>>>异常>>>>>>>>>>

# 1.传统错误处理

## 1.1.通过函数返回值处理异常

**优点**：函数调用路径中栈对象得到正确析构，不存在内存泄漏

**缺点**：错误流程处理复杂，代码臃肿。

## 1.2.通过远程跳转处理错误

**setjmp(env)**:拍快照，保存调用setjmp的当前函数的栈针，后续如果执行到出错，可以直接通过longjmp返回到此处，因为此次留了快照。直接调用setjmp的时候是直接返回0的。而通过longjmp间接调用返回的是设置的值。

**longjmp(env,-1)**：跳转到设置env快照setjmp(env)处，并把setjmp(env)返回值设置为-1。

**优点**：代码逻辑简便，不需要进行辅助复杂的错误逻辑处理。

**缺点**：会造成内存泄漏，因为直接返回返回点，则栈中出错点到快照处中间这些调用都没被正确析构从而造成内存泄漏。

# 2.C++异常处理

## 2.1.C++异常处理关键字

**try{}**：尝试执行，检查是否会出错。

**throw：**抛出异常，一抛出异常，函数直接结束，也不会执行返回值返回，包括递归调用时，每一层调用的函数均会直接结束(**走到函数的’}‘处**)，相当于后面的语句包括return直接被无视，且并不是只有出错的那次函数调用才直接结束函数，而是后续所有的被压入栈中的函数均直接执行到右花括号那里结束，且各种被压入栈中函数里的构造的对象也会被正确析构掉（因为虽然无视后面语句，但走到}这里算是执行完函数，数，函数弹出栈，局部变量被正常释放和析构），try函数也直接结束。

**catch**{type arg}：处理异常。

## 2.2.C++异常处理流程

- **不抛出throw异常**
  ![image-20240715103604894](C:\Users\z3254406361\AppData\Roaming\Typora\typora-user-images\image-20240715103604894.png)
- **抛出throw异常**
  ![image-20240715103625859](C:\Users\z3254406361\AppData\Roaming\Typora\typora-user-images\image-20240715103625859.png)

**注意：**catch在进行数据异常类型匹配时，不会进行数据类型的默认转换，只有与异常类型**精确匹配**的catch块才会被执行。但在C++中，抛出的异常一般都是类类型的对象，增加代码可读性。可以加多个catch块，不同catch块捕获不同类型异常。

```c++
#include <iostream>
#include <cstdio>
using namespace std;
class A{
    A(){
        cout << "A(void)" << endl;
    }
    
    ~A(){
        cout << "A(~)" << endl;
    }
}；
double fun1(){
    A a1;
	FILE* fp = fopen("a.txt","r");
	if (fp == NULL)
		throw -1.0f;
	cout << "this is fun1" << endl;
	return 0.0;
}
double fun2(){
    A a2;
	fun1();
	cout << "this is fun2" << endl;
	return 0.0;
}
double fun3(){
    A a3;
	fun2();
	cout << "this is fun3" << endl;
	return 0.0;
}

int main(int argc, char *argv[]){
	try{
		fun3();
		cout << "this is try" << endl;
	}
	catch(float err){
		if(err == -1.0){
			cout << "open file failed" << endl;
			return -1;
		}
	}
	return 0;
}
```

```shell
A(void)
A(void)
A(void)
A(~)
A(~)
A(~)
open file failed


#注释掉throw语句后：
this is fun1
this is fun2
this is fun3
this is try
```

# 3.函数异常说明(C++17已抛弃)

1.当一个函数声明不带任何异常描述时，它可以抛出任何异常。

2.C++运行限制函数能够抛出的异常类型，限制方法在函数声明后面添加一个throw参数表，在其中指定函数可以抛出的异常类型。

```c++
int fun(int,char) throw(int,char);
```

函数fun被限定只允许抛出int和char类型的异常，当fun函数抛出其他类型异常时，程序将被异常终止。

3.如果函数不允许抛出任何异常，只需要指定throw限制表为不包括任何类型的空表。

```c++
int fun(int,char) throw();

c++ noexception 等价与throw();
```

# 4.标准异常类

/usr/include/c++/版本号/exception

解决会抛出成千上万种异常如何一一都catch的问题。从exception类派生异常处理类.再利用多态：即一个catch函数可以捕获各种类型错误，不必为每一个类型错误都写一个catch、函数。

```c++
#include <iostream>
#include <cstdio>
using namespace std;
class FileError:public exception{
public:
	const char *what() const throw(){
		cout << "handle file error" << endl;
		return "FileError";
	}
};
class MemoryError:public exception{
public:
	const char *what() const throw(){
		cout << "handle memory error" << endl;
		return	"MemoryError";
	}
};
void func(void) throw(FileError,MemoryError){
	throw FileError();//匿名类对象
}
int main(int argc, char *argv[]){
	MemoryError A;
	try{
		func();
	}
	catch(FileError&ex){
			cout << "open file failed" << endl;
			return -1;
	}
	catch(MemoryError&ex){
			cout << "Memory err" << endl;
			return -1;
	}
    catch(exception &ex){
    	cout << ex.what() << endl;
        return -1;
    }
	return 0;
}
```

# >>>>>>>>文件与流>>>>>>>>

# 1.IO流库概览

C++建立了一个十分庞大的流类库来实现数据的输入输出操作。其中每个流类实现不同的功能，这些类通过继承组合在一起。

ios类是istream和ostream类的虚基类，用来提供对流进行格式化I/O操作和错误处理的成员函数。streambuf主要作为其他类的支持，定义了对缓冲区的通用操作，如设置缓冲区，读写缓冲区等操作。![image-20240924081743198](C:\Users\z3254406361\AppData\Roaming\Typora\typora-user-images\image-20240924081743198.png)

![image-20240715202030977](C:\Users\z3254406361\AppData\Roaming\Typora\typora-user-images\image-20240715202030977.png)

typedef basic_istream<char\>   istream

typedef basic_ostream<char\>  ostream

# 2.标准输入输出流对象

- **cout**
  ostream cout与标准输出设备关联
- **cin**
  istream cin与标准输入设备关联
- **cerr**
  ostream cerr与标准出错设备关联（非缓冲方式）
- **clog**
  ostream clog与标准出错设备关联（缓冲方式）

# 3.istream类

## 3.1.<<运算符

对输入运算符 ‘<<’ 进行了重载，实现了对c++那些基本的即系统内置的数据量的输入功能,但输入字符串时**<u>遇到空格结束</u>**

## 3.2.常用的成员函数

### 3.2.1.读取一个字符

```c++
int_type get();
//无参get函数，读取一个字符

basic_istream& get(char_type& ch);
//从输入流中读一个字符到ch里，包括空白符
```

### 3.2.2.读取一行

```c++
basic_istream& getline(char_type* s,std::streamsize count);
//读一行数据，读取count个字符，遇到到'\n'结束。实际只读cout-1个，最后一个自动加\0
basic_istream& getline(char_type* s,std::streamsize cout,char_type delim);
//读一行数据，读取count个字符，直到行末或者遇到delim（不会存储）终止字符停止。不加delim默认是'\n'。可以读取带空格的字符串，实际只读cout-1个，最后一个自动加\0
```

### 3.2.3.一次性读取count个字符

```c++
basic_istream& read(char_type* s,std::streamsize cout);
```

### 3.2.4.丢弃忽略字符

```c++
basic_istream& ignore(std::streamsize cout = 1,int_type delim = Traits::eof());
//从输入流中读取字符并丢弃
```

# 4.ostream类

```c++
basic_ostream& write(const char_type* s,std::streamsize cout);
basic_ostream& put(char_type ch);
//可以玩链式操作
    cout << "hello";
	cout.put('w').put('o').put('r').put('l').put('d');
```

# 5.输入输出格式化控制

- 操纵符（本质就是一堆全局函数）

  ```c++
  #include <iostream>
  #include <sstream>
  using namespace std;
  int main()
  {
      cout << "The number 42 in octal:   " << oct << 42 << '\n'
           << "The number 42 in decimal: " << dec << 42 << '\n'
           << "The number 42 in hex:     " << hex << 42 << '\n';
      cout << setw(10) << << setfill('0') << 123 << endl;
  }
  //执行结果
  The number 42 in octal:   52
  The number 42 in decimal: 42
  The number 42 in hex:     2a
  0000000123//设置位宽为10，不够填0
  ```

- 成员函数

  ```c++
  cout.width(10);
  cout.fill('0');
  cout.setf(ios::hex);//格式化输出，16进制输出
  cout.setf(left);//左对齐
  cout << 123 << endl;
  ```

# 6.string流(继承自iostream)

类似于C里的sprint和sscanf的效果。

```c++
ostringstream oss;
int i = 123;
float d = 56.78;
char s[] = "hello"
oss << i << ' ' << d << ' ' << s;//oss里存的就是123 56.78 hello，类似于sprintf
cout << oss.str() << endl;//输出的是123 56.78 hello

istringstream iss;
iss.str("100 1.24 world");
iss >> i >> d >> s;//类似于sscanf
```

# 7.文件流(继承自iostream)

## 7.1.ofstream

```c++
int i = 123;
float d = 56.78;
char s[] = "hello"
ofstream ofs("a.txt");
ofs << i << ' '<< d << ' '<< s <<endl;
ofs.close();
```

## 7.2.ifstream

当读取内容与接收变量的类型一致时，一直读取直到遇到空白字符或者数据类型不匹配。

```c++
ifstream ofs("a.txt"); 
//a.txt 123 45.78 hello world,以空白字符为结束
int i2;
float d2;
string s2;//只输入hello
ofs >> i2 >> d2 >> s2;
ofs.close();
```

# ——泛型编程——

# 模板

​	模板（template）是C++实现代码重用机制的重要工具，是泛型技术（即与数据类型无关的通用程序设计技术）的基础。模板表示的是概念级的通用程序设计方法，它把算法和数据类型区分开来，能够设计出独立于具体数据类型的模板程序，模板程序能以数据类型为参数生成针对于该类型的实际程序代码。模板分为函数模板和类模板两类。

## 模板的概念

**痛点**：逻辑一样但仅仅是数据类型不一样，虽然有函数重载，但相同代码要写好多遍。

```c++
int Min(int a,int b){
    return a < b ? a : b;
}
float Min(float a,float b){
    return a < b ? a : b;
}
double Min(double a,double b){
    return a < b ? a : b;
}
char Min(char a,char b){
    return a < b ? a : b;
}
```

**解决：**C++的模板与制作冰糕的模具相似，是生成函数或类的模具。模板接受数据类型参数，并根据此类型创建相应的函数或类。

针对上面所有的Min()函数，只需要下面的函数模板就能够生成所有的Min函数.

```c++
template <typename T>
T Min(T a,T b){
    return a<b?a:b;
}
//编译器用调用模板函数时传入参数的具体的类型替换T，即可生成对应的函数，如用int替换T，就生成了int类型的Min函数
int main(){
    int m=9,n=3;
    double d1=1.8,d2=3.4;
    cout << Min(m,n) << endl;
    cout << Min(d1,d2) << endl;
}
```

template和typename是用来定义模板的关键字。min模板不涉及任何具体的数据类型，而是用T代表任意数据类型，称为类型参数。min模板代表了求两个数值最小值的通用算法，它与具体数据类型无关，但能够生成计算各种数据类型的最小值的函数。编译器的做法是用具体的类型替换模板中的类型参数T，生成具体类型的函数min（）。

从函数模板min()可以看出，C++模板提供了对逻辑结构相同的数据对象通用行为的定义方法，它把通用算法的实现和具体的数据类型区分开来。

## 函数模板

###  函数模板定义

```c++
template <typename T1,typename T2,...>
返回类型 函数名(参数列表){
    //多个形参可以是多种数据类型T1,T2,T3。。。
}
```

### 函数模板实例化

​	当编译器遇到关键字template和跟随其后的参数定义时，它只是简单地知道这个函数模板在后面地程序代码中可能会用到，相当于做了一个标记。除此之外，编译器并不会做额外工作。在这个阶段函数模板本身并不能使编译器产生任何代码，因为编译器此时并不知道函数模板要处理地具体数据类型，根本无法参数任何函数代码。

​	当编译器遇到程序中对函数模板的调用时，他才会根据调用语句中实参的具体类型，确定模板参数的数据类型，并用此类型替换函数模板的模板参数，生成能够处理该类型的函数代码，即模板函数。

[【C++】模板进阶（非类型模板参数、类模板的特化和模板的分离编译）-CSDN博客](https://blog.csdn.net/m0_67821824/article/details/130067951)

​	模版参数传非类型参数可以理解为为模版函数多增加一个函数参数，从而避免函数参数列表参数过多。

**可以通过以下命令来查看**：

```shell
nm a.out | grep Min
```

### 模板参数

- **模板参数匹配问题**

  C++在实例化函数模板的过程中，只是简单地将模板参数的替换为实参的类型，并以此生成模板函数，不会进行参数类型的任何转换。

  ```c++
  template <typename T>
  T Min(T a,T b){
      return a<b?a:b;
  }
  int main(){
      int m=9,n=3;
      double d1=1.8,d2=3.4;
      cout << Min(m,d1) << endl;//error，no matching function Min(int,float);当编译器想生成两个形参类型不一样的函数时，发现只有形参类型一样的函数的定义，就直接报错了。
  }
  //解决方法：
  1.调用函数时对传入的参数进行强转。
  2.调用时用Min<double>(m,d1),直接把T指定为double。相当于写一个doblue Min(double a,double b)
  3.使用指定多个参数的模板：
      template <typename T1,typename T2>
  	T1 Min(T1 a,T2 b){
      //此函数涉及到的数据类型有1~2种，因为T1可以与T2一样，因此调用此参数时传入的实参的数据类型为1~2种的均不会报错。
      	return a < b ? a : b;
  	}
  //当编译器想生成两个形参类型不一样的函数时，发现有形参类型不一样的函数的定义，就不会报错了。
  //T1可以与T2一样，也可以不一样，因此此模板可以用于形参数据类型相同也可以不同的函数。
  ```

- **模板函数的形参表**
  函数模板中的参数或者返回值既可以是T类型形参，也可以是int这些确切的普通类型的参数。

### 函数模板的特化

![image-20240715224919802](C:\Users\z3254406361\AppData\Roaming\Typora\typora-user-images\image-20240715224919802.png)

```c++
template<>
返回类型 函数名<特化的数据类型>(参数表){

}
// 特化版本，针对const char*类型
template<>  
const char* Max<const char*>(const char* s1, const char* s2) {  
    return (strcmp(s1, s2) > 0) ? s1 : s2;  
}  
```

## 类模板

### 类模板的定义

​	用类模板解决堆栈类成员函数的重写问题，类模板可以接受类型作为参数，设计出与具体类型无关的通用类。在设计类模板时，可以使其中的某些数据成员，成员函数的参数或返回值与具体类型无关。

```c++
template <typename T1,typename T2>
class 类名{
    ... ...
};
template <typename T1,int a>
class 类名{
    ... ...
};
```

### 类模板的实例化

​	类模板的实例化包括模板实例化和成员函数实例化。当用类模板定义对象时，将引起类模板的实例化。在实例化模板时，如果模板参数是类型参数，则必须为它指定具体的类型；如果模板参数是非类型参数，则**必须为它指定一个常量值。**

```c++
Stack<int,10> //会被编译器翻译成有具体类型的普通类一样
istack;//声明类对象
```

编译器实例化Stack的方法是：将Stack模板声明中的所有类型参数T替换为int，将所有的非类型参数MAXSIZE替换为10，这样就用Stack模板生成了一个int类型模板类。为了区别于普通类，暂且将该类记作Stack<int，10>,即在类模板名后面的一对<>中写上模板参数。但在实例化对象时，不会实例化成员函数，只有在成员函数被调用时才会生成成员函数真正的代码。

与普通类的对象一样，**类模板(stack(T,10))**的对象或者引用也可以作为函数的参数，只不过这类函数通常是模板函数，且其调用实参常常是该类模板的模板类对象。

```c++
template <typename T>
void display(stack<T,10> &s)
{
    ... ...;
}
```

### 类模板特化

如：设计一个通用数组类，它能够直接存取数组元素。并能够输出数组中的最小值。同样对于char*类型需要特化，如果不做特化，则直接比char*指针地址大小，不是比char*所指字符串内容。

**特化某个成员函数**

```c++
template <>
返回类型 类模板名<特化的数据类型>::特化成员函数名(参数表){
	... ...
}
template<>
char* Arr<char*>::Min(){
    char *tmp;
    tmp = arr[0];
    for(int i = 1;i < size;i++){
        if(strcmp(tmp,arr[i]) > 0)
            tmp = arr[i];
    }
    return tmp;
}
```

**特化整个类模板**

此外，为了某种数据类型特化整个类模板，整个类模板也要以template<>开头，形式如下：

```c++
template <>
class 类模板名<特化数据类型>{
};
```

# 2.STL

STL就是标准模板库，它提供了模板化的通用类和通用函数。STL的核心内容包括容器，迭代器，算法三部分内容，三者常常协调工作，为各种编程问题提供有效的解决方案。

## 2.1.容器

容器是用来存储其他对象的对象。容器是容器类的实例，而容器类使用类模板实现的，适用于各种数据类型。STL的容器被分为顺序容器，关联容器和容器适配器三类。顺序容器常被称为序列容器，它是将相同类型对象的有限集按顺序组织在一起的容器，用来表示线性数据结构，C++提供的顺序类型容器有向量（vector），链表，双端队列；关联容器是非线性容器，是用来根据键（key）进行快速存储，检索数据的容器。这类容器可以存储值的集合或键值对，C++中的关联容器主要包括集合，多重集合，映射，多重映射；容器适配器主要指堆栈和队列，它们实际是受限制访问的顺序容器类型。

- vector：实际就是一个动态数组，即可以进行插入删除，在此过程中，vector会动态调整所占用的内存空间。

  ```c++
  #include <vector> //类模板vector <T>在此头文件中定义
  using namespace std; //类模板的作用域是std
  
  1.构造函数：
  vector(size_type count,const T& value = T(),const Allocator& alloc = Allocator());
  //vector <string> words1(10,'hello');
  
  explicit vector( size_type count );
  //vector <int> arry(10);
  
  vector(const vector& other );
  //vector <string>  words2(words1)
  
  vector( std::initializer_list<T> init,const Allocator& alloc = Allocator());
  
  //vector<string> words3 {"the", "frogurt", "is", "also", "cursed"};
  
  
  2.成员函数：
      
  ```

## 2.2.迭代器

迭代器是一个对象，常用于遍历容器，即在容器中实现“取得下一个元素”的操作。不管容器是否直接提供了访问其对象的方法，通过迭代器都能够访问该容器中的元素，一次访问一个元素。

若某个容器要使用迭代器，它就必须定义迭代器。定义迭代器时，必须指定迭代器所使用的容器类型。比如，若定义一个保存int类型元素的链表：

```c++
list <int> L1;
```

则为int类型的list容器指定迭代器的定义如下：

```c++
list <int>::iterator iter;
```

迭代器提供的主要操作如下：

```c++
operator*                     返回当前位置的元素值
operator++					  将迭代器前进到下一个元素位置
operator--					  将迭代器后退到前一个元素位置
operator== 或者!=				 判断两个迭代器是否指向同一个位置
operator=					  为迭代器赋值						
```

begin和end

![image-20240716211956209](C:\Users\z3254406361\AppData\Roaming\Typora\typora-user-images\image-20240716211956209.png)

## 2.3关联式容器

STL关联式容器包括集合和映射两大类，集合包括set和multiset，映射包括map和multimap，它们通过关键字存储和查找元素。在每种关联容器中，关键字按顺序排列，容器遍历就可以顺序进行。

- **set和multiset**
  集合类multiset和set提供了控制数字（包括字符及串）集合的操作，集合中的数字称为关键字，不需要有另一个值与关键字相关联。set和multiset会根据特定的排序准则，自动将元素排序，两者提供的操作方法基本相同，只是multiset允许元素重复而set不允许重复。
  ![image-20240716182859635](C:\Users\z3254406361\AppData\Roaming\Typora\typora-user-images\image-20240716182859635.png)

  ```c++
  #include <iostream>
  #include <set>
  using namespace std;
  
  int main(void){
  	int a1[] = {-1,-1,2,3,11,6,10,2,10,23,0};
  	set <int,greater<int> > set1(a1,a1+11);//greater表示从大到小的排序方式，默认是less从小到大
  	set1.insert(4);
  	set<int,greater<int> >::iterator it;
  	for(it=set1.begin();it != set1.end(); it++){
  		cout << *it << " ";
  	}
  	cout << endl;
  
  	string a2[] = {"赵云","张飞","关羽","马超","黄忠","张辽","刘备"};
  	multiset<string> set2(a2,a2+7);
  	multiset<string>::iterator it2;
  	set2.insert("赵云");
  	for(it2=set2.begin();it2 != set2.end(); it2++){
  		cout << *it2 << " ";
  	}
  	cout << endl;
  	return 0;
  }
  ```

  ```shell
  23 11 10 6 4 3 2 0 -1  #不可重复
  关羽 刘备 张辽 张飞 赵云 赵云 马超 黄忠 #可重复
  ```

- **map和multimap**
  map个multimap提供了操作<键，值>对的方法，他们存储一对对象，即键对象和值对象，键对象用于查找过程中的键，值是与键对应的附加数据。例如,若键为单词，对应的值是表示该单词在文档中出现此数的数字，这样map就成了统计单词在文本中出现次数的频数表；再如，若键为单词，值是单词出现的页号链表，用multimap实现这样的键值对象就是可以构造单词索引表。
  ![image-20240716193947144](C:\Users\z3254406361\AppData\Roaming\Typora\typora-user-images\image-20240716193947144.png)
  **定义：**
  前面介绍的set/multiset集合操作的方法同样适用于map/multimap，包括集合的建立方法，成员函数，比较运算，排序规则和方法等，只需要将其中的set更改为map，将multiset更改为multimap即可。需要说明的只有insert函数和访问元素不同。
  **insert成员函数：**
  从形式上看，map/multimap集合的insert成员都具有相同的形式，但insert插入到map/multimap中的元素是<键，值>构成的一对数据，这对数据是一个不可分割的整体。
  **元素访问：**
  map/multimap类型的迭代器提供了两个数据成员：一个是first，用于访问键；一个是second用于访问值。此外map类型的映射可以用键作为数字下标，访问该键所对应的值，**但multimap类型的映射不允许用数字下标的方式访问其中的元素。**
  **注意：**
  1.利用数组下标访问map时，如果map中不存在访问的键，则会给map加上该键并赋值为0，其实数组下标用于访问是不准确的，应该是用于插入map的。
  2.利用迭代器访问时不会出现上述情况。

  ```c++
  #include <iostream>
  #include <map>
  using namespace std;
  
  int main(int argc, char *argv[]){
  	string name[] = {"Tom","Bob","Jack"};
  	double salary[] = {15000,14000,13000};
  	map <string,double> m1;
  	map <string,double>::iterator it;
      /******/
      /*插入*/
      /******/
  	for(int i = 0; i < 3;i++){
  		m1.insert(make_pair(name[i],salary[i]));
  		//要先构造键值对才能插入
  	}
      m1["Alice"] = 20000;
  	m1["Jon"] = 12000;
      /******/
  	/*访问*/
      /******/
  	for(it = m1.begin();it != m1.end();it++){
  		cout << it->first << ":" << it->second << endl;
  	}
  	return 0;
  }
  ```

  ```shell
  Alice:20000
  Bob:14000
  Jack:13000
  Jon:12000
  Tom:15000
  ```

## 2.4算法

算法是用于模板技术实现的适用于于各种容器的通用程序。算法常常通过迭代器间接地操作容器元素，而且通常会返回**迭代器**作为算法运算的结果。

- **find和count算法**：
  find用于查找指定数据在某个区间中是否存在，该函数返回等于指定值的第一个元素位置，如果没有就返回最后元素位置；count用于统计某个值在指定区间出现的次数，其用法如下：

  ```c++
  find(beg,end,value);
  count(beg,end,value);
  ```

- **serch算法**：
  find算法从一个容器中查找指定的值，search算法则是从一个容器查找由另一个容器所指定的顺序值。

  ```c++
  search(beg1,end1,beg2,end2)//左闭右开
  ```

  serach将在[beg1,ebd1]区间查找有无与[beg2,end2)相同的子区间，如果找到返回[beg1,end1)内第一个相同元素的位置，如果没有找到返回end1；

- **merge算法**：

  ```c++
  merge(beg1,end1,beg2,end2,dest)
      //将[beg1,end1)区间与[beg2,end2)区间进行合并，放到dest中去，如果合并前有序，合并后仍然有序。不会去重！！
  ```

  容器链表的merge成员函数更简单：

  ```c++
  L1.merge(L2);
  ```

- **sort算法**：
  对指定区间进行排序，默认是从小到大

  ```c++
  sort(beg,end);//左闭右开
  ```

  # 3。

