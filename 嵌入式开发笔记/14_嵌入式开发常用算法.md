# 循环冗余检验 (CRC) 

Cyclic Redundancy Check循环冗余检验，是基于数据计算一组效验码，用于核对数据传输过程中是否被更改或传输错误。

## 1.CRC概念

​	假设数据传输过程中需要发送15位的二进制信息g=1010011 10100001，这串二进制码可表示为代数多项式g(x) = x^14 + x^12 + x^9 + x^8 + x^7 + x^5 + 1，其中g中第k位的值，对应g(x)中x^k的系数。将g(x)乘以x^m，即将g后加m个0，然后除以m阶多项式h(x)，得到的(m-1)阶余项r(x)对应的二进制码r就是CRC编码。

​	h(x)可以自由选择或者使用国际通行标准，一般按照h(x)的阶数m，将CRC算法称为CRC-m，比如CRC-32、CRC-64等。国际通行标准可以参看http://en.wikipedia.org/wiki/Cyclic_redundancy_check。

## 2.CRC算法规律原理

​	g(x)和h(x)的除运算是模2除，而模2除的本质是异或，因此可以通过g和h做xor（异或）运算。又因为校验码是余数，故只需要关注余数，而不是商、

​	举一个例子使用[CRC](https://so.csdn.net/so/search?q=CRC&spm=1001.2101.3001.7020)-8算法求101001110100001的效验码。CRC-8标准的h(x) = x^8 + x^7 + x^6 + x^4 + x^2 + 1，即h是9位的二进制串111010101。

![image-20250318093315898](figure\image-20250318093315898.png) 

​	经过迭代运算后，最终得到的r是10001100，这就是CRC效验码。通过示例，可以发现一些规律，依据这些规律编写算法：

- 每次迭代，根据gk的首位决定b，b是与gk进行运算的二进制码。若gk的首位是1，则b=h\*1；若gk的首位是0，则b=h\*0，或者跳过此次迭代，上面的例子中就是碰到0后直接跳到后面的非零位。
- 每次迭代，gk的首位将会被移出，所以只需考虑第2位后计算即可。这样就可以舍弃h的首位，将b取h的后m位。比如CRC-8的h是111010101，b只需是11010101。 因为b的首位和gk的首位都必为1，而相同的数异或结果为0，而0又必定被移出，因此第一位可以不算直接跳过。
- 每次迭代，受到影响的是gk的前m位（**指移出首位后的前m位**），所以构建一个m位的寄存器S，此寄存器储存gk的前m位。每次迭代计算前先将S的首位抛弃，即将寄存器左移一位，同时将g的后一位加入寄存器，然后再与被舍弃首位的b（如果此处迭代S被抛弃首位为1，则b = h，如果为0.则b = 0）做异或运算，得到结果。然后再利用结果按上述步骤循环迭代。![image-20250318095830599](figure\image-20250318095830599.png)

## 3.查表法